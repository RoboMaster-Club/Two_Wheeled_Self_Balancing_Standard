ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"mpc.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "HigherLevelApps/HigherLevelApps.c/mpc.cpp"
  20              		.section	.rodata._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei.str1.4,"aMS",%progbits,1
  21              		.align	2
  22              	.LC0:
  23 0000 76203D3D 		.ascii	"v == T(Value)\000"
  23      20542856 
  23      616C7565 
  23      2900
  24 000e 0000     		.align	2
  25              	.LC1:
  26 0010 45696765 		.ascii	"Eigen::internal::variable_if_dynamic<T, Value>::var"
  26      6E3A3A69 
  26      6E746572 
  26      6E616C3A 
  26      3A766172 
  27 0043 6961626C 		.ascii	"iable_if_dynamic(T) [with T = int; int Value = 3]\000"
  27      655F6966 
  27      5F64796E 
  27      616D6963 
  27      28542920 
  28 0075 000000   		.align	2
  29              	.LC2:
  30 0078 2E2F4569 		.ascii	"./Eigen/src/Core/util/XprHelper.h\000"
  30      67656E2F 
  30      7372632F 
  30      436F7265 
  30      2F757469 
  31              		.section	.text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei,"axG",%progbits,_ZN5Eigen8intern
  32              		.align	1
  33              		.weak	_ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei
  34              		.syntax unified
  35              		.thumb
  36              		.thumb_func
  38              	_ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:
  39              		.fnstart
  40              	.LVL0:
  41              	.LFB9412:
  42              		.file 2 "./Eigen/src/Core/util/XprHelper.h"
   1:./Eigen/src/Core/util/XprHelper.h **** // This file is part of Eigen, a lightweight C++ template library
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 2


   2:./Eigen/src/Core/util/XprHelper.h **** // for linear algebra.
   3:./Eigen/src/Core/util/XprHelper.h **** //
   4:./Eigen/src/Core/util/XprHelper.h **** // Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/util/XprHelper.h **** // Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>
   6:./Eigen/src/Core/util/XprHelper.h **** //
   7:./Eigen/src/Core/util/XprHelper.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/util/XprHelper.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/util/XprHelper.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/util/XprHelper.h **** 
  11:./Eigen/src/Core/util/XprHelper.h **** #ifndef EIGEN_XPRHELPER_H
  12:./Eigen/src/Core/util/XprHelper.h **** #define EIGEN_XPRHELPER_H
  13:./Eigen/src/Core/util/XprHelper.h **** 
  14:./Eigen/src/Core/util/XprHelper.h **** // just a workaround because GCC seems to not really like empty structs
  15:./Eigen/src/Core/util/XprHelper.h **** // FIXME: gcc 4.3 generates bad code when strict-aliasing is enabled
  16:./Eigen/src/Core/util/XprHelper.h **** // so currently we simply disable this optimization for gcc 4.3
  17:./Eigen/src/Core/util/XprHelper.h **** #if EIGEN_COMP_GNUC && !EIGEN_GNUC_AT(4,3)
  18:./Eigen/src/Core/util/XprHelper.h ****   #define EIGEN_EMPTY_STRUCT_CTOR(X) \
  19:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X() {} \
  20:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE X(const X& ) {}
  21:./Eigen/src/Core/util/XprHelper.h **** #else
  22:./Eigen/src/Core/util/XprHelper.h ****   #define EIGEN_EMPTY_STRUCT_CTOR(X)
  23:./Eigen/src/Core/util/XprHelper.h **** #endif
  24:./Eigen/src/Core/util/XprHelper.h **** 
  25:./Eigen/src/Core/util/XprHelper.h **** namespace Eigen {
  26:./Eigen/src/Core/util/XprHelper.h **** 
  27:./Eigen/src/Core/util/XprHelper.h **** namespace internal {
  28:./Eigen/src/Core/util/XprHelper.h **** 
  29:./Eigen/src/Core/util/XprHelper.h **** template<typename IndexDest, typename IndexSrc>
  30:./Eigen/src/Core/util/XprHelper.h **** EIGEN_DEVICE_FUNC
  31:./Eigen/src/Core/util/XprHelper.h **** inline IndexDest convert_index(const IndexSrc& idx) {
  32:./Eigen/src/Core/util/XprHelper.h ****   // for sizeof(IndexDest)>=sizeof(IndexSrc) compilers should be able to optimize this away:
  33:./Eigen/src/Core/util/XprHelper.h ****   eigen_internal_assert(idx <= NumTraits<IndexDest>::highest() && "Index value to big for target ty
  34:./Eigen/src/Core/util/XprHelper.h ****   return IndexDest(idx);
  35:./Eigen/src/Core/util/XprHelper.h **** }
  36:./Eigen/src/Core/util/XprHelper.h **** 
  37:./Eigen/src/Core/util/XprHelper.h **** // true if T can be considered as an integral index (i.e., and integral type or enum)
  38:./Eigen/src/Core/util/XprHelper.h **** template<typename T> struct is_valid_index_type
  39:./Eigen/src/Core/util/XprHelper.h **** {
  40:./Eigen/src/Core/util/XprHelper.h ****   enum { value =
  41:./Eigen/src/Core/util/XprHelper.h **** #if EIGEN_HAS_TYPE_TRAITS
  42:./Eigen/src/Core/util/XprHelper.h ****     internal::is_integral<T>::value || std::is_enum<T>::value
  43:./Eigen/src/Core/util/XprHelper.h **** #elif EIGEN_COMP_MSVC
  44:./Eigen/src/Core/util/XprHelper.h ****     internal::is_integral<T>::value || __is_enum(T)
  45:./Eigen/src/Core/util/XprHelper.h **** #else
  46:./Eigen/src/Core/util/XprHelper.h ****     // without C++11, we use is_convertible to Index instead of is_integral in order to treat enums
  47:./Eigen/src/Core/util/XprHelper.h ****     internal::is_convertible<T,Index>::value && !internal::is_same<T,float>::value && !is_same<T,do
  48:./Eigen/src/Core/util/XprHelper.h **** #endif
  49:./Eigen/src/Core/util/XprHelper.h ****   };
  50:./Eigen/src/Core/util/XprHelper.h **** };
  51:./Eigen/src/Core/util/XprHelper.h **** 
  52:./Eigen/src/Core/util/XprHelper.h **** // true if both types are not valid index types
  53:./Eigen/src/Core/util/XprHelper.h **** template<typename RowIndices, typename ColIndices>
  54:./Eigen/src/Core/util/XprHelper.h **** struct valid_indexed_view_overload {
  55:./Eigen/src/Core/util/XprHelper.h ****   enum { value = !(internal::is_valid_index_type<RowIndices>::value && internal::is_valid_index_typ
  56:./Eigen/src/Core/util/XprHelper.h **** };
  57:./Eigen/src/Core/util/XprHelper.h **** 
  58:./Eigen/src/Core/util/XprHelper.h **** // promote_scalar_arg is an helper used in operation between an expression and a scalar, like:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 3


  59:./Eigen/src/Core/util/XprHelper.h **** //    expression * scalar
  60:./Eigen/src/Core/util/XprHelper.h **** // Its role is to determine how the type T of the scalar operand should be promoted given the scala
  61:./Eigen/src/Core/util/XprHelper.h **** // The IsSupported template parameter must be provided by the caller as: internal::has_ReturnType<S
  62:./Eigen/src/Core/util/XprHelper.h **** // Then the logic is as follows:
  63:./Eigen/src/Core/util/XprHelper.h **** //  - if the operation is natively supported as defined by IsSupported, then the scalar type is not
  64:./Eigen/src/Core/util/XprHelper.h **** //  - otherwise, NumTraits<ExprScalar>::Literal is returned if T is implicitly convertible to NumTr
  65:./Eigen/src/Core/util/XprHelper.h **** //  - otherwise, ExprScalar is returned if T is implicitly convertible to ExprScalar AND that this 
  66:./Eigen/src/Core/util/XprHelper.h **** //  - In all other cases, the promoted type is not defined, and the respective operation is thus in
  67:./Eigen/src/Core/util/XprHelper.h **** template<typename ExprScalar,typename T, bool IsSupported>
  68:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg;
  69:./Eigen/src/Core/util/XprHelper.h **** 
  70:./Eigen/src/Core/util/XprHelper.h **** template<typename S,typename T>
  71:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg<S,T,true>
  72:./Eigen/src/Core/util/XprHelper.h **** {
  73:./Eigen/src/Core/util/XprHelper.h ****   typedef T type;
  74:./Eigen/src/Core/util/XprHelper.h **** };
  75:./Eigen/src/Core/util/XprHelper.h **** 
  76:./Eigen/src/Core/util/XprHelper.h **** // Recursively check safe conversion to PromotedType, and then ExprScalar if they are different.
  77:./Eigen/src/Core/util/XprHelper.h **** template<typename ExprScalar,typename T,typename PromotedType,
  78:./Eigen/src/Core/util/XprHelper.h ****   bool ConvertibleToLiteral = internal::is_convertible<T,PromotedType>::value,
  79:./Eigen/src/Core/util/XprHelper.h ****   bool IsSafe = NumTraits<T>::IsInteger || !NumTraits<PromotedType>::IsInteger>
  80:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg_unsupported;
  81:./Eigen/src/Core/util/XprHelper.h **** 
  82:./Eigen/src/Core/util/XprHelper.h **** // Start recursion with NumTraits<ExprScalar>::Literal
  83:./Eigen/src/Core/util/XprHelper.h **** template<typename S,typename T>
  84:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg<S,T,false> : promote_scalar_arg_unsupported<S,T,typename NumTraits<S>::Li
  85:./Eigen/src/Core/util/XprHelper.h **** 
  86:./Eigen/src/Core/util/XprHelper.h **** // We found a match!
  87:./Eigen/src/Core/util/XprHelper.h **** template<typename S,typename T, typename PromotedType>
  88:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg_unsupported<S,T,PromotedType,true,true>
  89:./Eigen/src/Core/util/XprHelper.h **** {
  90:./Eigen/src/Core/util/XprHelper.h ****   typedef PromotedType type;
  91:./Eigen/src/Core/util/XprHelper.h **** };
  92:./Eigen/src/Core/util/XprHelper.h **** 
  93:./Eigen/src/Core/util/XprHelper.h **** // No match, but no real-to-integer issues, and ExprScalar and current PromotedType are different,
  94:./Eigen/src/Core/util/XprHelper.h **** // so let's try to promote to ExprScalar
  95:./Eigen/src/Core/util/XprHelper.h **** template<typename ExprScalar,typename T, typename PromotedType>
  96:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg_unsupported<ExprScalar,T,PromotedType,false,true>
  97:./Eigen/src/Core/util/XprHelper.h ****    : promote_scalar_arg_unsupported<ExprScalar,T,ExprScalar>
  98:./Eigen/src/Core/util/XprHelper.h **** {};
  99:./Eigen/src/Core/util/XprHelper.h **** 
 100:./Eigen/src/Core/util/XprHelper.h **** // Unsafe real-to-integer, let's stop.
 101:./Eigen/src/Core/util/XprHelper.h **** template<typename S,typename T, typename PromotedType, bool ConvertibleToLiteral>
 102:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg_unsupported<S,T,PromotedType,ConvertibleToLiteral,false> {};
 103:./Eigen/src/Core/util/XprHelper.h **** 
 104:./Eigen/src/Core/util/XprHelper.h **** // T is not even convertible to ExprScalar, let's stop.
 105:./Eigen/src/Core/util/XprHelper.h **** template<typename S,typename T>
 106:./Eigen/src/Core/util/XprHelper.h **** struct promote_scalar_arg_unsupported<S,T,S,false,true> {};
 107:./Eigen/src/Core/util/XprHelper.h **** 
 108:./Eigen/src/Core/util/XprHelper.h **** //classes inheriting no_assignment_operator don't generate a default operator=.
 109:./Eigen/src/Core/util/XprHelper.h **** class no_assignment_operator
 110:./Eigen/src/Core/util/XprHelper.h **** {
 111:./Eigen/src/Core/util/XprHelper.h ****   private:
 112:./Eigen/src/Core/util/XprHelper.h ****     no_assignment_operator& operator=(const no_assignment_operator&);
 113:./Eigen/src/Core/util/XprHelper.h ****   protected:
 114:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEFAULT_COPY_CONSTRUCTOR(no_assignment_operator)
 115:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(no_assignment_operator)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 4


 116:./Eigen/src/Core/util/XprHelper.h **** };
 117:./Eigen/src/Core/util/XprHelper.h **** 
 118:./Eigen/src/Core/util/XprHelper.h **** /** \internal return the index type with the largest number of bits */
 119:./Eigen/src/Core/util/XprHelper.h **** template<typename I1, typename I2>
 120:./Eigen/src/Core/util/XprHelper.h **** struct promote_index_type
 121:./Eigen/src/Core/util/XprHelper.h **** {
 122:./Eigen/src/Core/util/XprHelper.h ****   typedef typename conditional<(sizeof(I1)<sizeof(I2)), I2, I1>::type type;
 123:./Eigen/src/Core/util/XprHelper.h **** };
 124:./Eigen/src/Core/util/XprHelper.h **** 
 125:./Eigen/src/Core/util/XprHelper.h **** /** \internal If the template parameter Value is Dynamic, this class is just a wrapper around a T v
 126:./Eigen/src/Core/util/XprHelper.h ****   * can be accessed using value() and setValue().
 127:./Eigen/src/Core/util/XprHelper.h ****   * Otherwise, this class is an empty structure and value() just returns the template parameter Val
 128:./Eigen/src/Core/util/XprHelper.h ****   */
 129:./Eigen/src/Core/util/XprHelper.h **** template<typename T, int Value> class variable_if_dynamic
 130:./Eigen/src/Core/util/XprHelper.h **** {
 131:./Eigen/src/Core/util/XprHelper.h ****   public:
 132:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(variable_if_dynamic)
 133:./Eigen/src/Core/util/XprHelper.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v) { EIGEN_ONLY_USED_FOR_D
  43              		.loc 2 133 52 view -0
  44              		.cfi_startproc
  45              		@ args = 0, pretend = 0, frame = 0
  46              		@ frame_needed = 0, uses_anonymous_args = 0
  47              	.LBB339:
  48              		.loc 2 133 109 is_stmt 0 view .LVU1
  49 0000 0329     		cmp	r1, #3
  50 0002 00D1     		bne	.L6
  51              	.LBE339:
  52              		.loc 2 133 138 view .LVU2
  53 0004 7047     		bx	lr
  54              	.L6:
  55              		.loc 2 133 52 discriminator 1 view .LVU3
  56 0006 08B5     		push	{r3, lr}
  57              		.save {r3, lr}
  58              	.LCFI0:
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 3, -8
  61              		.cfi_offset 14, -4
  62              	.LBB340:
  63              		.loc 2 133 109 discriminator 1 view .LVU4
  64 0008 024B     		ldr	r3, .L7
  65 000a 034A     		ldr	r2, .L7+4
  66 000c 8521     		movs	r1, #133
  67              	.LVL1:
  68              		.loc 2 133 109 discriminator 1 view .LVU5
  69 000e 0348     		ldr	r0, .L7+8
  70              	.LVL2:
  71              		.loc 2 133 109 discriminator 1 view .LVU6
  72 0010 FFF7FEFF 		bl	__assert_func
  73              	.LVL3:
  74              	.L8:
  75              		.align	2
  76              	.L7:
  77 0014 00000000 		.word	.LC0
  78 0018 10000000 		.word	.LC1
  79 001c 78000000 		.word	.LC2
  80              	.LBE340:
  81              		.cfi_endproc
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 5


  82              	.LFE9412:
  83              		.fnend
  85              		.weak	_ZN5Eigen8internal19variable_if_dynamicIiLi3EEC1Ei
  86              		.thumb_set _ZN5Eigen8internal19variable_if_dynamicIiLi3EEC1Ei,_ZN5Eigen8internal19variable_if_dyna
  87              		.section	.rodata._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3EL
  88              		.align	2
  89              	.LC3:
  90 0000 726F7773 		.ascii	"rows >= 0 && (RowsAtCompileTime == Dynamic || RowsA"
  90      203E3D20 
  90      30202626 
  90      2028526F 
  90      77734174 
  91 0033 74436F6D 		.ascii	"tCompileTime == rows) && cols >= 0 && (ColsAtCompil"
  91      70696C65 
  91      54696D65 
  91      203D3D20 
  91      726F7773 
  92 0066 6554696D 		.ascii	"eTime == Dynamic || ColsAtCompileTime == cols)\000"
  92      65203D3D 
  92      2044796E 
  92      616D6963 
  92      207C7C20 
  93 0095 000000   		.align	2
  94              	.LC4:
  95 0098 45696765 		.ascii	"Eigen::CwiseNullaryOp<NullaryOp, MatrixType>::Cwise"
  95      6E3A3A43 
  95      77697365 
  95      4E756C6C 
  95      6172794F 
  96 00cb 4E756C6C 		.ascii	"NullaryOp(Eigen::Index, Eigen::Index, const Nullary"
  96      6172794F 
  96      70284569 
  96      67656E3A 
  96      3A496E64 
  97 00fe 4F702629 		.ascii	"Op&) [with NullaryOp = Eigen::internal::scalar_rand"
  97      205B7769 
  97      7468204E 
  97      756C6C61 
  97      72794F70 
  98 0131 6F6D5F6F 		.ascii	"om_op<double>; PlainObjectType = Eigen::Matrix<doub"
  98      703C646F 
  98      75626C65 
  98      3E3B2050 
  98      6C61696E 
  99 0164 6C652C20 		.ascii	"le, 3, 3>; Eigen::Index = int]\000"
  99      332C2033 
  99      3E3B2045 
  99      6967656E 
  99      3A3A496E 
 100 0183 00       		.align	2
 101              	.LC5:
 102 0184 2E2F4569 		.ascii	"./Eigen/src/Core/CwiseNullaryOp.h\000"
 102      67656E2F 
 102      7372632F 
 102      436F7265 
 102      2F437769 
 103              		.section	.text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 6


 104              		.align	1
 105              		.weak	_ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3E
 106              		.syntax unified
 107              		.thumb
 108              		.thumb_func
 110              	_ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2Ei
 111              		.fnstart
 112              	.LVL4:
 113              	.LFB9329:
 114              		.file 3 "./Eigen/src/Core/CwiseNullaryOp.h"
   1:./Eigen/src/Core/CwiseNullaryOp.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/CwiseNullaryOp.h **** // for linear algebra.
   3:./Eigen/src/Core/CwiseNullaryOp.h **** //
   4:./Eigen/src/Core/CwiseNullaryOp.h **** // Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/CwiseNullaryOp.h **** //
   6:./Eigen/src/Core/CwiseNullaryOp.h **** // This Source Code Form is subject to the terms of the Mozilla
   7:./Eigen/src/Core/CwiseNullaryOp.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   8:./Eigen/src/Core/CwiseNullaryOp.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
   9:./Eigen/src/Core/CwiseNullaryOp.h **** 
  10:./Eigen/src/Core/CwiseNullaryOp.h **** #ifndef EIGEN_CWISE_NULLARY_OP_H
  11:./Eigen/src/Core/CwiseNullaryOp.h **** #define EIGEN_CWISE_NULLARY_OP_H
  12:./Eigen/src/Core/CwiseNullaryOp.h **** 
  13:./Eigen/src/Core/CwiseNullaryOp.h **** namespace Eigen {
  14:./Eigen/src/Core/CwiseNullaryOp.h **** 
  15:./Eigen/src/Core/CwiseNullaryOp.h **** namespace internal {
  16:./Eigen/src/Core/CwiseNullaryOp.h **** template<typename NullaryOp, typename PlainObjectType>
  17:./Eigen/src/Core/CwiseNullaryOp.h **** struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>
  18:./Eigen/src/Core/CwiseNullaryOp.h **** {
  19:./Eigen/src/Core/CwiseNullaryOp.h ****   enum {
  20:./Eigen/src/Core/CwiseNullaryOp.h ****     Flags = traits<PlainObjectType>::Flags & RowMajorBit
  21:./Eigen/src/Core/CwiseNullaryOp.h ****   };
  22:./Eigen/src/Core/CwiseNullaryOp.h **** };
  23:./Eigen/src/Core/CwiseNullaryOp.h **** 
  24:./Eigen/src/Core/CwiseNullaryOp.h **** } // namespace internal
  25:./Eigen/src/Core/CwiseNullaryOp.h **** 
  26:./Eigen/src/Core/CwiseNullaryOp.h **** /** \class CwiseNullaryOp
  27:./Eigen/src/Core/CwiseNullaryOp.h ****   * \ingroup Core_Module
  28:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  29:./Eigen/src/Core/CwiseNullaryOp.h ****   * \brief Generic expression of a matrix where all coefficients are defined by a functor
  30:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  31:./Eigen/src/Core/CwiseNullaryOp.h ****   * \tparam NullaryOp template functor implementing the operator
  32:./Eigen/src/Core/CwiseNullaryOp.h ****   * \tparam PlainObjectType the underlying plain matrix/array type
  33:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  34:./Eigen/src/Core/CwiseNullaryOp.h ****   * This class represents an expression of a generic nullary operator.
  35:./Eigen/src/Core/CwiseNullaryOp.h ****   * It is the return type of the Ones(), Zero(), Constant(), Identity() and Random() methods,
  36:./Eigen/src/Core/CwiseNullaryOp.h ****   * and most of the time this is the only way it is used.
  37:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  38:./Eigen/src/Core/CwiseNullaryOp.h ****   * However, if you want to write a function returning such an expression, you
  39:./Eigen/src/Core/CwiseNullaryOp.h ****   * will need to use this class.
  40:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  41:./Eigen/src/Core/CwiseNullaryOp.h ****   * The functor NullaryOp must expose one of the following method:
  42:./Eigen/src/Core/CwiseNullaryOp.h ****     <table class="manual">
  43:./Eigen/src/Core/CwiseNullaryOp.h ****     <tr            ><td>\c operator()() </td><td>if the procedural generation does not depend on th
  44:./Eigen/src/Core/CwiseNullaryOp.h ****     <tr class="alt"><td>\c operator()(Index i)</td><td>if the procedural generation makes sense for
  45:./Eigen/src/Core/CwiseNullaryOp.h ****     <tr            ><td>\c operator()(Index i,Index j)</td><td>if the procedural generation depends
  46:./Eigen/src/Core/CwiseNullaryOp.h ****     </table>
  47:./Eigen/src/Core/CwiseNullaryOp.h ****   * It is also possible to expose the last two operators if the generation makes sense for matrices
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 7


  48:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  49:./Eigen/src/Core/CwiseNullaryOp.h ****   * See DenseBase::NullaryExpr(Index,const CustomNullaryOp&) for an example binding
  50:./Eigen/src/Core/CwiseNullaryOp.h ****   * C++11 random number generators.
  51:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  52:./Eigen/src/Core/CwiseNullaryOp.h ****   * A nullary expression can also be used to implement custom sophisticated matrix manipulations
  53:./Eigen/src/Core/CwiseNullaryOp.h ****   * that cannot be covered by the existing set of natively supported matrix manipulations.
  54:./Eigen/src/Core/CwiseNullaryOp.h ****   * See this \ref TopicCustomizing_NullaryExpr "page" for some examples and additional explanations
  55:./Eigen/src/Core/CwiseNullaryOp.h ****   * on the behavior of CwiseNullaryOp.
  56:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  57:./Eigen/src/Core/CwiseNullaryOp.h ****   * \sa class CwiseUnaryOp, class CwiseBinaryOp, DenseBase::NullaryExpr
  58:./Eigen/src/Core/CwiseNullaryOp.h ****   */
  59:./Eigen/src/Core/CwiseNullaryOp.h **** template<typename NullaryOp, typename PlainObjectType>
  60:./Eigen/src/Core/CwiseNullaryOp.h **** class CwiseNullaryOp : public internal::dense_xpr_base< CwiseNullaryOp<NullaryOp, PlainObjectType> 
  61:./Eigen/src/Core/CwiseNullaryOp.h **** {
  62:./Eigen/src/Core/CwiseNullaryOp.h ****   public:
  63:./Eigen/src/Core/CwiseNullaryOp.h **** 
  64:./Eigen/src/Core/CwiseNullaryOp.h ****     typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;
  65:./Eigen/src/Core/CwiseNullaryOp.h ****     EIGEN_DENSE_PUBLIC_INTERFACE(CwiseNullaryOp)
  66:./Eigen/src/Core/CwiseNullaryOp.h **** 
  67:./Eigen/src/Core/CwiseNullaryOp.h ****     EIGEN_DEVICE_FUNC
  68:./Eigen/src/Core/CwiseNullaryOp.h ****     CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())
 115              		.loc 3 68 5 is_stmt 1 view -0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		.loc 3 68 5 is_stmt 0 view .LVU8
 120 0000 70B5     		push	{r4, r5, r6, lr}
 121              		.save {r4, r5, r6, lr}
 122              	.LCFI1:
 123              		.cfi_def_cfa_offset 16
 124              		.cfi_offset 4, -16
 125              		.cfi_offset 5, -12
 126              		.cfi_offset 6, -8
 127              		.cfi_offset 14, -4
 128 0002 0546     		mov	r5, r0
 129 0004 0E46     		mov	r6, r1
 130 0006 1446     		mov	r4, r2
 131              	.LVL5:
 132              	.LBB341:
 133              	.LBB342:
 134              	.LBI342:
 135              		.file 4 "./Eigen/src/Core/MatrixBase.h"
   1:./Eigen/src/Core/MatrixBase.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/MatrixBase.h **** // for linear algebra.
   3:./Eigen/src/Core/MatrixBase.h **** //
   4:./Eigen/src/Core/MatrixBase.h **** // Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/MatrixBase.h **** // Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/MatrixBase.h **** //
   7:./Eigen/src/Core/MatrixBase.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/MatrixBase.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/MatrixBase.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/MatrixBase.h **** 
  11:./Eigen/src/Core/MatrixBase.h **** #ifndef EIGEN_MATRIXBASE_H
  12:./Eigen/src/Core/MatrixBase.h **** #define EIGEN_MATRIXBASE_H
  13:./Eigen/src/Core/MatrixBase.h **** 
  14:./Eigen/src/Core/MatrixBase.h **** namespace Eigen {
  15:./Eigen/src/Core/MatrixBase.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 8


  16:./Eigen/src/Core/MatrixBase.h **** /** \class MatrixBase
  17:./Eigen/src/Core/MatrixBase.h ****   * \ingroup Core_Module
  18:./Eigen/src/Core/MatrixBase.h ****   *
  19:./Eigen/src/Core/MatrixBase.h ****   * \brief Base class for all dense matrices, vectors, and expressions
  20:./Eigen/src/Core/MatrixBase.h ****   *
  21:./Eigen/src/Core/MatrixBase.h ****   * This class is the base that is inherited by all matrix, vector, and related expression
  22:./Eigen/src/Core/MatrixBase.h ****   * types. Most of the Eigen API is contained in this class, and its base classes. Other important
  23:./Eigen/src/Core/MatrixBase.h ****   * classes for the Eigen API are Matrix, and VectorwiseOp.
  24:./Eigen/src/Core/MatrixBase.h ****   *
  25:./Eigen/src/Core/MatrixBase.h ****   * Note that some methods are defined in other modules such as the \ref LU_Module LU module
  26:./Eigen/src/Core/MatrixBase.h ****   * for all functions related to matrix inversions.
  27:./Eigen/src/Core/MatrixBase.h ****   *
  28:./Eigen/src/Core/MatrixBase.h ****   * \tparam Derived is the derived type, e.g. a matrix type, or an expression, etc.
  29:./Eigen/src/Core/MatrixBase.h ****   *
  30:./Eigen/src/Core/MatrixBase.h ****   * When writing a function taking Eigen objects as argument, if you want your function
  31:./Eigen/src/Core/MatrixBase.h ****   * to take as argument any matrix, vector, or expression, just let it take a
  32:./Eigen/src/Core/MatrixBase.h ****   * MatrixBase argument. As an example, here is a function printFirstRow which, given
  33:./Eigen/src/Core/MatrixBase.h ****   * a matrix, vector, or expression \a x, prints the first row of \a x.
  34:./Eigen/src/Core/MatrixBase.h ****   *
  35:./Eigen/src/Core/MatrixBase.h ****   * \code
  36:./Eigen/src/Core/MatrixBase.h ****     template<typename Derived>
  37:./Eigen/src/Core/MatrixBase.h ****     void printFirstRow(const Eigen::MatrixBase<Derived>& x)
  38:./Eigen/src/Core/MatrixBase.h ****     {
  39:./Eigen/src/Core/MatrixBase.h ****       cout << x.row(0) << endl;
  40:./Eigen/src/Core/MatrixBase.h ****     }
  41:./Eigen/src/Core/MatrixBase.h ****   * \endcode
  42:./Eigen/src/Core/MatrixBase.h ****   *
  43:./Eigen/src/Core/MatrixBase.h ****   * This class can be extended with the help of the plugin mechanism described on the page
  44:./Eigen/src/Core/MatrixBase.h ****   * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_MATRIXBASE_PLUGIN.
  45:./Eigen/src/Core/MatrixBase.h ****   *
  46:./Eigen/src/Core/MatrixBase.h ****   * \sa \blank \ref TopicClassHierarchy
  47:./Eigen/src/Core/MatrixBase.h ****   */
  48:./Eigen/src/Core/MatrixBase.h **** template<typename Derived> class MatrixBase
  49:./Eigen/src/Core/MatrixBase.h ****   : public DenseBase<Derived>
  50:./Eigen/src/Core/MatrixBase.h **** {
  51:./Eigen/src/Core/MatrixBase.h ****   public:
  52:./Eigen/src/Core/MatrixBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
  53:./Eigen/src/Core/MatrixBase.h ****     typedef MatrixBase StorageBaseType;
  54:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::traits<Derived>::StorageKind StorageKind;
  55:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
  56:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
  57:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
  58:./Eigen/src/Core/MatrixBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
  59:./Eigen/src/Core/MatrixBase.h **** 
  60:./Eigen/src/Core/MatrixBase.h ****     typedef DenseBase<Derived> Base;
  61:./Eigen/src/Core/MatrixBase.h ****     using Base::RowsAtCompileTime;
  62:./Eigen/src/Core/MatrixBase.h ****     using Base::ColsAtCompileTime;
  63:./Eigen/src/Core/MatrixBase.h ****     using Base::SizeAtCompileTime;
  64:./Eigen/src/Core/MatrixBase.h ****     using Base::MaxRowsAtCompileTime;
  65:./Eigen/src/Core/MatrixBase.h ****     using Base::MaxColsAtCompileTime;
  66:./Eigen/src/Core/MatrixBase.h ****     using Base::MaxSizeAtCompileTime;
  67:./Eigen/src/Core/MatrixBase.h ****     using Base::IsVectorAtCompileTime;
  68:./Eigen/src/Core/MatrixBase.h ****     using Base::Flags;
  69:./Eigen/src/Core/MatrixBase.h **** 
  70:./Eigen/src/Core/MatrixBase.h ****     using Base::derived;
  71:./Eigen/src/Core/MatrixBase.h ****     using Base::const_cast_derived;
  72:./Eigen/src/Core/MatrixBase.h ****     using Base::rows;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 9


  73:./Eigen/src/Core/MatrixBase.h ****     using Base::cols;
  74:./Eigen/src/Core/MatrixBase.h ****     using Base::size;
  75:./Eigen/src/Core/MatrixBase.h ****     using Base::coeff;
  76:./Eigen/src/Core/MatrixBase.h ****     using Base::coeffRef;
  77:./Eigen/src/Core/MatrixBase.h ****     using Base::lazyAssign;
  78:./Eigen/src/Core/MatrixBase.h ****     using Base::eval;
  79:./Eigen/src/Core/MatrixBase.h ****     using Base::operator-;
  80:./Eigen/src/Core/MatrixBase.h ****     using Base::operator+=;
  81:./Eigen/src/Core/MatrixBase.h ****     using Base::operator-=;
  82:./Eigen/src/Core/MatrixBase.h ****     using Base::operator*=;
  83:./Eigen/src/Core/MatrixBase.h ****     using Base::operator/=;
  84:./Eigen/src/Core/MatrixBase.h **** 
  85:./Eigen/src/Core/MatrixBase.h ****     typedef typename Base::CoeffReturnType CoeffReturnType;
  86:./Eigen/src/Core/MatrixBase.h ****     typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;
  87:./Eigen/src/Core/MatrixBase.h ****     typedef typename Base::RowXpr RowXpr;
  88:./Eigen/src/Core/MatrixBase.h ****     typedef typename Base::ColXpr ColXpr;
  89:./Eigen/src/Core/MatrixBase.h **** #endif // not EIGEN_PARSED_BY_DOXYGEN
  90:./Eigen/src/Core/MatrixBase.h **** 
  91:./Eigen/src/Core/MatrixBase.h **** 
  92:./Eigen/src/Core/MatrixBase.h **** 
  93:./Eigen/src/Core/MatrixBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
  94:./Eigen/src/Core/MatrixBase.h ****     /** type of the equivalent square matrix */
  95:./Eigen/src/Core/MatrixBase.h ****     typedef Matrix<Scalar,EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime),
  96:./Eigen/src/Core/MatrixBase.h ****                           EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;
  97:./Eigen/src/Core/MatrixBase.h **** #endif // not EIGEN_PARSED_BY_DOXYGEN
  98:./Eigen/src/Core/MatrixBase.h **** 
  99:./Eigen/src/Core/MatrixBase.h ****     /** \returns the size of the main diagonal, which is min(rows(),cols()).
 100:./Eigen/src/Core/MatrixBase.h ****       * \sa rows(), cols(), SizeAtCompileTime. */
 101:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 102:./Eigen/src/Core/MatrixBase.h ****     inline Index diagonalSize() const { return (numext::mini)(rows(),cols()); }
 103:./Eigen/src/Core/MatrixBase.h **** 
 104:./Eigen/src/Core/MatrixBase.h ****     typedef typename Base::PlainObject PlainObject;
 105:./Eigen/src/Core/MatrixBase.h **** 
 106:./Eigen/src/Core/MatrixBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 107:./Eigen/src/Core/MatrixBase.h ****     /** \internal Represents a matrix with all coefficients equal to one another*/
 108:./Eigen/src/Core/MatrixBase.h ****     typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
 109:./Eigen/src/Core/MatrixBase.h ****     /** \internal the return type of MatrixBase::adjoint() */
 110:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
 111:./Eigen/src/Core/MatrixBase.h ****                         CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, ConstTransposeReturnTyp
 112:./Eigen/src/Core/MatrixBase.h ****                         ConstTransposeReturnType
 113:./Eigen/src/Core/MatrixBase.h ****                      >::type AdjointReturnType;
 114:./Eigen/src/Core/MatrixBase.h ****     /** \internal Return type of eigenvalues() */
 115:./Eigen/src/Core/MatrixBase.h ****     typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMa
 116:./Eigen/src/Core/MatrixBase.h ****     /** \internal the return type of identity */
 117:./Eigen/src/Core/MatrixBase.h ****     typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,PlainObject> IdentityReturnType;
 118:./Eigen/src/Core/MatrixBase.h ****     /** \internal the return type of unit vectors */
 119:./Eigen/src/Core/MatrixBase.h ****     typedef Block<const CwiseNullaryOp<internal::scalar_identity_op<Scalar>, SquareMatrixType>,
 120:./Eigen/src/Core/MatrixBase.h ****                   internal::traits<Derived>::RowsAtCompileTime,
 121:./Eigen/src/Core/MatrixBase.h ****                   internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;
 122:./Eigen/src/Core/MatrixBase.h **** #endif // not EIGEN_PARSED_BY_DOXYGEN
 123:./Eigen/src/Core/MatrixBase.h **** 
 124:./Eigen/src/Core/MatrixBase.h **** #define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::MatrixBase
 125:./Eigen/src/Core/MatrixBase.h **** #define EIGEN_DOC_UNARY_ADDONS(X,Y)
 126:./Eigen/src/Core/MatrixBase.h **** #   include "../plugins/CommonCwiseBinaryOps.h"
 127:./Eigen/src/Core/MatrixBase.h **** #   include "../plugins/MatrixCwiseUnaryOps.h"
 128:./Eigen/src/Core/MatrixBase.h **** #   include "../plugins/MatrixCwiseBinaryOps.h"
 129:./Eigen/src/Core/MatrixBase.h **** #   ifdef EIGEN_MATRIXBASE_PLUGIN
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 10


 130:./Eigen/src/Core/MatrixBase.h **** #     include EIGEN_MATRIXBASE_PLUGIN
 131:./Eigen/src/Core/MatrixBase.h **** #   endif
 132:./Eigen/src/Core/MatrixBase.h **** #undef EIGEN_CURRENT_STORAGE_BASE_CLASS
 133:./Eigen/src/Core/MatrixBase.h **** #undef EIGEN_DOC_UNARY_ADDONS
 134:./Eigen/src/Core/MatrixBase.h **** 
 135:./Eigen/src/Core/MatrixBase.h ****     /** Special case of the template operator=, in order to prevent the compiler
 136:./Eigen/src/Core/MatrixBase.h ****       * from generating a default operator= (issue hit with g++ 4.1)
 137:./Eigen/src/Core/MatrixBase.h ****       */
 138:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 139:./Eigen/src/Core/MatrixBase.h ****     Derived& operator=(const MatrixBase& other);
 140:./Eigen/src/Core/MatrixBase.h **** 
 141:./Eigen/src/Core/MatrixBase.h ****     // We cannot inherit here via Base::operator= since it is causing
 142:./Eigen/src/Core/MatrixBase.h ****     // trouble with MSVC.
 143:./Eigen/src/Core/MatrixBase.h **** 
 144:./Eigen/src/Core/MatrixBase.h ****     template <typename OtherDerived>
 145:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 146:./Eigen/src/Core/MatrixBase.h ****     Derived& operator=(const DenseBase<OtherDerived>& other);
 147:./Eigen/src/Core/MatrixBase.h **** 
 148:./Eigen/src/Core/MatrixBase.h ****     template <typename OtherDerived>
 149:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 150:./Eigen/src/Core/MatrixBase.h ****     Derived& operator=(const EigenBase<OtherDerived>& other);
 151:./Eigen/src/Core/MatrixBase.h **** 
 152:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 153:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 154:./Eigen/src/Core/MatrixBase.h ****     Derived& operator=(const ReturnByValue<OtherDerived>& other);
 155:./Eigen/src/Core/MatrixBase.h **** 
 156:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 157:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 158:./Eigen/src/Core/MatrixBase.h ****     Derived& operator+=(const MatrixBase<OtherDerived>& other);
 159:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 160:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 161:./Eigen/src/Core/MatrixBase.h ****     Derived& operator-=(const MatrixBase<OtherDerived>& other);
 162:./Eigen/src/Core/MatrixBase.h **** 
 163:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 164:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 165:./Eigen/src/Core/MatrixBase.h ****     const Product<Derived,OtherDerived>
 166:./Eigen/src/Core/MatrixBase.h ****     operator*(const MatrixBase<OtherDerived> &other) const;
 167:./Eigen/src/Core/MatrixBase.h **** 
 168:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 169:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 170:./Eigen/src/Core/MatrixBase.h ****     const Product<Derived,OtherDerived,LazyProduct>
 171:./Eigen/src/Core/MatrixBase.h ****     lazyProduct(const MatrixBase<OtherDerived> &other) const;
 172:./Eigen/src/Core/MatrixBase.h **** 
 173:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 174:./Eigen/src/Core/MatrixBase.h ****     Derived& operator*=(const EigenBase<OtherDerived>& other);
 175:./Eigen/src/Core/MatrixBase.h **** 
 176:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 177:./Eigen/src/Core/MatrixBase.h ****     void applyOnTheLeft(const EigenBase<OtherDerived>& other);
 178:./Eigen/src/Core/MatrixBase.h **** 
 179:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 180:./Eigen/src/Core/MatrixBase.h ****     void applyOnTheRight(const EigenBase<OtherDerived>& other);
 181:./Eigen/src/Core/MatrixBase.h **** 
 182:./Eigen/src/Core/MatrixBase.h ****     template<typename DiagonalDerived>
 183:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 184:./Eigen/src/Core/MatrixBase.h ****     const Product<Derived, DiagonalDerived, LazyProduct>
 185:./Eigen/src/Core/MatrixBase.h ****     operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;
 186:./Eigen/src/Core/MatrixBase.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 11


 187:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 188:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 189:./Eigen/src/Core/MatrixBase.h ****     typename ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar,typename internal::tra
 190:./Eigen/src/Core/MatrixBase.h ****     dot(const MatrixBase<OtherDerived>& other) const;
 191:./Eigen/src/Core/MatrixBase.h **** 
 192:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC RealScalar squaredNorm() const;
 193:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC RealScalar norm() const;
 194:./Eigen/src/Core/MatrixBase.h ****     RealScalar stableNorm() const;
 195:./Eigen/src/Core/MatrixBase.h ****     RealScalar blueNorm() const;
 196:./Eigen/src/Core/MatrixBase.h ****     RealScalar hypotNorm() const;
 197:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC const PlainObject normalized() const;
 198:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC const PlainObject stableNormalized() const;
 199:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC void normalize();
 200:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC void stableNormalize();
 201:./Eigen/src/Core/MatrixBase.h **** 
 202:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC const AdjointReturnType adjoint() const;
 203:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC void adjointInPlace();
 204:./Eigen/src/Core/MatrixBase.h **** 
 205:./Eigen/src/Core/MatrixBase.h ****     typedef Diagonal<Derived> DiagonalReturnType;
 206:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 207:./Eigen/src/Core/MatrixBase.h ****     DiagonalReturnType diagonal();
 208:./Eigen/src/Core/MatrixBase.h **** 
 209:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;
 210:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 211:./Eigen/src/Core/MatrixBase.h ****     ConstDiagonalReturnType diagonal() const;
 212:./Eigen/src/Core/MatrixBase.h **** 
 213:./Eigen/src/Core/MatrixBase.h ****     template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };
 214:./Eigen/src/Core/MatrixBase.h ****     template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,
 215:./Eigen/src/Core/MatrixBase.h **** 
 216:./Eigen/src/Core/MatrixBase.h ****     template<int Index>
 217:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 218:./Eigen/src/Core/MatrixBase.h ****     typename DiagonalIndexReturnType<Index>::Type diagonal();
 219:./Eigen/src/Core/MatrixBase.h **** 
 220:./Eigen/src/Core/MatrixBase.h ****     template<int Index>
 221:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 222:./Eigen/src/Core/MatrixBase.h ****     typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;
 223:./Eigen/src/Core/MatrixBase.h **** 
 224:./Eigen/src/Core/MatrixBase.h ****     typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;
 225:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonal
 226:./Eigen/src/Core/MatrixBase.h **** 
 227:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 228:./Eigen/src/Core/MatrixBase.h ****     DiagonalDynamicIndexReturnType diagonal(Index index);
 229:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 230:./Eigen/src/Core/MatrixBase.h ****     ConstDiagonalDynamicIndexReturnType diagonal(Index index) const;
 231:./Eigen/src/Core/MatrixBase.h **** 
 232:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, M
 233:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView
 234:./Eigen/src/Core/MatrixBase.h **** 
 235:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int Mode>
 236:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 237:./Eigen/src/Core/MatrixBase.h ****     typename TriangularViewReturnType<Mode>::Type triangularView();
 238:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int Mode>
 239:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 240:./Eigen/src/Core/MatrixBase.h ****     typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;
 241:./Eigen/src/Core/MatrixBase.h **** 
 242:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived,
 243:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointVi
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 12


 244:./Eigen/src/Core/MatrixBase.h **** 
 245:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int UpLo>
 246:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 247:./Eigen/src/Core/MatrixBase.h ****     typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();
 248:./Eigen/src/Core/MatrixBase.h ****     template<unsigned int UpLo>
 249:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 250:./Eigen/src/Core/MatrixBase.h ****     typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;
 251:./Eigen/src/Core/MatrixBase.h **** 
 252:./Eigen/src/Core/MatrixBase.h ****     const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),
 253:./Eigen/src/Core/MatrixBase.h ****                                          const typename NumTraits<Scalar>::Real& m_epsilon = NumTra
 254:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const IdentityReturnType Identity();
 255:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const IdentityReturnType Identity(Index rows, Index cols);
 256:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType Unit(Index size, Index i);
 257:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType Unit(Index i);
 258:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType UnitX();
 259:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType UnitY();
 260:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType UnitZ();
 261:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC static const BasisReturnType UnitW();
 262:./Eigen/src/Core/MatrixBase.h **** 
 263:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 264:./Eigen/src/Core/MatrixBase.h ****     const DiagonalWrapper<const Derived> asDiagonal() const;
 265:./Eigen/src/Core/MatrixBase.h ****     const PermutationWrapper<const Derived> asPermutation() const;
 266:./Eigen/src/Core/MatrixBase.h **** 
 267:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 268:./Eigen/src/Core/MatrixBase.h ****     Derived& setIdentity();
 269:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 270:./Eigen/src/Core/MatrixBase.h ****     Derived& setIdentity(Index rows, Index cols);
 271:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC Derived& setUnit(Index i);
 272:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC Derived& setUnit(Index newSize, Index i);
 273:./Eigen/src/Core/MatrixBase.h **** 
 274:./Eigen/src/Core/MatrixBase.h ****     bool isIdentity(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 275:./Eigen/src/Core/MatrixBase.h ****     bool isDiagonal(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 276:./Eigen/src/Core/MatrixBase.h **** 
 277:./Eigen/src/Core/MatrixBase.h ****     bool isUpperTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 278:./Eigen/src/Core/MatrixBase.h ****     bool isLowerTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 279:./Eigen/src/Core/MatrixBase.h **** 
 280:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 281:./Eigen/src/Core/MatrixBase.h ****     bool isOrthogonal(const MatrixBase<OtherDerived>& other,
 282:./Eigen/src/Core/MatrixBase.h ****                       const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 283:./Eigen/src/Core/MatrixBase.h ****     bool isUnitary(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 284:./Eigen/src/Core/MatrixBase.h **** 
 285:./Eigen/src/Core/MatrixBase.h ****     /** \returns true if each coefficients of \c *this and \a other are all exactly equal.
 286:./Eigen/src/Core/MatrixBase.h ****       * \warning When using floating point scalar values you probably should rather use a
 287:./Eigen/src/Core/MatrixBase.h ****       *          fuzzy comparison such as isApprox()
 288:./Eigen/src/Core/MatrixBase.h ****       * \sa isApprox(), operator!= */
 289:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 290:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC inline bool operator==(const MatrixBase<OtherDerived>& other) const
 291:./Eigen/src/Core/MatrixBase.h ****     { return cwiseEqual(other).all(); }
 292:./Eigen/src/Core/MatrixBase.h **** 
 293:./Eigen/src/Core/MatrixBase.h ****     /** \returns true if at least one pair of coefficients of \c *this and \a other are not exactly
 294:./Eigen/src/Core/MatrixBase.h ****       * \warning When using floating point scalar values you probably should rather use a
 295:./Eigen/src/Core/MatrixBase.h ****       *          fuzzy comparison such as isApprox()
 296:./Eigen/src/Core/MatrixBase.h ****       * \sa isApprox(), operator== */
 297:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 298:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC inline bool operator!=(const MatrixBase<OtherDerived>& other) const
 299:./Eigen/src/Core/MatrixBase.h ****     { return cwiseNotEqual(other).any(); }
 300:./Eigen/src/Core/MatrixBase.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 13


 301:./Eigen/src/Core/MatrixBase.h ****     NoAlias<Derived,Eigen::MatrixBase > EIGEN_DEVICE_FUNC noalias();
 302:./Eigen/src/Core/MatrixBase.h **** 
 303:./Eigen/src/Core/MatrixBase.h ****     // TODO forceAlignedAccess is temporarily disabled
 304:./Eigen/src/Core/MatrixBase.h ****     // Need to find a nicer workaround.
 305:./Eigen/src/Core/MatrixBase.h ****     inline const Derived& forceAlignedAccess() const { return derived(); }
 306:./Eigen/src/Core/MatrixBase.h ****     inline Derived& forceAlignedAccess() { return derived(); }
 307:./Eigen/src/Core/MatrixBase.h ****     template<bool Enable> inline const Derived& forceAlignedAccessIf() const { return derived(); }
 308:./Eigen/src/Core/MatrixBase.h ****     template<bool Enable> inline Derived& forceAlignedAccessIf() { return derived(); }
 309:./Eigen/src/Core/MatrixBase.h **** 
 310:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC Scalar trace() const;
 311:./Eigen/src/Core/MatrixBase.h **** 
 312:./Eigen/src/Core/MatrixBase.h ****     template<int p> EIGEN_DEVICE_FUNC RealScalar lpNorm() const;
 313:./Eigen/src/Core/MatrixBase.h **** 
 314:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC MatrixBase<Derived>& matrix() { return *this; }
 315:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC const MatrixBase<Derived>& matrix() const { return *this; }
 316:./Eigen/src/Core/MatrixBase.h **** 
 317:./Eigen/src/Core/MatrixBase.h ****     /** \returns an \link Eigen::ArrayBase Array \endlink expression of this matrix
 318:./Eigen/src/Core/MatrixBase.h ****       * \sa ArrayBase::matrix() */
 319:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ArrayWrapper<Derived> array() { return ArrayWrapper<Deriv
 320:./Eigen/src/Core/MatrixBase.h ****     /** \returns a const \link Eigen::ArrayBase Array \endlink expression of this matrix
 321:./Eigen/src/Core/MatrixBase.h ****       * \sa ArrayBase::matrix() */
 322:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const ArrayWrapper<const Derived> array() const { return 
 323:./Eigen/src/Core/MatrixBase.h **** 
 324:./Eigen/src/Core/MatrixBase.h **** /////////// LU module ///////////
 325:./Eigen/src/Core/MatrixBase.h **** 
 326:./Eigen/src/Core/MatrixBase.h ****     inline const FullPivLU<PlainObject> fullPivLu() const;
 327:./Eigen/src/Core/MatrixBase.h ****     inline const PartialPivLU<PlainObject> partialPivLu() const;
 328:./Eigen/src/Core/MatrixBase.h **** 
 329:./Eigen/src/Core/MatrixBase.h ****     inline const PartialPivLU<PlainObject> lu() const;
 330:./Eigen/src/Core/MatrixBase.h **** 
 331:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 332:./Eigen/src/Core/MatrixBase.h ****     inline const Inverse<Derived> inverse() const;
 333:./Eigen/src/Core/MatrixBase.h **** 
 334:./Eigen/src/Core/MatrixBase.h ****     template<typename ResultType>
 335:./Eigen/src/Core/MatrixBase.h ****     inline void computeInverseAndDetWithCheck(
 336:./Eigen/src/Core/MatrixBase.h ****       ResultType& inverse,
 337:./Eigen/src/Core/MatrixBase.h ****       typename ResultType::Scalar& determinant,
 338:./Eigen/src/Core/MatrixBase.h ****       bool& invertible,
 339:./Eigen/src/Core/MatrixBase.h ****       const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
 340:./Eigen/src/Core/MatrixBase.h ****     ) const;
 341:./Eigen/src/Core/MatrixBase.h **** 
 342:./Eigen/src/Core/MatrixBase.h ****     template<typename ResultType>
 343:./Eigen/src/Core/MatrixBase.h ****     inline void computeInverseWithCheck(
 344:./Eigen/src/Core/MatrixBase.h ****       ResultType& inverse,
 345:./Eigen/src/Core/MatrixBase.h ****       bool& invertible,
 346:./Eigen/src/Core/MatrixBase.h ****       const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
 347:./Eigen/src/Core/MatrixBase.h ****     ) const;
 348:./Eigen/src/Core/MatrixBase.h **** 
 349:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 350:./Eigen/src/Core/MatrixBase.h ****     Scalar determinant() const;
 351:./Eigen/src/Core/MatrixBase.h **** 
 352:./Eigen/src/Core/MatrixBase.h **** /////////// Cholesky module ///////////
 353:./Eigen/src/Core/MatrixBase.h **** 
 354:./Eigen/src/Core/MatrixBase.h ****     inline const LLT<PlainObject>  llt() const;
 355:./Eigen/src/Core/MatrixBase.h ****     inline const LDLT<PlainObject> ldlt() const;
 356:./Eigen/src/Core/MatrixBase.h **** 
 357:./Eigen/src/Core/MatrixBase.h **** /////////// QR module ///////////
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 14


 358:./Eigen/src/Core/MatrixBase.h **** 
 359:./Eigen/src/Core/MatrixBase.h ****     inline const HouseholderQR<PlainObject> householderQr() const;
 360:./Eigen/src/Core/MatrixBase.h ****     inline const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;
 361:./Eigen/src/Core/MatrixBase.h ****     inline const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;
 362:./Eigen/src/Core/MatrixBase.h ****     inline const CompleteOrthogonalDecomposition<PlainObject> completeOrthogonalDecomposition() con
 363:./Eigen/src/Core/MatrixBase.h **** 
 364:./Eigen/src/Core/MatrixBase.h **** /////////// Eigenvalues module ///////////
 365:./Eigen/src/Core/MatrixBase.h **** 
 366:./Eigen/src/Core/MatrixBase.h ****     inline EigenvaluesReturnType eigenvalues() const;
 367:./Eigen/src/Core/MatrixBase.h ****     inline RealScalar operatorNorm() const;
 368:./Eigen/src/Core/MatrixBase.h **** 
 369:./Eigen/src/Core/MatrixBase.h **** /////////// SVD module ///////////
 370:./Eigen/src/Core/MatrixBase.h **** 
 371:./Eigen/src/Core/MatrixBase.h ****     inline JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;
 372:./Eigen/src/Core/MatrixBase.h ****     inline BDCSVD<PlainObject>    bdcSvd(unsigned int computationOptions = 0) const;
 373:./Eigen/src/Core/MatrixBase.h **** 
 374:./Eigen/src/Core/MatrixBase.h **** /////////// Geometry module ///////////
 375:./Eigen/src/Core/MatrixBase.h **** 
 376:./Eigen/src/Core/MatrixBase.h ****     #ifndef EIGEN_PARSED_BY_DOXYGEN
 377:./Eigen/src/Core/MatrixBase.h ****     /// \internal helper struct to form the return type of the cross product
 378:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived> struct cross_product_return_type {
 379:./Eigen/src/Core/MatrixBase.h ****       typedef typename ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar,typename int
 380:./Eigen/src/Core/MatrixBase.h ****       typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;
 381:./Eigen/src/Core/MatrixBase.h ****     };
 382:./Eigen/src/Core/MatrixBase.h ****     #endif // EIGEN_PARSED_BY_DOXYGEN
 383:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 384:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 385:./Eigen/src/Core/MatrixBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 386:./Eigen/src/Core/MatrixBase.h ****     inline typename cross_product_return_type<OtherDerived>::type
 387:./Eigen/src/Core/MatrixBase.h **** #else
 388:./Eigen/src/Core/MatrixBase.h ****     inline PlainObject
 389:./Eigen/src/Core/MatrixBase.h **** #endif
 390:./Eigen/src/Core/MatrixBase.h ****     cross(const MatrixBase<OtherDerived>& other) const;
 391:./Eigen/src/Core/MatrixBase.h **** 
 392:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 393:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 394:./Eigen/src/Core/MatrixBase.h ****     inline PlainObject cross3(const MatrixBase<OtherDerived>& other) const;
 395:./Eigen/src/Core/MatrixBase.h **** 
 396:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 397:./Eigen/src/Core/MatrixBase.h ****     inline PlainObject unitOrthogonal(void) const;
 398:./Eigen/src/Core/MatrixBase.h **** 
 399:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 400:./Eigen/src/Core/MatrixBase.h ****     inline Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;
 401:./Eigen/src/Core/MatrixBase.h **** 
 402:./Eigen/src/Core/MatrixBase.h ****     // put this as separate enum value to work around possible GCC 4.3 bug (?)
 403:./Eigen/src/Core/MatrixBase.h ****     enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1&&RowsAtCompileTime==1 ? ((internal
 404:./Eigen/src/Core/MatrixBase.h ****                                           : ColsAtCompileTime==1 ? Vertical : Horizontal };
 405:./Eigen/src/Core/MatrixBase.h ****     typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;
 406:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 407:./Eigen/src/Core/MatrixBase.h ****     inline HomogeneousReturnType homogeneous() const;
 408:./Eigen/src/Core/MatrixBase.h **** 
 409:./Eigen/src/Core/MatrixBase.h ****     enum {
 410:./Eigen/src/Core/MatrixBase.h ****       SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1
 411:./Eigen/src/Core/MatrixBase.h ****     };
 412:./Eigen/src/Core/MatrixBase.h ****     typedef Block<const Derived,
 413:./Eigen/src/Core/MatrixBase.h ****                   internal::traits<Derived>::ColsAtCompileTime==1 ? SizeMinusOne : 1,
 414:./Eigen/src/Core/MatrixBase.h ****                   internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMin
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 15


 415:./Eigen/src/Core/MatrixBase.h ****     typedef EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(ConstStartMinusOne,Scalar,quotient) HNormalizedR
 416:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 417:./Eigen/src/Core/MatrixBase.h ****     inline const HNormalizedReturnType hnormalized() const;
 418:./Eigen/src/Core/MatrixBase.h **** 
 419:./Eigen/src/Core/MatrixBase.h **** ////////// Householder module ///////////
 420:./Eigen/src/Core/MatrixBase.h **** 
 421:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 422:./Eigen/src/Core/MatrixBase.h ****     void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);
 423:./Eigen/src/Core/MatrixBase.h ****     template<typename EssentialPart>
 424:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 425:./Eigen/src/Core/MatrixBase.h ****     void makeHouseholder(EssentialPart& essential,
 426:./Eigen/src/Core/MatrixBase.h ****                          Scalar& tau, RealScalar& beta) const;
 427:./Eigen/src/Core/MatrixBase.h ****     template<typename EssentialPart>
 428:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 429:./Eigen/src/Core/MatrixBase.h ****     void applyHouseholderOnTheLeft(const EssentialPart& essential,
 430:./Eigen/src/Core/MatrixBase.h ****                                    const Scalar& tau,
 431:./Eigen/src/Core/MatrixBase.h ****                                    Scalar* workspace);
 432:./Eigen/src/Core/MatrixBase.h ****     template<typename EssentialPart>
 433:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 434:./Eigen/src/Core/MatrixBase.h ****     void applyHouseholderOnTheRight(const EssentialPart& essential,
 435:./Eigen/src/Core/MatrixBase.h ****                                     const Scalar& tau,
 436:./Eigen/src/Core/MatrixBase.h ****                                     Scalar* workspace);
 437:./Eigen/src/Core/MatrixBase.h **** 
 438:./Eigen/src/Core/MatrixBase.h **** ///////// Jacobi module /////////
 439:./Eigen/src/Core/MatrixBase.h **** 
 440:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherScalar>
 441:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 442:./Eigen/src/Core/MatrixBase.h ****     void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);
 443:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherScalar>
 444:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEVICE_FUNC
 445:./Eigen/src/Core/MatrixBase.h ****     void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);
 446:./Eigen/src/Core/MatrixBase.h **** 
 447:./Eigen/src/Core/MatrixBase.h **** ///////// SparseCore module /////////
 448:./Eigen/src/Core/MatrixBase.h **** 
 449:./Eigen/src/Core/MatrixBase.h ****     template<typename OtherDerived>
 450:./Eigen/src/Core/MatrixBase.h ****     EIGEN_STRONG_INLINE const typename SparseMatrixBase<OtherDerived>::template CwiseProductDenseRe
 451:./Eigen/src/Core/MatrixBase.h ****     cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const
 452:./Eigen/src/Core/MatrixBase.h ****     {
 453:./Eigen/src/Core/MatrixBase.h ****       return other.cwiseProduct(derived());
 454:./Eigen/src/Core/MatrixBase.h ****     }
 455:./Eigen/src/Core/MatrixBase.h **** 
 456:./Eigen/src/Core/MatrixBase.h **** ///////// MatrixFunctions module /////////
 457:./Eigen/src/Core/MatrixBase.h **** 
 458:./Eigen/src/Core/MatrixBase.h ****     typedef typename internal::stem_function<Scalar>::type StemFunction;
 459:./Eigen/src/Core/MatrixBase.h **** #define EIGEN_MATRIX_FUNCTION(ReturnType, Name, Description) \
 460:./Eigen/src/Core/MatrixBase.h ****     /** \returns an expression of the matrix Description of \c *this. \brief This function requires
 461:./Eigen/src/Core/MatrixBase.h ****     const ReturnType<Derived> Name() const;
 462:./Eigen/src/Core/MatrixBase.h **** #define EIGEN_MATRIX_FUNCTION_1(ReturnType, Name, Description, Argument) \
 463:./Eigen/src/Core/MatrixBase.h ****     /** \returns an expression of the matrix Description of \c *this. \brief This function requires
 464:./Eigen/src/Core/MatrixBase.h ****     const ReturnType<Derived> Name(Argument) const;
 465:./Eigen/src/Core/MatrixBase.h **** 
 466:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixExponentialReturnValue, exp, exponential)
 467:./Eigen/src/Core/MatrixBase.h ****     /** \brief Helper function for the <a href="unsupported/group__MatrixFunctions__Module.html"> u
 468:./Eigen/src/Core/MatrixBase.h ****     const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;
 469:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, cosh, hyperbolic cosine)
 470:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, sinh, hyperbolic sine)
 471:./Eigen/src/Core/MatrixBase.h **** #if EIGEN_HAS_CXX11_MATH
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 16


 472:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, atanh, inverse hyperbolic cosine)
 473:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, acosh, inverse hyperbolic cosine)
 474:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, asinh, inverse hyperbolic sine)
 475:./Eigen/src/Core/MatrixBase.h **** #endif
 476:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, cos, cosine)
 477:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, sin, sine)
 478:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixSquareRootReturnValue, sqrt, square root)
 479:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION(MatrixLogarithmReturnValue, log, logarithm)
 480:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION_1(MatrixPowerReturnValue,        pow, power to \c p, const RealScalar& p)
 481:./Eigen/src/Core/MatrixBase.h ****     EIGEN_MATRIX_FUNCTION_1(MatrixComplexPowerReturnValue, pow, power to \c p, const std::complex<R
 482:./Eigen/src/Core/MatrixBase.h **** 
 483:./Eigen/src/Core/MatrixBase.h ****   protected:
 484:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEFAULT_COPY_CONSTRUCTOR(MatrixBase)
 485:./Eigen/src/Core/MatrixBase.h ****     EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MatrixBase)
 136              		.loc 4 485 5 is_stmt 1 view .LVU9
 137              	.LBB343:
 138              	.LBI343:
 139              		.file 5 "./Eigen/src/Core/DenseBase.h"
   1:./Eigen/src/Core/DenseBase.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/DenseBase.h **** // for linear algebra.
   3:./Eigen/src/Core/DenseBase.h **** //
   4:./Eigen/src/Core/DenseBase.h **** // Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/DenseBase.h **** // Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/DenseBase.h **** //
   7:./Eigen/src/Core/DenseBase.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/DenseBase.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/DenseBase.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/DenseBase.h **** 
  11:./Eigen/src/Core/DenseBase.h **** #ifndef EIGEN_DENSEBASE_H
  12:./Eigen/src/Core/DenseBase.h **** #define EIGEN_DENSEBASE_H
  13:./Eigen/src/Core/DenseBase.h **** 
  14:./Eigen/src/Core/DenseBase.h **** namespace Eigen {
  15:./Eigen/src/Core/DenseBase.h **** 
  16:./Eigen/src/Core/DenseBase.h **** namespace internal {
  17:./Eigen/src/Core/DenseBase.h **** 
  18:./Eigen/src/Core/DenseBase.h **** // The index type defined by EIGEN_DEFAULT_DENSE_INDEX_TYPE must be a signed type.
  19:./Eigen/src/Core/DenseBase.h **** // This dummy function simply aims at checking that at compile time.
  20:./Eigen/src/Core/DenseBase.h **** static inline void check_DenseIndex_is_signed() {
  21:./Eigen/src/Core/DenseBase.h ****   EIGEN_STATIC_ASSERT(NumTraits<DenseIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE)
  22:./Eigen/src/Core/DenseBase.h **** }
  23:./Eigen/src/Core/DenseBase.h **** 
  24:./Eigen/src/Core/DenseBase.h **** } // end namespace internal
  25:./Eigen/src/Core/DenseBase.h **** 
  26:./Eigen/src/Core/DenseBase.h **** /** \class DenseBase
  27:./Eigen/src/Core/DenseBase.h ****   * \ingroup Core_Module
  28:./Eigen/src/Core/DenseBase.h ****   *
  29:./Eigen/src/Core/DenseBase.h ****   * \brief Base class for all dense matrices, vectors, and arrays
  30:./Eigen/src/Core/DenseBase.h ****   *
  31:./Eigen/src/Core/DenseBase.h ****   * This class is the base that is inherited by all dense objects (matrix, vector, arrays,
  32:./Eigen/src/Core/DenseBase.h ****   * and related expression types). The common Eigen API for dense objects is contained in this clas
  33:./Eigen/src/Core/DenseBase.h ****   *
  34:./Eigen/src/Core/DenseBase.h ****   * \tparam Derived is the derived type, e.g., a matrix type or an expression.
  35:./Eigen/src/Core/DenseBase.h ****   *
  36:./Eigen/src/Core/DenseBase.h ****   * This class can be extended with the help of the plugin mechanism described on the page
  37:./Eigen/src/Core/DenseBase.h ****   * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_DENSEBASE_PLUGIN.
  38:./Eigen/src/Core/DenseBase.h ****   *
  39:./Eigen/src/Core/DenseBase.h ****   * \sa \blank \ref TopicClassHierarchy
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 17


  40:./Eigen/src/Core/DenseBase.h ****   */
  41:./Eigen/src/Core/DenseBase.h **** template<typename Derived> class DenseBase
  42:./Eigen/src/Core/DenseBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
  43:./Eigen/src/Core/DenseBase.h ****   : public DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value>
  44:./Eigen/src/Core/DenseBase.h **** #else
  45:./Eigen/src/Core/DenseBase.h ****   : public DenseCoeffsBase<Derived,DirectWriteAccessors>
  46:./Eigen/src/Core/DenseBase.h **** #endif // not EIGEN_PARSED_BY_DOXYGEN
  47:./Eigen/src/Core/DenseBase.h **** {
  48:./Eigen/src/Core/DenseBase.h ****   public:
  49:./Eigen/src/Core/DenseBase.h **** 
  50:./Eigen/src/Core/DenseBase.h ****     /** Inner iterator type to iterate over the coefficients of a row or column.
  51:./Eigen/src/Core/DenseBase.h ****       * \sa class InnerIterator
  52:./Eigen/src/Core/DenseBase.h ****       */
  53:./Eigen/src/Core/DenseBase.h ****     typedef Eigen::InnerIterator<Derived> InnerIterator;
  54:./Eigen/src/Core/DenseBase.h **** 
  55:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::traits<Derived>::StorageKind StorageKind;
  56:./Eigen/src/Core/DenseBase.h **** 
  57:./Eigen/src/Core/DenseBase.h ****     /**
  58:./Eigen/src/Core/DenseBase.h ****       * \brief The type used to store indices
  59:./Eigen/src/Core/DenseBase.h ****       * \details This typedef is relevant for types that store multiple indices such as
  60:./Eigen/src/Core/DenseBase.h ****       *          PermutationMatrix or Transpositions, otherwise it defaults to Eigen::Index
  61:./Eigen/src/Core/DenseBase.h ****       * \sa \blank \ref TopicPreprocessorDirectives, Eigen::Index, SparseMatrixBase.
  62:./Eigen/src/Core/DenseBase.h ****      */
  63:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
  64:./Eigen/src/Core/DenseBase.h **** 
  65:./Eigen/src/Core/DenseBase.h ****     /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<f
  66:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
  67:./Eigen/src/Core/DenseBase.h **** 
  68:./Eigen/src/Core/DenseBase.h ****     /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<f
  69:./Eigen/src/Core/DenseBase.h ****       *
  70:./Eigen/src/Core/DenseBase.h ****       * It is an alias for the Scalar type */
  71:./Eigen/src/Core/DenseBase.h ****     typedef Scalar value_type;
  72:./Eigen/src/Core/DenseBase.h **** 
  73:./Eigen/src/Core/DenseBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
  74:./Eigen/src/Core/DenseBase.h ****     typedef DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value> Base;
  75:./Eigen/src/Core/DenseBase.h **** 
  76:./Eigen/src/Core/DenseBase.h ****     using Base::derived;
  77:./Eigen/src/Core/DenseBase.h ****     using Base::const_cast_derived;
  78:./Eigen/src/Core/DenseBase.h ****     using Base::rows;
  79:./Eigen/src/Core/DenseBase.h ****     using Base::cols;
  80:./Eigen/src/Core/DenseBase.h ****     using Base::size;
  81:./Eigen/src/Core/DenseBase.h ****     using Base::rowIndexByOuterInner;
  82:./Eigen/src/Core/DenseBase.h ****     using Base::colIndexByOuterInner;
  83:./Eigen/src/Core/DenseBase.h ****     using Base::coeff;
  84:./Eigen/src/Core/DenseBase.h ****     using Base::coeffByOuterInner;
  85:./Eigen/src/Core/DenseBase.h ****     using Base::operator();
  86:./Eigen/src/Core/DenseBase.h ****     using Base::operator[];
  87:./Eigen/src/Core/DenseBase.h ****     using Base::x;
  88:./Eigen/src/Core/DenseBase.h ****     using Base::y;
  89:./Eigen/src/Core/DenseBase.h ****     using Base::z;
  90:./Eigen/src/Core/DenseBase.h ****     using Base::w;
  91:./Eigen/src/Core/DenseBase.h ****     using Base::stride;
  92:./Eigen/src/Core/DenseBase.h ****     using Base::innerStride;
  93:./Eigen/src/Core/DenseBase.h ****     using Base::outerStride;
  94:./Eigen/src/Core/DenseBase.h ****     using Base::rowStride;
  95:./Eigen/src/Core/DenseBase.h ****     using Base::colStride;
  96:./Eigen/src/Core/DenseBase.h ****     typedef typename Base::CoeffReturnType CoeffReturnType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 18


  97:./Eigen/src/Core/DenseBase.h **** 
  98:./Eigen/src/Core/DenseBase.h ****     enum {
  99:./Eigen/src/Core/DenseBase.h **** 
 100:./Eigen/src/Core/DenseBase.h ****       RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
 101:./Eigen/src/Core/DenseBase.h ****         /**< The number of rows at compile-time. This is just a copy of the value provided
 102:./Eigen/src/Core/DenseBase.h ****           * by the \a Derived type. If a value is not known at compile-time,
 103:./Eigen/src/Core/DenseBase.h ****           * it is set to the \a Dynamic constant.
 104:./Eigen/src/Core/DenseBase.h ****           * \sa MatrixBase::rows(), MatrixBase::cols(), ColsAtCompileTime, SizeAtCompileTime */
 105:./Eigen/src/Core/DenseBase.h **** 
 106:./Eigen/src/Core/DenseBase.h ****       ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
 107:./Eigen/src/Core/DenseBase.h ****         /**< The number of columns at compile-time. This is just a copy of the value provided
 108:./Eigen/src/Core/DenseBase.h ****           * by the \a Derived type. If a value is not known at compile-time,
 109:./Eigen/src/Core/DenseBase.h ****           * it is set to the \a Dynamic constant.
 110:./Eigen/src/Core/DenseBase.h ****           * \sa MatrixBase::rows(), MatrixBase::cols(), RowsAtCompileTime, SizeAtCompileTime */
 111:./Eigen/src/Core/DenseBase.h **** 
 112:./Eigen/src/Core/DenseBase.h **** 
 113:./Eigen/src/Core/DenseBase.h ****       SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileT
 114:./Eigen/src/Core/DenseBase.h ****                                                    internal::traits<Derived>::ColsAtCompileTime>::r
 115:./Eigen/src/Core/DenseBase.h ****         /**< This is equal to the number of coefficients, i.e. the number of
 116:./Eigen/src/Core/DenseBase.h ****           * rows times the number of columns, or to \a Dynamic if this is not
 117:./Eigen/src/Core/DenseBase.h ****           * known at compile-time. \sa RowsAtCompileTime, ColsAtCompileTime */
 118:./Eigen/src/Core/DenseBase.h **** 
 119:./Eigen/src/Core/DenseBase.h ****       MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
 120:./Eigen/src/Core/DenseBase.h ****         /**< This value is equal to the maximum possible number of rows that this expression
 121:./Eigen/src/Core/DenseBase.h ****           * might have. If this expression might have an arbitrarily high number of rows,
 122:./Eigen/src/Core/DenseBase.h ****           * this value is set to \a Dynamic.
 123:./Eigen/src/Core/DenseBase.h ****           *
 124:./Eigen/src/Core/DenseBase.h ****           * This value is useful to know when evaluating an expression, in order to determine
 125:./Eigen/src/Core/DenseBase.h ****           * whether it is possible to avoid doing a dynamic memory allocation.
 126:./Eigen/src/Core/DenseBase.h ****           *
 127:./Eigen/src/Core/DenseBase.h ****           * \sa RowsAtCompileTime, MaxColsAtCompileTime, MaxSizeAtCompileTime
 128:./Eigen/src/Core/DenseBase.h ****           */
 129:./Eigen/src/Core/DenseBase.h **** 
 130:./Eigen/src/Core/DenseBase.h ****       MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
 131:./Eigen/src/Core/DenseBase.h ****         /**< This value is equal to the maximum possible number of columns that this expression
 132:./Eigen/src/Core/DenseBase.h ****           * might have. If this expression might have an arbitrarily high number of columns,
 133:./Eigen/src/Core/DenseBase.h ****           * this value is set to \a Dynamic.
 134:./Eigen/src/Core/DenseBase.h ****           *
 135:./Eigen/src/Core/DenseBase.h ****           * This value is useful to know when evaluating an expression, in order to determine
 136:./Eigen/src/Core/DenseBase.h ****           * whether it is possible to avoid doing a dynamic memory allocation.
 137:./Eigen/src/Core/DenseBase.h ****           *
 138:./Eigen/src/Core/DenseBase.h ****           * \sa ColsAtCompileTime, MaxRowsAtCompileTime, MaxSizeAtCompileTime
 139:./Eigen/src/Core/DenseBase.h ****           */
 140:./Eigen/src/Core/DenseBase.h **** 
 141:./Eigen/src/Core/DenseBase.h ****       MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCo
 142:./Eigen/src/Core/DenseBase.h ****                                                       internal::traits<Derived>::MaxColsAtCompileTi
 143:./Eigen/src/Core/DenseBase.h ****         /**< This value is equal to the maximum possible number of coefficients that this expressio
 144:./Eigen/src/Core/DenseBase.h ****           * might have. If this expression might have an arbitrarily high number of coefficients,
 145:./Eigen/src/Core/DenseBase.h ****           * this value is set to \a Dynamic.
 146:./Eigen/src/Core/DenseBase.h ****           *
 147:./Eigen/src/Core/DenseBase.h ****           * This value is useful to know when evaluating an expression, in order to determine
 148:./Eigen/src/Core/DenseBase.h ****           * whether it is possible to avoid doing a dynamic memory allocation.
 149:./Eigen/src/Core/DenseBase.h ****           *
 150:./Eigen/src/Core/DenseBase.h ****           * \sa SizeAtCompileTime, MaxRowsAtCompileTime, MaxColsAtCompileTime
 151:./Eigen/src/Core/DenseBase.h ****           */
 152:./Eigen/src/Core/DenseBase.h **** 
 153:./Eigen/src/Core/DenseBase.h ****       IsVectorAtCompileTime = internal::traits<Derived>::RowsAtCompileTime == 1
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 19


 154:./Eigen/src/Core/DenseBase.h ****                            || internal::traits<Derived>::ColsAtCompileTime == 1,
 155:./Eigen/src/Core/DenseBase.h ****         /**< This is set to true if either the number of rows or the number of
 156:./Eigen/src/Core/DenseBase.h ****           * columns is known at compile-time to be equal to 1. Indeed, in that case,
 157:./Eigen/src/Core/DenseBase.h ****           * we are dealing with a column-vector (if there is only one column) or with
 158:./Eigen/src/Core/DenseBase.h ****           * a row-vector (if there is only one row). */
 159:./Eigen/src/Core/DenseBase.h **** 
 160:./Eigen/src/Core/DenseBase.h ****       NumDimensions = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2,
 161:./Eigen/src/Core/DenseBase.h ****         /**< This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors,
 162:./Eigen/src/Core/DenseBase.h ****          * and 2 for matrices.
 163:./Eigen/src/Core/DenseBase.h ****          */
 164:./Eigen/src/Core/DenseBase.h **** 
 165:./Eigen/src/Core/DenseBase.h ****       Flags = internal::traits<Derived>::Flags,
 166:./Eigen/src/Core/DenseBase.h ****         /**< This stores expression \ref flags flags which may or may not be inherited by new expre
 167:./Eigen/src/Core/DenseBase.h ****           * constructed from this one. See the \ref flags "list of flags".
 168:./Eigen/src/Core/DenseBase.h ****           */
 169:./Eigen/src/Core/DenseBase.h **** 
 170:./Eigen/src/Core/DenseBase.h ****       IsRowMajor = int(Flags) & RowMajorBit, /**< True if this expression has row-major storage ord
 171:./Eigen/src/Core/DenseBase.h **** 
 172:./Eigen/src/Core/DenseBase.h ****       InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)
 173:./Eigen/src/Core/DenseBase.h ****                              : int(IsRowMajor) ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
 174:./Eigen/src/Core/DenseBase.h **** 
 175:./Eigen/src/Core/DenseBase.h ****       InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,
 176:./Eigen/src/Core/DenseBase.h ****       OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret
 177:./Eigen/src/Core/DenseBase.h ****     };
 178:./Eigen/src/Core/DenseBase.h **** 
 179:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;
 180:./Eigen/src/Core/DenseBase.h **** 
 181:./Eigen/src/Core/DenseBase.h ****     enum { IsPlainObjectBase = 0 };
 182:./Eigen/src/Core/DenseBase.h **** 
 183:./Eigen/src/Core/DenseBase.h ****     /** The plain matrix type corresponding to this expression.
 184:./Eigen/src/Core/DenseBase.h ****       * \sa PlainObject */
 185:./Eigen/src/Core/DenseBase.h ****     typedef Matrix<typename internal::traits<Derived>::Scalar,
 186:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::RowsAtCompileTime,
 187:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::ColsAtCompileTime,
 188:./Eigen/src/Core/DenseBase.h ****                 AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
 189:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::MaxRowsAtCompileTime,
 190:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::MaxColsAtCompileTime
 191:./Eigen/src/Core/DenseBase.h ****           > PlainMatrix;
 192:./Eigen/src/Core/DenseBase.h **** 
 193:./Eigen/src/Core/DenseBase.h ****     /** The plain array type corresponding to this expression.
 194:./Eigen/src/Core/DenseBase.h ****       * \sa PlainObject */
 195:./Eigen/src/Core/DenseBase.h ****     typedef Array<typename internal::traits<Derived>::Scalar,
 196:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::RowsAtCompileTime,
 197:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::ColsAtCompileTime,
 198:./Eigen/src/Core/DenseBase.h ****                 AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
 199:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::MaxRowsAtCompileTime,
 200:./Eigen/src/Core/DenseBase.h ****                 internal::traits<Derived>::MaxColsAtCompileTime
 201:./Eigen/src/Core/DenseBase.h ****           > PlainArray;
 202:./Eigen/src/Core/DenseBase.h **** 
 203:./Eigen/src/Core/DenseBase.h ****     /** \brief The plain matrix or array type corresponding to this expression.
 204:./Eigen/src/Core/DenseBase.h ****       *
 205:./Eigen/src/Core/DenseBase.h ****       * This is not necessarily exactly the return type of eval(). In the case of plain matrices,
 206:./Eigen/src/Core/DenseBase.h ****       * the return type of eval() is a const reference to a matrix, not a matrix! It is however gua
 207:./Eigen/src/Core/DenseBase.h ****       * that the return type of eval() is either PlainObject or const PlainObject&.
 208:./Eigen/src/Core/DenseBase.h ****       */
 209:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::conditional<internal::is_same<typename internal::traits<Derived>::Xp
 210:./Eigen/src/Core/DenseBase.h ****                                  PlainMatrix, PlainArray>::type PlainObject;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 20


 211:./Eigen/src/Core/DenseBase.h **** 
 212:./Eigen/src/Core/DenseBase.h ****     /** \returns the number of nonzero coefficients which is in practice the number
 213:./Eigen/src/Core/DenseBase.h ****       * of stored coefficients. */
 214:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 215:./Eigen/src/Core/DenseBase.h ****     inline Index nonZeros() const { return size(); }
 216:./Eigen/src/Core/DenseBase.h **** 
 217:./Eigen/src/Core/DenseBase.h ****     /** \returns the outer size.
 218:./Eigen/src/Core/DenseBase.h ****       *
 219:./Eigen/src/Core/DenseBase.h ****       * \note For a vector, this returns just 1. For a matrix (non-vector), this is the major dimen
 220:./Eigen/src/Core/DenseBase.h ****       * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of columns fo
 221:./Eigen/src/Core/DenseBase.h ****       * column-major matrix, and the number of rows for a row-major matrix. */
 222:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 223:./Eigen/src/Core/DenseBase.h ****     Index outerSize() const
 224:./Eigen/src/Core/DenseBase.h ****     {
 225:./Eigen/src/Core/DenseBase.h ****       return IsVectorAtCompileTime ? 1
 226:./Eigen/src/Core/DenseBase.h ****            : int(IsRowMajor) ? this->rows() : this->cols();
 227:./Eigen/src/Core/DenseBase.h ****     }
 228:./Eigen/src/Core/DenseBase.h **** 
 229:./Eigen/src/Core/DenseBase.h ****     /** \returns the inner size.
 230:./Eigen/src/Core/DenseBase.h ****       *
 231:./Eigen/src/Core/DenseBase.h ****       * \note For a vector, this is just the size. For a matrix (non-vector), this is the minor dim
 232:./Eigen/src/Core/DenseBase.h ****       * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a
 233:./Eigen/src/Core/DenseBase.h ****       * column-major matrix, and the number of columns for a row-major matrix. */
 234:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 235:./Eigen/src/Core/DenseBase.h ****     Index innerSize() const
 236:./Eigen/src/Core/DenseBase.h ****     {
 237:./Eigen/src/Core/DenseBase.h ****       return IsVectorAtCompileTime ? this->size()
 238:./Eigen/src/Core/DenseBase.h ****            : int(IsRowMajor) ? this->cols() : this->rows();
 239:./Eigen/src/Core/DenseBase.h ****     }
 240:./Eigen/src/Core/DenseBase.h **** 
 241:./Eigen/src/Core/DenseBase.h ****     /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resi
 242:./Eigen/src/Core/DenseBase.h ****       * Matrix::resize() and Array::resize(). The present method only asserts that the new size equ
 243:./Eigen/src/Core/DenseBase.h ****       * nothing else.
 244:./Eigen/src/Core/DenseBase.h ****       */
 245:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 246:./Eigen/src/Core/DenseBase.h ****     void resize(Index newSize)
 247:./Eigen/src/Core/DenseBase.h ****     {
 248:./Eigen/src/Core/DenseBase.h ****       EIGEN_ONLY_USED_FOR_DEBUG(newSize);
 249:./Eigen/src/Core/DenseBase.h ****       eigen_assert(newSize == this->size()
 250:./Eigen/src/Core/DenseBase.h ****                 && "DenseBase::resize() does not actually allow to resize.");
 251:./Eigen/src/Core/DenseBase.h ****     }
 252:./Eigen/src/Core/DenseBase.h ****     /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resi
 253:./Eigen/src/Core/DenseBase.h ****       * Matrix::resize() and Array::resize(). The present method only asserts that the new size equ
 254:./Eigen/src/Core/DenseBase.h ****       * nothing else.
 255:./Eigen/src/Core/DenseBase.h ****       */
 256:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 257:./Eigen/src/Core/DenseBase.h ****     void resize(Index rows, Index cols)
 258:./Eigen/src/Core/DenseBase.h ****     {
 259:./Eigen/src/Core/DenseBase.h ****       EIGEN_ONLY_USED_FOR_DEBUG(rows);
 260:./Eigen/src/Core/DenseBase.h ****       EIGEN_ONLY_USED_FOR_DEBUG(cols);
 261:./Eigen/src/Core/DenseBase.h ****       eigen_assert(rows == this->rows() && cols == this->cols()
 262:./Eigen/src/Core/DenseBase.h ****                 && "DenseBase::resize() does not actually allow to resize.");
 263:./Eigen/src/Core/DenseBase.h ****     }
 264:./Eigen/src/Core/DenseBase.h **** 
 265:./Eigen/src/Core/DenseBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 266:./Eigen/src/Core/DenseBase.h ****     /** \internal Represents a matrix with all coefficients equal to one another*/
 267:./Eigen/src/Core/DenseBase.h ****     typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 21


 268:./Eigen/src/Core/DenseBase.h ****     /** \internal \deprecated Represents a vector with linearly spaced coefficients that allows seq
 269:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEPRECATED typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> SequentialL
 270:./Eigen/src/Core/DenseBase.h ****     /** \internal Represents a vector with linearly spaced coefficients that allows random access. 
 271:./Eigen/src/Core/DenseBase.h ****     typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> RandomAccessLinSpacedReturnT
 272:./Eigen/src/Core/DenseBase.h ****     /** \internal the return type of MatrixBase::eigenvalues() */
 273:./Eigen/src/Core/DenseBase.h ****     typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::
 274:./Eigen/src/Core/DenseBase.h **** 
 275:./Eigen/src/Core/DenseBase.h **** #endif // not EIGEN_PARSED_BY_DOXYGEN
 276:./Eigen/src/Core/DenseBase.h **** 
 277:./Eigen/src/Core/DenseBase.h ****     /** Copies \a other into *this. \returns a reference to *this. */
 278:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 279:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 280:./Eigen/src/Core/DenseBase.h ****     Derived& operator=(const DenseBase<OtherDerived>& other);
 281:./Eigen/src/Core/DenseBase.h **** 
 282:./Eigen/src/Core/DenseBase.h ****     /** Special case of the template operator=, in order to prevent the compiler
 283:./Eigen/src/Core/DenseBase.h ****       * from generating a default operator= (issue hit with g++ 4.1)
 284:./Eigen/src/Core/DenseBase.h ****       */
 285:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 286:./Eigen/src/Core/DenseBase.h ****     Derived& operator=(const DenseBase& other);
 287:./Eigen/src/Core/DenseBase.h **** 
 288:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 289:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 290:./Eigen/src/Core/DenseBase.h ****     Derived& operator=(const EigenBase<OtherDerived> &other);
 291:./Eigen/src/Core/DenseBase.h **** 
 292:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 293:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 294:./Eigen/src/Core/DenseBase.h ****     Derived& operator+=(const EigenBase<OtherDerived> &other);
 295:./Eigen/src/Core/DenseBase.h **** 
 296:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 297:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 298:./Eigen/src/Core/DenseBase.h ****     Derived& operator-=(const EigenBase<OtherDerived> &other);
 299:./Eigen/src/Core/DenseBase.h **** 
 300:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 301:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 302:./Eigen/src/Core/DenseBase.h ****     Derived& operator=(const ReturnByValue<OtherDerived>& func);
 303:./Eigen/src/Core/DenseBase.h **** 
 304:./Eigen/src/Core/DenseBase.h ****     /** \internal
 305:./Eigen/src/Core/DenseBase.h ****       * Copies \a other into *this without evaluating other. \returns a reference to *this. */
 306:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 307:./Eigen/src/Core/DenseBase.h ****     /** \deprecated */
 308:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
 309:./Eigen/src/Core/DenseBase.h ****     Derived& lazyAssign(const DenseBase<OtherDerived>& other);
 310:./Eigen/src/Core/DenseBase.h **** 
 311:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 312:./Eigen/src/Core/DenseBase.h ****     CommaInitializer<Derived> operator<< (const Scalar& s);
 313:./Eigen/src/Core/DenseBase.h **** 
 314:./Eigen/src/Core/DenseBase.h ****     template<unsigned int Added,unsigned int Removed>
 315:./Eigen/src/Core/DenseBase.h ****     /** \deprecated it now returns \c *this */
 316:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEPRECATED
 317:./Eigen/src/Core/DenseBase.h ****     const Derived& flagged() const
 318:./Eigen/src/Core/DenseBase.h ****     { return derived(); }
 319:./Eigen/src/Core/DenseBase.h **** 
 320:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 321:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 322:./Eigen/src/Core/DenseBase.h ****     CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);
 323:./Eigen/src/Core/DenseBase.h **** 
 324:./Eigen/src/Core/DenseBase.h ****     typedef Transpose<Derived> TransposeReturnType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 22


 325:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 326:./Eigen/src/Core/DenseBase.h ****     TransposeReturnType transpose();
 327:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;
 328:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 329:./Eigen/src/Core/DenseBase.h ****     ConstTransposeReturnType transpose() const;
 330:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 331:./Eigen/src/Core/DenseBase.h ****     void transposeInPlace();
 332:./Eigen/src/Core/DenseBase.h **** 
 333:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType
 334:./Eigen/src/Core/DenseBase.h ****     Constant(Index rows, Index cols, const Scalar& value);
 335:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType
 336:./Eigen/src/Core/DenseBase.h ****     Constant(Index size, const Scalar& value);
 337:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType
 338:./Eigen/src/Core/DenseBase.h ****     Constant(const Scalar& value);
 339:./Eigen/src/Core/DenseBase.h **** 
 340:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
 341:./Eigen/src/Core/DenseBase.h ****     LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);
 342:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
 343:./Eigen/src/Core/DenseBase.h ****     LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
 344:./Eigen/src/Core/DenseBase.h **** 
 345:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
 346:./Eigen/src/Core/DenseBase.h ****     LinSpaced(Index size, const Scalar& low, const Scalar& high);
 347:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
 348:./Eigen/src/Core/DenseBase.h ****     LinSpaced(const Scalar& low, const Scalar& high);
 349:./Eigen/src/Core/DenseBase.h **** 
 350:./Eigen/src/Core/DenseBase.h ****     template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
 351:./Eigen/src/Core/DenseBase.h ****     static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
 352:./Eigen/src/Core/DenseBase.h ****     NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);
 353:./Eigen/src/Core/DenseBase.h ****     template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
 354:./Eigen/src/Core/DenseBase.h ****     static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
 355:./Eigen/src/Core/DenseBase.h ****     NullaryExpr(Index size, const CustomNullaryOp& func);
 356:./Eigen/src/Core/DenseBase.h ****     template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
 357:./Eigen/src/Core/DenseBase.h ****     static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
 358:./Eigen/src/Core/DenseBase.h ****     NullaryExpr(const CustomNullaryOp& func);
 359:./Eigen/src/Core/DenseBase.h **** 
 360:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index rows, Index cols);
 361:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index size);
 362:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Zero();
 363:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index rows, Index cols);
 364:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index size);
 365:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC static const ConstantReturnType Ones();
 366:./Eigen/src/Core/DenseBase.h **** 
 367:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC void fill(const Scalar& value);
 368:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setConstant(const Scalar& value);
 369:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);
 370:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setLinSpaced(const Scalar& low, const Scalar& high);
 371:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setZero();
 372:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setOnes();
 373:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Derived& setRandom();
 374:./Eigen/src/Core/DenseBase.h **** 
 375:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived> EIGEN_DEVICE_FUNC
 376:./Eigen/src/Core/DenseBase.h ****     bool isApprox(const DenseBase<OtherDerived>& other,
 377:./Eigen/src/Core/DenseBase.h ****                   const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 378:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 379:./Eigen/src/Core/DenseBase.h ****     bool isMuchSmallerThan(const RealScalar& other,
 380:./Eigen/src/Core/DenseBase.h ****                            const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 381:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived> EIGEN_DEVICE_FUNC
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 23


 382:./Eigen/src/Core/DenseBase.h ****     bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,
 383:./Eigen/src/Core/DenseBase.h ****                            const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 384:./Eigen/src/Core/DenseBase.h **** 
 385:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTrai
 386:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scala
 387:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) co
 388:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) co
 389:./Eigen/src/Core/DenseBase.h **** 
 390:./Eigen/src/Core/DenseBase.h ****     inline bool hasNaN() const;
 391:./Eigen/src/Core/DenseBase.h ****     inline bool allFinite() const;
 392:./Eigen/src/Core/DenseBase.h **** 
 393:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 394:./Eigen/src/Core/DenseBase.h ****     Derived& operator*=(const Scalar& other);
 395:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 396:./Eigen/src/Core/DenseBase.h ****     Derived& operator/=(const Scalar& other);
 397:./Eigen/src/Core/DenseBase.h **** 
 398:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::typ
 399:./Eigen/src/Core/DenseBase.h ****     /** \returns the matrix or vector obtained by evaluating this expression.
 400:./Eigen/src/Core/DenseBase.h ****       *
 401:./Eigen/src/Core/DenseBase.h ****       * Notice that in the case of a plain matrix or vector (not an expression) this function just 
 402:./Eigen/src/Core/DenseBase.h ****       * a const reference, in order to avoid a useless copy.
 403:./Eigen/src/Core/DenseBase.h ****       *
 404:./Eigen/src/Core/DenseBase.h ****       * \warning Be careful with eval() and the auto C++ keyword, as detailed in this \link TopicPi
 405:./Eigen/src/Core/DenseBase.h ****       */
 406:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 407:./Eigen/src/Core/DenseBase.h ****     EIGEN_STRONG_INLINE EvalReturnType eval() const
 408:./Eigen/src/Core/DenseBase.h ****     {
 409:./Eigen/src/Core/DenseBase.h ****       // Even though MSVC does not honor strong inlining when the return type
 410:./Eigen/src/Core/DenseBase.h ****       // is a dynamic matrix, we desperately need strong inlining for fixed
 411:./Eigen/src/Core/DenseBase.h ****       // size types on MSVC.
 412:./Eigen/src/Core/DenseBase.h ****       return typename internal::eval<Derived>::type(derived());
 413:./Eigen/src/Core/DenseBase.h ****     }
 414:./Eigen/src/Core/DenseBase.h **** 
 415:./Eigen/src/Core/DenseBase.h ****     /** swaps *this with the expression \a other.
 416:./Eigen/src/Core/DenseBase.h ****       *
 417:./Eigen/src/Core/DenseBase.h ****       */
 418:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 419:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 420:./Eigen/src/Core/DenseBase.h ****     void swap(const DenseBase<OtherDerived>& other)
 421:./Eigen/src/Core/DenseBase.h ****     {
 422:./Eigen/src/Core/DenseBase.h ****       EIGEN_STATIC_ASSERT(!OtherDerived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_R
 423:./Eigen/src/Core/DenseBase.h ****       eigen_assert(rows()==other.rows() && cols()==other.cols());
 424:./Eigen/src/Core/DenseBase.h ****       call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
 425:./Eigen/src/Core/DenseBase.h ****     }
 426:./Eigen/src/Core/DenseBase.h **** 
 427:./Eigen/src/Core/DenseBase.h ****     /** swaps *this with the matrix or array \a other.
 428:./Eigen/src/Core/DenseBase.h ****       *
 429:./Eigen/src/Core/DenseBase.h ****       */
 430:./Eigen/src/Core/DenseBase.h ****     template<typename OtherDerived>
 431:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 432:./Eigen/src/Core/DenseBase.h ****     void swap(PlainObjectBase<OtherDerived>& other)
 433:./Eigen/src/Core/DenseBase.h ****     {
 434:./Eigen/src/Core/DenseBase.h ****       eigen_assert(rows()==other.rows() && cols()==other.cols());
 435:./Eigen/src/Core/DenseBase.h ****       call_assignment(derived(), other.derived(), internal::swap_assign_op<Scalar>());
 436:./Eigen/src/Core/DenseBase.h ****     }
 437:./Eigen/src/Core/DenseBase.h **** 
 438:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline const NestByValue<Derived> nestByValue() const;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 24


 439:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;
 440:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline ForceAlignedAccess<Derived> forceAlignedAccess();
 441:./Eigen/src/Core/DenseBase.h ****     template<bool Enable> EIGEN_DEVICE_FUNC
 442:./Eigen/src/Core/DenseBase.h ****     inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type 
 443:./Eigen/src/Core/DenseBase.h ****     template<bool Enable> EIGEN_DEVICE_FUNC
 444:./Eigen/src/Core/DenseBase.h ****     inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceA
 445:./Eigen/src/Core/DenseBase.h **** 
 446:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Scalar sum() const;
 447:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Scalar mean() const;
 448:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Scalar trace() const;
 449:./Eigen/src/Core/DenseBase.h **** 
 450:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Scalar prod() const;
 451:./Eigen/src/Core/DenseBase.h **** 
 452:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation>
 453:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar minCoeff() const;
 454:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation>
 455:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar maxCoeff() const;
 456:./Eigen/src/Core/DenseBase.h **** 
 457:./Eigen/src/Core/DenseBase.h **** 
 458:./Eigen/src/Core/DenseBase.h ****     // By default, the fastest version with undefined NaN propagation semantics is
 459:./Eigen/src/Core/DenseBase.h ****     // used.
 460:./Eigen/src/Core/DenseBase.h ****     // TODO(rmlarsen): Replace with default template argument when we move to
 461:./Eigen/src/Core/DenseBase.h ****     // c++11 or beyond.
 462:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar minCoeff() const {
 463:./Eigen/src/Core/DenseBase.h ****       return minCoeff<PropagateFast>();
 464:./Eigen/src/Core/DenseBase.h ****     }
 465:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar maxCoeff() const {
 466:./Eigen/src/Core/DenseBase.h ****       return maxCoeff<PropagateFast>();
 467:./Eigen/src/Core/DenseBase.h ****     }
 468:./Eigen/src/Core/DenseBase.h **** 
 469:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation, typename IndexType>
 470:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 471:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;
 472:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation, typename IndexType>
 473:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 474:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;
 475:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation, typename IndexType>
 476:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 477:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;
 478:./Eigen/src/Core/DenseBase.h ****     template<int NaNPropagation, typename IndexType>
 479:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 480:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;
 481:./Eigen/src/Core/DenseBase.h **** 
 482:./Eigen/src/Core/DenseBase.h ****     // TODO(rmlarsen): Replace these methods with a default template argument.
 483:./Eigen/src/Core/DenseBase.h ****     template<typename IndexType>
 484:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline
 485:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const {
 486:./Eigen/src/Core/DenseBase.h ****       return minCoeff<PropagateFast>(row, col);
 487:./Eigen/src/Core/DenseBase.h ****     }
 488:./Eigen/src/Core/DenseBase.h ****     template<typename IndexType>
 489:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline
 490:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const {
 491:./Eigen/src/Core/DenseBase.h ****       return maxCoeff<PropagateFast>(row, col);
 492:./Eigen/src/Core/DenseBase.h ****     }
 493:./Eigen/src/Core/DenseBase.h ****     template<typename IndexType>
 494:./Eigen/src/Core/DenseBase.h ****      EIGEN_DEVICE_FUNC inline
 495:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 25


 496:./Eigen/src/Core/DenseBase.h ****       return minCoeff<PropagateFast>(index);
 497:./Eigen/src/Core/DenseBase.h ****     }
 498:./Eigen/src/Core/DenseBase.h ****     template<typename IndexType>
 499:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline
 500:./Eigen/src/Core/DenseBase.h ****     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const {
 501:./Eigen/src/Core/DenseBase.h ****       return maxCoeff<PropagateFast>(index);
 502:./Eigen/src/Core/DenseBase.h ****     }
 503:./Eigen/src/Core/DenseBase.h ****   
 504:./Eigen/src/Core/DenseBase.h ****     template<typename BinaryOp>
 505:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 506:./Eigen/src/Core/DenseBase.h ****     Scalar redux(const BinaryOp& func) const;
 507:./Eigen/src/Core/DenseBase.h **** 
 508:./Eigen/src/Core/DenseBase.h ****     template<typename Visitor>
 509:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 510:./Eigen/src/Core/DenseBase.h ****     void visit(Visitor& func) const;
 511:./Eigen/src/Core/DenseBase.h **** 
 512:./Eigen/src/Core/DenseBase.h ****     /** \returns a WithFormat proxy object allowing to print a matrix the with given
 513:./Eigen/src/Core/DenseBase.h ****       * format \a fmt.
 514:./Eigen/src/Core/DenseBase.h ****       *
 515:./Eigen/src/Core/DenseBase.h ****       * See class IOFormat for some examples.
 516:./Eigen/src/Core/DenseBase.h ****       *
 517:./Eigen/src/Core/DenseBase.h ****       * \sa class IOFormat, class WithFormat
 518:./Eigen/src/Core/DenseBase.h ****       */
 519:./Eigen/src/Core/DenseBase.h ****     inline const WithFormat<Derived> format(const IOFormat& fmt) const
 520:./Eigen/src/Core/DenseBase.h ****     {
 521:./Eigen/src/Core/DenseBase.h ****       return WithFormat<Derived>(derived(), fmt);
 522:./Eigen/src/Core/DenseBase.h ****     }
 523:./Eigen/src/Core/DenseBase.h **** 
 524:./Eigen/src/Core/DenseBase.h ****     /** \returns the unique coefficient of a 1x1 expression */
 525:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 526:./Eigen/src/Core/DenseBase.h ****     CoeffReturnType value() const
 527:./Eigen/src/Core/DenseBase.h ****     {
 528:./Eigen/src/Core/DenseBase.h ****       EIGEN_STATIC_ASSERT_SIZE_1x1(Derived)
 529:./Eigen/src/Core/DenseBase.h ****       eigen_assert(this->rows() == 1 && this->cols() == 1);
 530:./Eigen/src/Core/DenseBase.h ****       return derived().coeff(0,0);
 531:./Eigen/src/Core/DenseBase.h ****     }
 532:./Eigen/src/Core/DenseBase.h **** 
 533:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool all() const;
 534:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC bool any() const;
 535:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC Index count() const;
 536:./Eigen/src/Core/DenseBase.h **** 
 537:./Eigen/src/Core/DenseBase.h ****     typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;
 538:./Eigen/src/Core/DenseBase.h ****     typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;
 539:./Eigen/src/Core/DenseBase.h ****     typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;
 540:./Eigen/src/Core/DenseBase.h ****     typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;
 541:./Eigen/src/Core/DenseBase.h **** 
 542:./Eigen/src/Core/DenseBase.h ****     /** \returns a VectorwiseOp wrapper of *this for broadcasting and partial reductions
 543:./Eigen/src/Core/DenseBase.h ****     *
 544:./Eigen/src/Core/DenseBase.h ****     * Example: \include MatrixBase_rowwise.cpp
 545:./Eigen/src/Core/DenseBase.h ****     * Output: \verbinclude MatrixBase_rowwise.out
 546:./Eigen/src/Core/DenseBase.h ****     *
 547:./Eigen/src/Core/DenseBase.h ****     * \sa colwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
 548:./Eigen/src/Core/DenseBase.h ****     */
 549:./Eigen/src/Core/DenseBase.h ****     //Code moved here due to a CUDA compiler bug
 550:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {
 551:./Eigen/src/Core/DenseBase.h ****       return ConstRowwiseReturnType(derived());
 552:./Eigen/src/Core/DenseBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 26


 553:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC RowwiseReturnType rowwise();
 554:./Eigen/src/Core/DenseBase.h **** 
 555:./Eigen/src/Core/DenseBase.h ****     /** \returns a VectorwiseOp wrapper of *this broadcasting and partial reductions
 556:./Eigen/src/Core/DenseBase.h ****     *
 557:./Eigen/src/Core/DenseBase.h ****     * Example: \include MatrixBase_colwise.cpp
 558:./Eigen/src/Core/DenseBase.h ****     * Output: \verbinclude MatrixBase_colwise.out
 559:./Eigen/src/Core/DenseBase.h ****     *
 560:./Eigen/src/Core/DenseBase.h ****     * \sa rowwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
 561:./Eigen/src/Core/DenseBase.h ****     */
 562:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {
 563:./Eigen/src/Core/DenseBase.h ****       return ConstColwiseReturnType(derived());
 564:./Eigen/src/Core/DenseBase.h ****     }
 565:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC ColwiseReturnType colwise();
 566:./Eigen/src/Core/DenseBase.h **** 
 567:./Eigen/src/Core/DenseBase.h ****     typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;
 568:./Eigen/src/Core/DenseBase.h ****     static const RandomReturnType Random(Index rows, Index cols);
 569:./Eigen/src/Core/DenseBase.h ****     static const RandomReturnType Random(Index size);
 570:./Eigen/src/Core/DenseBase.h ****     static const RandomReturnType Random();
 571:./Eigen/src/Core/DenseBase.h **** 
 572:./Eigen/src/Core/DenseBase.h ****     template<typename ThenDerived,typename ElseDerived>
 573:./Eigen/src/Core/DenseBase.h ****     inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived,ElseDerived>
 574:./Eigen/src/Core/DenseBase.h ****     select(const DenseBase<ThenDerived>& thenMatrix,
 575:./Eigen/src/Core/DenseBase.h ****            const DenseBase<ElseDerived>& elseMatrix) const;
 576:./Eigen/src/Core/DenseBase.h **** 
 577:./Eigen/src/Core/DenseBase.h ****     template<typename ThenDerived>
 578:./Eigen/src/Core/DenseBase.h ****     inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturn
 579:./Eigen/src/Core/DenseBase.h ****     select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar
 580:./Eigen/src/Core/DenseBase.h **** 
 581:./Eigen/src/Core/DenseBase.h ****     template<typename ElseDerived>
 582:./Eigen/src/Core/DenseBase.h ****     inline EIGEN_DEVICE_FUNC const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDe
 583:./Eigen/src/Core/DenseBase.h ****     select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix
 584:./Eigen/src/Core/DenseBase.h **** 
 585:./Eigen/src/Core/DenseBase.h ****     template<int p> RealScalar lpNorm() const;
 586:./Eigen/src/Core/DenseBase.h **** 
 587:./Eigen/src/Core/DenseBase.h ****     template<int RowFactor, int ColFactor>
 588:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 589:./Eigen/src/Core/DenseBase.h ****     const Replicate<Derived,RowFactor,ColFactor> replicate() const;
 590:./Eigen/src/Core/DenseBase.h ****     /**
 591:./Eigen/src/Core/DenseBase.h ****     * \return an expression of the replication of \c *this
 592:./Eigen/src/Core/DenseBase.h ****     *
 593:./Eigen/src/Core/DenseBase.h ****     * Example: \include MatrixBase_replicate_int_int.cpp
 594:./Eigen/src/Core/DenseBase.h ****     * Output: \verbinclude MatrixBase_replicate_int_int.out
 595:./Eigen/src/Core/DenseBase.h ****     *
 596:./Eigen/src/Core/DenseBase.h ****     * \sa VectorwiseOp::replicate(), DenseBase::replicate<int,int>(), class Replicate
 597:./Eigen/src/Core/DenseBase.h ****     */
 598:./Eigen/src/Core/DenseBase.h ****     //Code moved here due to a CUDA compiler bug
 599:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 600:./Eigen/src/Core/DenseBase.h ****     const Replicate<Derived, Dynamic, Dynamic> replicate(Index rowFactor, Index colFactor) const
 601:./Eigen/src/Core/DenseBase.h ****     {
 602:./Eigen/src/Core/DenseBase.h ****       return Replicate<Derived, Dynamic, Dynamic>(derived(), rowFactor, colFactor);
 603:./Eigen/src/Core/DenseBase.h ****     }
 604:./Eigen/src/Core/DenseBase.h **** 
 605:./Eigen/src/Core/DenseBase.h ****     typedef Reverse<Derived, BothDirections> ReverseReturnType;
 606:./Eigen/src/Core/DenseBase.h ****     typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;
 607:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC ReverseReturnType reverse();
 608:./Eigen/src/Core/DenseBase.h ****     /** This is the const version of reverse(). */
 609:./Eigen/src/Core/DenseBase.h ****     //Code moved here due to a CUDA compiler bug
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 27


 610:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const
 611:./Eigen/src/Core/DenseBase.h ****     {
 612:./Eigen/src/Core/DenseBase.h ****       return ConstReverseReturnType(derived());
 613:./Eigen/src/Core/DenseBase.h ****     }
 614:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC void reverseInPlace();
 615:./Eigen/src/Core/DenseBase.h **** 
 616:./Eigen/src/Core/DenseBase.h ****     #ifdef EIGEN_PARSED_BY_DOXYGEN
 617:./Eigen/src/Core/DenseBase.h ****     /** STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomA
 618:./Eigen/src/Core/DenseBase.h ****       * iterator type as returned by the begin() and end() methods.
 619:./Eigen/src/Core/DenseBase.h ****       */
 620:./Eigen/src/Core/DenseBase.h ****     typedef random_access_iterator_type iterator;
 621:./Eigen/src/Core/DenseBase.h ****     /** This is the const version of iterator (aka read-only) */
 622:./Eigen/src/Core/DenseBase.h ****     typedef random_access_iterator_type const_iterator;
 623:./Eigen/src/Core/DenseBase.h ****     #else
 624:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
 625:./Eigen/src/Core/DenseBase.h ****                                             internal::pointer_based_stl_iterator<Derived>,
 626:./Eigen/src/Core/DenseBase.h ****                                             internal::generic_randaccess_stl_iterator<Derived>
 627:./Eigen/src/Core/DenseBase.h ****                                           >::type iterator_type;
 628:./Eigen/src/Core/DenseBase.h **** 
 629:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
 630:./Eigen/src/Core/DenseBase.h ****                                             internal::pointer_based_stl_iterator<const Derived>,
 631:./Eigen/src/Core/DenseBase.h ****                                             internal::generic_randaccess_stl_iterator<const Derived
 632:./Eigen/src/Core/DenseBase.h ****                                           >::type const_iterator_type;
 633:./Eigen/src/Core/DenseBase.h **** 
 634:./Eigen/src/Core/DenseBase.h ****     // Stl-style iterators are supported only for vectors.
 635:./Eigen/src/Core/DenseBase.h **** 
 636:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::conditional< IsVectorAtCompileTime,
 637:./Eigen/src/Core/DenseBase.h ****                                             iterator_type,
 638:./Eigen/src/Core/DenseBase.h ****                                             void
 639:./Eigen/src/Core/DenseBase.h ****                                           >::type iterator;
 640:./Eigen/src/Core/DenseBase.h **** 
 641:./Eigen/src/Core/DenseBase.h ****     typedef typename internal::conditional< IsVectorAtCompileTime,
 642:./Eigen/src/Core/DenseBase.h ****                                             const_iterator_type,
 643:./Eigen/src/Core/DenseBase.h ****                                             void
 644:./Eigen/src/Core/DenseBase.h ****                                           >::type const_iterator;
 645:./Eigen/src/Core/DenseBase.h ****     #endif
 646:./Eigen/src/Core/DenseBase.h **** 
 647:./Eigen/src/Core/DenseBase.h ****     inline iterator begin();
 648:./Eigen/src/Core/DenseBase.h ****     inline const_iterator begin() const;
 649:./Eigen/src/Core/DenseBase.h ****     inline const_iterator cbegin() const;
 650:./Eigen/src/Core/DenseBase.h ****     inline iterator end();
 651:./Eigen/src/Core/DenseBase.h ****     inline const_iterator end() const;
 652:./Eigen/src/Core/DenseBase.h ****     inline const_iterator cend() const;
 653:./Eigen/src/Core/DenseBase.h **** 
 654:./Eigen/src/Core/DenseBase.h **** #define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::DenseBase
 655:./Eigen/src/Core/DenseBase.h **** #define EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
 656:./Eigen/src/Core/DenseBase.h **** #define EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF(COND)
 657:./Eigen/src/Core/DenseBase.h **** #define EIGEN_DOC_UNARY_ADDONS(X,Y)
 658:./Eigen/src/Core/DenseBase.h **** #   include "../plugins/CommonCwiseUnaryOps.h"
 659:./Eigen/src/Core/DenseBase.h **** #   include "../plugins/BlockMethods.h"
 660:./Eigen/src/Core/DenseBase.h **** #   include "../plugins/IndexedViewMethods.h"
 661:./Eigen/src/Core/DenseBase.h **** #   include "../plugins/ReshapedMethods.h"
 662:./Eigen/src/Core/DenseBase.h **** #   ifdef EIGEN_DENSEBASE_PLUGIN
 663:./Eigen/src/Core/DenseBase.h **** #     include EIGEN_DENSEBASE_PLUGIN
 664:./Eigen/src/Core/DenseBase.h **** #   endif
 665:./Eigen/src/Core/DenseBase.h **** #undef EIGEN_CURRENT_STORAGE_BASE_CLASS
 666:./Eigen/src/Core/DenseBase.h **** #undef EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 28


 667:./Eigen/src/Core/DenseBase.h **** #undef EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF
 668:./Eigen/src/Core/DenseBase.h **** #undef EIGEN_DOC_UNARY_ADDONS
 669:./Eigen/src/Core/DenseBase.h **** 
 670:./Eigen/src/Core/DenseBase.h ****     // disable the use of evalTo for dense objects with a nice compilation error
 671:./Eigen/src/Core/DenseBase.h ****     template<typename Dest>
 672:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC
 673:./Eigen/src/Core/DenseBase.h ****     inline void evalTo(Dest& ) const
 674:./Eigen/src/Core/DenseBase.h ****     {
 675:./Eigen/src/Core/DenseBase.h ****       EIGEN_STATIC_ASSERT((internal::is_same<Dest,void>::value),THE_EVAL_EVALTO_FUNCTION_SHOULD_NEV
 676:./Eigen/src/Core/DenseBase.h ****     }
 677:./Eigen/src/Core/DenseBase.h **** 
 678:./Eigen/src/Core/DenseBase.h ****   protected:
 679:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEFAULT_COPY_CONSTRUCTOR(DenseBase)
 680:./Eigen/src/Core/DenseBase.h ****     /** Default constructor. Do nothing. */
 681:./Eigen/src/Core/DenseBase.h ****     EIGEN_DEVICE_FUNC DenseBase()
 140              		.loc 5 681 23 view .LVU10
 141              		.loc 5 681 23 is_stmt 0 view .LVU11
 142              	.LBE343:
 143              	.LBE342:
  69:./Eigen/src/Core/CwiseNullaryOp.h ****       : m_rows(rows), m_cols(cols), m_functor(func)
 144              		.loc 3 69 9 view .LVU12
 145 0008 FFF7FEFF 		bl	_ZN5Eigen8internal19variable_if_dynamicIiLi3EEC1Ei
 146              	.LVL6:
 147              		.loc 3 69 23 view .LVU13
 148 000c 2146     		mov	r1, r4
 149 000e 681C     		adds	r0, r5, #1
 150 0010 FFF7FEFF 		bl	_ZN5Eigen8internal19variable_if_dynamicIiLi3EEC1Ei
 151              	.LVL7:
 152              	.LBB344:
 153              	.LBI344:
 154              		.file 6 "./Eigen/src/Core/Random.h"
   1:./Eigen/src/Core/Random.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/Random.h **** // for linear algebra.
   3:./Eigen/src/Core/Random.h **** //
   4:./Eigen/src/Core/Random.h **** // Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/Random.h **** //
   6:./Eigen/src/Core/Random.h **** // This Source Code Form is subject to the terms of the Mozilla
   7:./Eigen/src/Core/Random.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   8:./Eigen/src/Core/Random.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
   9:./Eigen/src/Core/Random.h **** 
  10:./Eigen/src/Core/Random.h **** #ifndef EIGEN_RANDOM_H
  11:./Eigen/src/Core/Random.h **** #define EIGEN_RANDOM_H
  12:./Eigen/src/Core/Random.h **** 
  13:./Eigen/src/Core/Random.h **** namespace Eigen { 
  14:./Eigen/src/Core/Random.h **** 
  15:./Eigen/src/Core/Random.h **** namespace internal {
  16:./Eigen/src/Core/Random.h **** 
  17:./Eigen/src/Core/Random.h **** template<typename Scalar> struct scalar_random_op {
  18:./Eigen/src/Core/Random.h ****   EIGEN_EMPTY_STRUCT_CTOR(scalar_random_op)
 155              		.loc 6 18 3 is_stmt 1 view .LVU14
 156              		.loc 6 18 3 is_stmt 0 view .LVU15
 157              	.LBE344:
  70:./Eigen/src/Core/CwiseNullaryOp.h ****     {
  71:./Eigen/src/Core/CwiseNullaryOp.h ****       eigen_assert(rows >= 0
 158              		.loc 3 71 7 view .LVU16
 159 0014 032E     		cmp	r6, #3
 160 0016 05D1     		bne	.L10
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 29


 161              		.loc 3 71 7 discriminator 1 view .LVU17
 162 0018 002C     		cmp	r4, #0
 163 001a 03DB     		blt	.L10
 164              		.loc 3 71 7 discriminator 3 view .LVU18
 165 001c 032C     		cmp	r4, #3
 166 001e 01D1     		bne	.L10
 167              	.LBE341:
  72:./Eigen/src/Core/CwiseNullaryOp.h ****             && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows)
  73:./Eigen/src/Core/CwiseNullaryOp.h ****             &&  cols >= 0
  74:./Eigen/src/Core/CwiseNullaryOp.h ****             && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols));
  75:./Eigen/src/Core/CwiseNullaryOp.h ****     }
 168              		.loc 3 75 5 view .LVU19
 169 0020 2846     		mov	r0, r5
 170 0022 70BD     		pop	{r4, r5, r6, pc}
 171              	.LVL8:
 172              	.L10:
 173              	.LBB345:
  71:./Eigen/src/Core/CwiseNullaryOp.h ****             && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows)
 174              		.loc 3 71 7 discriminator 5 view .LVU20
 175 0024 024B     		ldr	r3, .L13
 176 0026 034A     		ldr	r2, .L13+4
 177 0028 4721     		movs	r1, #71
 178 002a 0348     		ldr	r0, .L13+8
 179 002c FFF7FEFF 		bl	__assert_func
 180              	.LVL9:
 181              	.L14:
 182              		.align	2
 183              	.L13:
 184 0030 00000000 		.word	.LC3
 185 0034 98000000 		.word	.LC4
 186 0038 84010000 		.word	.LC5
 187              	.LBE345:
 188              		.cfi_endproc
 189              	.LFE9329:
 190              		.fnend
 192              		.weak	_ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3E
 193              		.thumb_set _ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3
 194              		.section	.rodata._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii.str1.4,"
 195              		.align	2
 196              	.LC6:
 197 0000 28212852 		.ascii	"(!(RowsAtCompileTime!=Dynamic) || (rows==RowsAtComp"
 197      6F777341 
 197      74436F6D 
 197      70696C65 
 197      54696D65 
 198 0033 696C6554 		.ascii	"ileTime)) && (!(ColsAtCompileTime!=Dynamic) || (col"
 198      696D6529 
 198      29202626 
 198      20282128 
 198      436F6C73 
 199 0066 733D3D43 		.ascii	"s==ColsAtCompileTime)) && (!(RowsAtCompileTime==Dyn"
 199      6F6C7341 
 199      74436F6D 
 199      70696C65 
 199      54696D65 
 200 0099 616D6963 		.ascii	"amic && MaxRowsAtCompileTime!=Dynamic) || (rows<=Ma"
 200      20262620 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 30


 200      4D617852 
 200      6F777341 
 200      74436F6D 
 201 00cc 78526F77 		.ascii	"xRowsAtCompileTime)) && (!(ColsAtCompileTime==Dynam"
 201      73417443 
 201      6F6D7069 
 201      6C655469 
 201      6D652929 
 202 00ff 69632026 		.ascii	"ic && MaxColsAtCompileTime!=Dynamic) || (cols<=MaxC"
 202      26204D61 
 202      78436F6C 
 202      73417443 
 202      6F6D7069 
 203 0132 6F6C7341 		.ascii	"olsAtCompileTime)) && rows>=0 && cols>=0 && \"Inval"
 203      74436F6D 
 203      70696C65 
 203      54696D65 
 203      29292026 
 204 0164 69642073 		.ascii	"id sizes when resizing a matrix or array.\"\000"
 204      697A6573 
 204      20776865 
 204      6E207265 
 204      73697A69 
 205 018f 00       		.align	2
 206              	.LC7:
 207 0190 766F6964 		.ascii	"void Eigen::PlainObjectBase<Derived>::resize(Eigen:"
 207      20456967 
 207      656E3A3A 
 207      506C6169 
 207      6E4F626A 
 208 01c3 3A496E64 		.ascii	":Index, Eigen::Index) [with Derived = Eigen::Matrix"
 208      65782C20 
 208      45696765 
 208      6E3A3A49 
 208      6E646578 
 209 01f6 3C646F75 		.ascii	"<double, 3, 3>; Eigen::Index = int]\000"
 209      626C652C 
 209      20332C20 
 209      333E3B20 
 209      45696765 
 210 021a 0000     		.align	2
 211              	.LC8:
 212 021c 2E2F4569 		.ascii	"./Eigen/src/Core/PlainObjectBase.h\000"
 212      67656E2F 
 212      7372632F 
 212      436F7265 
 212      2F506C61 
 213              		.section	.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii,"axG",%pro
 214              		.align	1
 215              		.weak	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii
 216              		.syntax unified
 217              		.thumb
 218              		.thumb_func
 220              	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:
 221              		.fnstart
 222              	.LVL10:
 223              	.LFB9421:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 31


 224              		.file 7 "./Eigen/src/Core/PlainObjectBase.h"
   1:./Eigen/src/Core/PlainObjectBase.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/PlainObjectBase.h **** // for linear algebra.
   3:./Eigen/src/Core/PlainObjectBase.h **** //
   4:./Eigen/src/Core/PlainObjectBase.h **** // Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/PlainObjectBase.h **** // Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>
   6:./Eigen/src/Core/PlainObjectBase.h **** //
   7:./Eigen/src/Core/PlainObjectBase.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/PlainObjectBase.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/PlainObjectBase.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/PlainObjectBase.h **** 
  11:./Eigen/src/Core/PlainObjectBase.h **** #ifndef EIGEN_DENSESTORAGEBASE_H
  12:./Eigen/src/Core/PlainObjectBase.h **** #define EIGEN_DENSESTORAGEBASE_H
  13:./Eigen/src/Core/PlainObjectBase.h **** 
  14:./Eigen/src/Core/PlainObjectBase.h **** #if defined(EIGEN_INITIALIZE_MATRICES_BY_ZERO)
  15:./Eigen/src/Core/PlainObjectBase.h **** # define EIGEN_INITIALIZE_COEFFS
  16:./Eigen/src/Core/PlainObjectBase.h **** # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeff
  17:./Eigen/src/Core/PlainObjectBase.h **** #elif defined(EIGEN_INITIALIZE_MATRICES_BY_NAN)
  18:./Eigen/src/Core/PlainObjectBase.h **** # define EIGEN_INITIALIZE_COEFFS
  19:./Eigen/src/Core/PlainObjectBase.h **** # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeff
  20:./Eigen/src/Core/PlainObjectBase.h **** #else
  21:./Eigen/src/Core/PlainObjectBase.h **** # undef EIGEN_INITIALIZE_COEFFS
  22:./Eigen/src/Core/PlainObjectBase.h **** # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
  23:./Eigen/src/Core/PlainObjectBase.h **** #endif
  24:./Eigen/src/Core/PlainObjectBase.h **** 
  25:./Eigen/src/Core/PlainObjectBase.h **** namespace Eigen {
  26:./Eigen/src/Core/PlainObjectBase.h **** 
  27:./Eigen/src/Core/PlainObjectBase.h **** namespace internal {
  28:./Eigen/src/Core/PlainObjectBase.h **** 
  29:./Eigen/src/Core/PlainObjectBase.h **** template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {
  30:./Eigen/src/Core/PlainObjectBase.h ****   template<typename Index>
  31:./Eigen/src/Core/PlainObjectBase.h ****   EIGEN_DEVICE_FUNC
  32:./Eigen/src/Core/PlainObjectBase.h ****   static EIGEN_ALWAYS_INLINE void run(Index, Index)
  33:./Eigen/src/Core/PlainObjectBase.h ****   {
  34:./Eigen/src/Core/PlainObjectBase.h ****   }
  35:./Eigen/src/Core/PlainObjectBase.h **** };
  36:./Eigen/src/Core/PlainObjectBase.h **** 
  37:./Eigen/src/Core/PlainObjectBase.h **** template<> struct check_rows_cols_for_overflow<Dynamic> {
  38:./Eigen/src/Core/PlainObjectBase.h ****   template<typename Index>
  39:./Eigen/src/Core/PlainObjectBase.h ****   EIGEN_DEVICE_FUNC
  40:./Eigen/src/Core/PlainObjectBase.h ****   static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)
  41:./Eigen/src/Core/PlainObjectBase.h ****   {
  42:./Eigen/src/Core/PlainObjectBase.h ****     // http://hg.mozilla.org/mozilla-central/file/6c8a909977d3/xpcom/ds/CheckedInt.h#l242
  43:./Eigen/src/Core/PlainObjectBase.h ****     // we assume Index is signed
  44:./Eigen/src/Core/PlainObjectBase.h ****     Index max_index = (std::size_t(1) << (8 * sizeof(Index) - 1)) - 1; // assume Index is signed
  45:./Eigen/src/Core/PlainObjectBase.h ****     bool error = (rows == 0 || cols == 0) ? false
  46:./Eigen/src/Core/PlainObjectBase.h ****                : (rows > max_index / cols);
  47:./Eigen/src/Core/PlainObjectBase.h ****     if (error)
  48:./Eigen/src/Core/PlainObjectBase.h ****       throw_std_bad_alloc();
  49:./Eigen/src/Core/PlainObjectBase.h ****   }
  50:./Eigen/src/Core/PlainObjectBase.h **** };
  51:./Eigen/src/Core/PlainObjectBase.h **** 
  52:./Eigen/src/Core/PlainObjectBase.h **** template <typename Derived,
  53:./Eigen/src/Core/PlainObjectBase.h ****           typename OtherDerived = Derived,
  54:./Eigen/src/Core/PlainObjectBase.h ****           bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtComp
  55:./Eigen/src/Core/PlainObjectBase.h **** struct conservative_resize_like_impl;
  56:./Eigen/src/Core/PlainObjectBase.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 32


  57:./Eigen/src/Core/PlainObjectBase.h **** template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
  58:./Eigen/src/Core/PlainObjectBase.h **** 
  59:./Eigen/src/Core/PlainObjectBase.h **** } // end namespace internal
  60:./Eigen/src/Core/PlainObjectBase.h **** 
  61:./Eigen/src/Core/PlainObjectBase.h **** #ifdef EIGEN_PARSED_BY_DOXYGEN
  62:./Eigen/src/Core/PlainObjectBase.h **** namespace doxygen {
  63:./Eigen/src/Core/PlainObjectBase.h **** 
  64:./Eigen/src/Core/PlainObjectBase.h **** // This is a workaround to doxygen not being able to understand the inheritance logic
  65:./Eigen/src/Core/PlainObjectBase.h **** // when it is hidden by the dense_xpr_base helper struct.
  66:./Eigen/src/Core/PlainObjectBase.h **** // Moreover, doxygen fails to include members that are not documented in the declaration body of
  67:./Eigen/src/Core/PlainObjectBase.h **** // MatrixBase if we inherits MatrixBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>
  68:./Eigen/src/Core/PlainObjectBase.h **** // this is why we simply inherits MatrixBase, though this does not make sense.
  69:./Eigen/src/Core/PlainObjectBase.h **** 
  70:./Eigen/src/Core/PlainObjectBase.h **** /** This class is just a workaround for Doxygen and it does not not actually exist. */
  71:./Eigen/src/Core/PlainObjectBase.h **** template<typename Derived> struct dense_xpr_base_dispatcher;
  72:./Eigen/src/Core/PlainObjectBase.h **** /** This class is just a workaround for Doxygen and it does not not actually exist. */
  73:./Eigen/src/Core/PlainObjectBase.h **** template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
  74:./Eigen/src/Core/PlainObjectBase.h **** struct dense_xpr_base_dispatcher<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
  75:./Eigen/src/Core/PlainObjectBase.h ****     : public MatrixBase {};
  76:./Eigen/src/Core/PlainObjectBase.h **** /** This class is just a workaround for Doxygen and it does not not actually exist. */
  77:./Eigen/src/Core/PlainObjectBase.h **** template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
  78:./Eigen/src/Core/PlainObjectBase.h **** struct dense_xpr_base_dispatcher<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
  79:./Eigen/src/Core/PlainObjectBase.h ****     : public ArrayBase {};
  80:./Eigen/src/Core/PlainObjectBase.h **** 
  81:./Eigen/src/Core/PlainObjectBase.h **** } // namespace doxygen
  82:./Eigen/src/Core/PlainObjectBase.h **** 
  83:./Eigen/src/Core/PlainObjectBase.h **** /** \class PlainObjectBase
  84:./Eigen/src/Core/PlainObjectBase.h ****   * \ingroup Core_Module
  85:./Eigen/src/Core/PlainObjectBase.h ****   * \brief %Dense storage base class for matrices and arrays.
  86:./Eigen/src/Core/PlainObjectBase.h ****   *
  87:./Eigen/src/Core/PlainObjectBase.h ****   * This class can be extended with the help of the plugin mechanism described on the page
  88:./Eigen/src/Core/PlainObjectBase.h ****   * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_PLAINOBJECTBASE_PLUG
  89:./Eigen/src/Core/PlainObjectBase.h ****   *
  90:./Eigen/src/Core/PlainObjectBase.h ****   * \tparam Derived is the derived type, e.g., a Matrix or Array
  91:./Eigen/src/Core/PlainObjectBase.h ****   *
  92:./Eigen/src/Core/PlainObjectBase.h ****   * \sa \ref TopicClassHierarchy
  93:./Eigen/src/Core/PlainObjectBase.h ****   */
  94:./Eigen/src/Core/PlainObjectBase.h **** template<typename Derived>
  95:./Eigen/src/Core/PlainObjectBase.h **** class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>
  96:./Eigen/src/Core/PlainObjectBase.h **** #else
  97:./Eigen/src/Core/PlainObjectBase.h **** template<typename Derived>
  98:./Eigen/src/Core/PlainObjectBase.h **** class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
  99:./Eigen/src/Core/PlainObjectBase.h **** #endif
 100:./Eigen/src/Core/PlainObjectBase.h **** {
 101:./Eigen/src/Core/PlainObjectBase.h ****   public:
 102:./Eigen/src/Core/PlainObjectBase.h ****     enum { Options = internal::traits<Derived>::Options };
 103:./Eigen/src/Core/PlainObjectBase.h ****     typedef typename internal::dense_xpr_base<Derived>::type Base;
 104:./Eigen/src/Core/PlainObjectBase.h **** 
 105:./Eigen/src/Core/PlainObjectBase.h ****     typedef typename internal::traits<Derived>::StorageKind StorageKind;
 106:./Eigen/src/Core/PlainObjectBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
 107:./Eigen/src/Core/PlainObjectBase.h **** 
 108:./Eigen/src/Core/PlainObjectBase.h ****     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
 109:./Eigen/src/Core/PlainObjectBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 110:./Eigen/src/Core/PlainObjectBase.h ****     typedef Derived DenseType;
 111:./Eigen/src/Core/PlainObjectBase.h **** 
 112:./Eigen/src/Core/PlainObjectBase.h ****     using Base::RowsAtCompileTime;
 113:./Eigen/src/Core/PlainObjectBase.h ****     using Base::ColsAtCompileTime;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 33


 114:./Eigen/src/Core/PlainObjectBase.h ****     using Base::SizeAtCompileTime;
 115:./Eigen/src/Core/PlainObjectBase.h ****     using Base::MaxRowsAtCompileTime;
 116:./Eigen/src/Core/PlainObjectBase.h ****     using Base::MaxColsAtCompileTime;
 117:./Eigen/src/Core/PlainObjectBase.h ****     using Base::MaxSizeAtCompileTime;
 118:./Eigen/src/Core/PlainObjectBase.h ****     using Base::IsVectorAtCompileTime;
 119:./Eigen/src/Core/PlainObjectBase.h ****     using Base::Flags;
 120:./Eigen/src/Core/PlainObjectBase.h **** 
 121:./Eigen/src/Core/PlainObjectBase.h ****     typedef Eigen::Map<Derived, Unaligned>  MapType;
 122:./Eigen/src/Core/PlainObjectBase.h ****     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
 123:./Eigen/src/Core/PlainObjectBase.h ****     typedef Eigen::Map<Derived, AlignedMax> AlignedMapType;
 124:./Eigen/src/Core/PlainObjectBase.h ****     typedef const Eigen::Map<const Derived, AlignedMax> ConstAlignedMapType;
 125:./Eigen/src/Core/PlainObjectBase.h ****     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, St
 126:./Eigen/src/Core/PlainObjectBase.h ****     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Un
 127:./Eigen/src/Core/PlainObjectBase.h ****     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligne
 128:./Eigen/src/Core/PlainObjectBase.h ****     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Deri
 129:./Eigen/src/Core/PlainObjectBase.h **** 
 130:./Eigen/src/Core/PlainObjectBase.h ****   protected:
 131:./Eigen/src/Core/PlainObjectBase.h ****     DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTi
 132:./Eigen/src/Core/PlainObjectBase.h **** 
 133:./Eigen/src/Core/PlainObjectBase.h ****   public:
 134:./Eigen/src/Core/PlainObjectBase.h ****     enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0
 135:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
 136:./Eigen/src/Core/PlainObjectBase.h **** 
 137:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 138:./Eigen/src/Core/PlainObjectBase.h ****     Base& base() { return *static_cast<Base*>(this); }
 139:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 140:./Eigen/src/Core/PlainObjectBase.h ****     const Base& base() const { return *static_cast<const Base*>(this); }
 141:./Eigen/src/Core/PlainObjectBase.h **** 
 142:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
 143:./Eigen/src/Core/PlainObjectBase.h ****     Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }
 144:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
 145:./Eigen/src/Core/PlainObjectBase.h ****     Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }
 146:./Eigen/src/Core/PlainObjectBase.h **** 
 147:./Eigen/src/Core/PlainObjectBase.h ****     /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index,In
 148:./Eigen/src/Core/PlainObjectBase.h ****       * provided to by-pass the creation of an evaluator of the expression, thus saving compilation
 149:./Eigen/src/Core/PlainObjectBase.h ****       *
 150:./Eigen/src/Core/PlainObjectBase.h ****       * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
 151:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 152:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
 153:./Eigen/src/Core/PlainObjectBase.h ****     {
 154:./Eigen/src/Core/PlainObjectBase.h ****       if(Flags & RowMajorBit)
 155:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[colId + rowId * m_storage.cols()];
 156:./Eigen/src/Core/PlainObjectBase.h ****       else // column-major
 157:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[rowId + colId * m_storage.rows()];
 158:./Eigen/src/Core/PlainObjectBase.h ****     }
 159:./Eigen/src/Core/PlainObjectBase.h **** 
 160:./Eigen/src/Core/PlainObjectBase.h ****     /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) c
 161:./Eigen/src/Core/PlainObjectBase.h ****       * provided to by-pass the creation of an evaluator of the expression, thus saving compilation
 162:./Eigen/src/Core/PlainObjectBase.h ****       *
 163:./Eigen/src/Core/PlainObjectBase.h ****       * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
 164:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 165:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
 166:./Eigen/src/Core/PlainObjectBase.h ****     {
 167:./Eigen/src/Core/PlainObjectBase.h ****       return m_storage.data()[index];
 168:./Eigen/src/Core/PlainObjectBase.h ****     }
 169:./Eigen/src/Core/PlainObjectBase.h **** 
 170:./Eigen/src/Core/PlainObjectBase.h ****     /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,In
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 34


 171:./Eigen/src/Core/PlainObjectBase.h ****       * provided to by-pass the creation of an evaluator of the expression, thus saving compilation
 172:./Eigen/src/Core/PlainObjectBase.h ****       *
 173:./Eigen/src/Core/PlainObjectBase.h ****       * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const for details. */
 174:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 175:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
 176:./Eigen/src/Core/PlainObjectBase.h ****     {
 177:./Eigen/src/Core/PlainObjectBase.h ****       if(Flags & RowMajorBit)
 178:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[colId + rowId * m_storage.cols()];
 179:./Eigen/src/Core/PlainObjectBase.h ****       else // column-major
 180:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[rowId + colId * m_storage.rows()];
 181:./Eigen/src/Core/PlainObjectBase.h ****     }
 182:./Eigen/src/Core/PlainObjectBase.h **** 
 183:./Eigen/src/Core/PlainObjectBase.h ****     /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) c
 184:./Eigen/src/Core/PlainObjectBase.h ****       * provided to by-pass the creation of an evaluator of the expression, thus saving compilation
 185:./Eigen/src/Core/PlainObjectBase.h ****       *
 186:./Eigen/src/Core/PlainObjectBase.h ****       * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const for details. */
 187:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 188:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
 189:./Eigen/src/Core/PlainObjectBase.h ****     {
 190:./Eigen/src/Core/PlainObjectBase.h ****       return m_storage.data()[index];
 191:./Eigen/src/Core/PlainObjectBase.h ****     }
 192:./Eigen/src/Core/PlainObjectBase.h **** 
 193:./Eigen/src/Core/PlainObjectBase.h ****     /** This is the const version of coeffRef(Index,Index) which is thus synonym of coeff(Index,Ind
 194:./Eigen/src/Core/PlainObjectBase.h ****       * It is provided for convenience. */
 195:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 196:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
 197:./Eigen/src/Core/PlainObjectBase.h ****     {
 198:./Eigen/src/Core/PlainObjectBase.h ****       if(Flags & RowMajorBit)
 199:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[colId + rowId * m_storage.cols()];
 200:./Eigen/src/Core/PlainObjectBase.h ****       else // column-major
 201:./Eigen/src/Core/PlainObjectBase.h ****         return m_storage.data()[rowId + colId * m_storage.rows()];
 202:./Eigen/src/Core/PlainObjectBase.h ****     }
 203:./Eigen/src/Core/PlainObjectBase.h **** 
 204:./Eigen/src/Core/PlainObjectBase.h ****     /** This is the const version of coeffRef(Index) which is thus synonym of coeff(Index).
 205:./Eigen/src/Core/PlainObjectBase.h ****       * It is provided for convenience. */
 206:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 207:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
 208:./Eigen/src/Core/PlainObjectBase.h ****     {
 209:./Eigen/src/Core/PlainObjectBase.h ****       return m_storage.data()[index];
 210:./Eigen/src/Core/PlainObjectBase.h ****     }
 211:./Eigen/src/Core/PlainObjectBase.h **** 
 212:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal */
 213:./Eigen/src/Core/PlainObjectBase.h ****     template<int LoadMode>
 214:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const
 215:./Eigen/src/Core/PlainObjectBase.h ****     {
 216:./Eigen/src/Core/PlainObjectBase.h ****       return internal::ploadt<PacketScalar, LoadMode>
 217:./Eigen/src/Core/PlainObjectBase.h ****                (m_storage.data() + (Flags & RowMajorBit
 218:./Eigen/src/Core/PlainObjectBase.h ****                                    ? colId + rowId * m_storage.cols()
 219:./Eigen/src/Core/PlainObjectBase.h ****                                    : rowId + colId * m_storage.rows()));
 220:./Eigen/src/Core/PlainObjectBase.h ****     }
 221:./Eigen/src/Core/PlainObjectBase.h **** 
 222:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal */
 223:./Eigen/src/Core/PlainObjectBase.h ****     template<int LoadMode>
 224:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PacketScalar packet(Index index) const
 225:./Eigen/src/Core/PlainObjectBase.h ****     {
 226:./Eigen/src/Core/PlainObjectBase.h ****       return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
 227:./Eigen/src/Core/PlainObjectBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 35


 228:./Eigen/src/Core/PlainObjectBase.h **** 
 229:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal */
 230:./Eigen/src/Core/PlainObjectBase.h ****     template<int StoreMode>
 231:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)
 232:./Eigen/src/Core/PlainObjectBase.h ****     {
 233:./Eigen/src/Core/PlainObjectBase.h ****       internal::pstoret<Scalar, PacketScalar, StoreMode>
 234:./Eigen/src/Core/PlainObjectBase.h ****               (m_storage.data() + (Flags & RowMajorBit
 235:./Eigen/src/Core/PlainObjectBase.h ****                                    ? colId + rowId * m_storage.cols()
 236:./Eigen/src/Core/PlainObjectBase.h ****                                    : rowId + colId * m_storage.rows()), val);
 237:./Eigen/src/Core/PlainObjectBase.h ****     }
 238:./Eigen/src/Core/PlainObjectBase.h **** 
 239:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal */
 240:./Eigen/src/Core/PlainObjectBase.h ****     template<int StoreMode>
 241:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
 242:./Eigen/src/Core/PlainObjectBase.h ****     {
 243:./Eigen/src/Core/PlainObjectBase.h ****       internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
 244:./Eigen/src/Core/PlainObjectBase.h ****     }
 245:./Eigen/src/Core/PlainObjectBase.h **** 
 246:./Eigen/src/Core/PlainObjectBase.h ****     /** \returns a const pointer to the data array of this matrix */
 247:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const
 248:./Eigen/src/Core/PlainObjectBase.h ****     { return m_storage.data(); }
 249:./Eigen/src/Core/PlainObjectBase.h **** 
 250:./Eigen/src/Core/PlainObjectBase.h ****     /** \returns a pointer to the data array of this matrix */
 251:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()
 252:./Eigen/src/Core/PlainObjectBase.h ****     { return m_storage.data(); }
 253:./Eigen/src/Core/PlainObjectBase.h **** 
 254:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes \c *this to a \a rows x \a cols matrix.
 255:./Eigen/src/Core/PlainObjectBase.h ****       *
 256:./Eigen/src/Core/PlainObjectBase.h ****       * This method is intended for dynamic-size matrices, although it is legal to call it on any
 257:./Eigen/src/Core/PlainObjectBase.h ****       * matrix as long as fixed dimensions are left unchanged. If you only want to change the numbe
 258:./Eigen/src/Core/PlainObjectBase.h ****       * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t)
 259:./Eigen/src/Core/PlainObjectBase.h ****       *
 260:./Eigen/src/Core/PlainObjectBase.h ****       * If the current number of coefficients of \c *this exactly matches the
 261:./Eigen/src/Core/PlainObjectBase.h ****       * product \a rows * \a cols, then no memory allocation is performed and
 262:./Eigen/src/Core/PlainObjectBase.h ****       * the current values are left unchanged. In all other cases, including
 263:./Eigen/src/Core/PlainObjectBase.h ****       * shrinking, the data is reallocated and all previous values are lost.
 264:./Eigen/src/Core/PlainObjectBase.h ****       *
 265:./Eigen/src/Core/PlainObjectBase.h ****       * Example: \include Matrix_resize_int_int.cpp
 266:./Eigen/src/Core/PlainObjectBase.h ****       * Output: \verbinclude Matrix_resize_int_int.out
 267:./Eigen/src/Core/PlainObjectBase.h ****       *
 268:./Eigen/src/Core/PlainObjectBase.h ****       * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
 269:./Eigen/src/Core/PlainObjectBase.h ****       */
 270:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 271:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void resize(Index rows, Index cols)
 225              		.loc 7 271 30 is_stmt 1 view -0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 0, uses_anonymous_args = 0
 272:./Eigen/src/Core/PlainObjectBase.h ****     {
 273:./Eigen/src/Core/PlainObjectBase.h ****       eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime)
 229              		.loc 7 273 7 is_stmt 0 view .LVU22
 230 0000 0329     		cmp	r1, #3
 231 0002 06D1     		bne	.L16
 232              		.loc 7 273 7 discriminator 1 view .LVU23
 233 0004 032A     		cmp	r2, #3
 234 0006 04D1     		bne	.L16
 235              		.loc 7 273 7 discriminator 3 view .LVU24
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 36


 236 0008 0029     		cmp	r1, #0
 237 000a 02DB     		blt	.L16
 238              		.loc 7 273 7 discriminator 5 view .LVU25
 239 000c 002A     		cmp	r2, #0
 240 000e 00DB     		blt	.L16
 241 0010 7047     		bx	lr
 242              	.L16:
 271:./Eigen/src/Core/PlainObjectBase.h ****     {
 243              		.loc 7 271 30 discriminator 7 view .LVU26
 244 0012 08B5     		push	{r3, lr}
 245              		.save {r3, lr}
 246              	.LCFI2:
 247              		.cfi_def_cfa_offset 8
 248              		.cfi_offset 3, -8
 249              		.cfi_offset 14, -4
 250              		.loc 7 273 7 discriminator 7 view .LVU27
 251 0014 034B     		ldr	r3, .L20
 252 0016 044A     		ldr	r2, .L20+4
 253              	.LVL11:
 254              		.loc 7 273 7 discriminator 7 view .LVU28
 255 0018 40F21111 		movw	r1, #273
 256              	.LVL12:
 257              		.loc 7 273 7 discriminator 7 view .LVU29
 258 001c 0348     		ldr	r0, .L20+8
 259              	.LVL13:
 260              		.loc 7 273 7 discriminator 7 view .LVU30
 261 001e FFF7FEFF 		bl	__assert_func
 262              	.LVL14:
 263              	.L21:
 264 0022 00BF     		.align	2
 265              	.L20:
 266 0024 00000000 		.word	.LC6
 267 0028 90010000 		.word	.LC7
 268 002c 1C020000 		.word	.LC8
 269              		.cfi_endproc
 270              	.LFE9421:
 271              		.fnend
 273              		.global	__aeabi_dsub
 274              		.global	__aeabi_i2d
 275              		.global	__aeabi_dmul
 276              		.global	__aeabi_ddiv
 277              		.global	__aeabi_dadd
 278              		.section	.text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_,"axG",%progbits,_ZN5E
 279              		.align	1
 280              		.weak	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_
 281              		.syntax unified
 282              		.thumb
 283              		.thumb_func
 285              	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_:
 286              		.fnstart
 287              	.LVL15:
 288              	.LFB9540:
 289              		.file 8 "./Eigen/src/Core/MathFunctions.h"
   1:./Eigen/src/Core/MathFunctions.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/MathFunctions.h **** // for linear algebra.
   3:./Eigen/src/Core/MathFunctions.h **** //
   4:./Eigen/src/Core/MathFunctions.h **** // Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 37


   5:./Eigen/src/Core/MathFunctions.h **** // Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.
   6:./Eigen/src/Core/MathFunctions.h **** //
   7:./Eigen/src/Core/MathFunctions.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/MathFunctions.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/MathFunctions.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/MathFunctions.h **** 
  11:./Eigen/src/Core/MathFunctions.h **** #ifndef EIGEN_MATHFUNCTIONS_H
  12:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_MATHFUNCTIONS_H
  13:./Eigen/src/Core/MathFunctions.h **** 
  14:./Eigen/src/Core/MathFunctions.h **** // TODO this should better be moved to NumTraits
  15:./Eigen/src/Core/MathFunctions.h **** // Source: WolframAlpha
  16:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_PI    3.141592653589793238462643383279502884197169399375105820974944592307816406L
  17:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_LOG2E 1.442695040888963407359924681001892137426645954152985934135449406931109219L
  18:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_LN2   0.693147180559945309417232121458176568075500134360255254120680009493393621L
  19:./Eigen/src/Core/MathFunctions.h **** 
  20:./Eigen/src/Core/MathFunctions.h **** namespace Eigen {
  21:./Eigen/src/Core/MathFunctions.h **** 
  22:./Eigen/src/Core/MathFunctions.h **** // On WINCE, std::abs is defined for int only, so let's defined our own overloads:
  23:./Eigen/src/Core/MathFunctions.h **** // This issue has been confirmed with MSVC 2008 only, but the issue might exist for more recent ver
  24:./Eigen/src/Core/MathFunctions.h **** #if EIGEN_OS_WINCE && EIGEN_COMP_MSVC && EIGEN_COMP_MSVC<=1500
  25:./Eigen/src/Core/MathFunctions.h **** long        abs(long        x) { return (labs(x));  }
  26:./Eigen/src/Core/MathFunctions.h **** double      abs(double      x) { return (fabs(x));  }
  27:./Eigen/src/Core/MathFunctions.h **** float       abs(float       x) { return (fabsf(x)); }
  28:./Eigen/src/Core/MathFunctions.h **** long double abs(long double x) { return (fabsl(x)); }
  29:./Eigen/src/Core/MathFunctions.h **** #endif
  30:./Eigen/src/Core/MathFunctions.h **** 
  31:./Eigen/src/Core/MathFunctions.h **** namespace internal {
  32:./Eigen/src/Core/MathFunctions.h **** 
  33:./Eigen/src/Core/MathFunctions.h **** /** \internal \class global_math_functions_filtering_base
  34:./Eigen/src/Core/MathFunctions.h ****   *
  35:./Eigen/src/Core/MathFunctions.h ****   * What it does:
  36:./Eigen/src/Core/MathFunctions.h ****   * Defines a typedef 'type' as follows:
  37:./Eigen/src/Core/MathFunctions.h ****   * - if type T has a member typedef Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl, then
  38:./Eigen/src/Core/MathFunctions.h ****   *   global_math_functions_filtering_base<T>::type is a typedef for it.
  39:./Eigen/src/Core/MathFunctions.h ****   * - otherwise, global_math_functions_filtering_base<T>::type is a typedef for T.
  40:./Eigen/src/Core/MathFunctions.h ****   *
  41:./Eigen/src/Core/MathFunctions.h ****   * How it's used:
  42:./Eigen/src/Core/MathFunctions.h ****   * To allow to defined the global math functions (like sin...) in certain cases, like the Array ex
  43:./Eigen/src/Core/MathFunctions.h ****   * When you do sin(array1+array2), the object array1+array2 has a complicated expression type, all
  44:./Eigen/src/Core/MathFunctions.h ****   * is that it inherits ArrayBase. So we implement a partial specialization of sin_impl for ArrayBa
  45:./Eigen/src/Core/MathFunctions.h ****   * So we must make sure to use sin_impl<ArrayBase<Derived> > and not sin_impl<Derived>, otherwise 
  46:./Eigen/src/Core/MathFunctions.h ****   * won't be used. How does sin know that? That's exactly what global_math_functions_filtering_base
  47:./Eigen/src/Core/MathFunctions.h ****   *
  48:./Eigen/src/Core/MathFunctions.h ****   * How it's implemented:
  49:./Eigen/src/Core/MathFunctions.h ****   * SFINAE in the style of enable_if. Highly susceptible of breaking compilers. With GCC, it sure d
  50:./Eigen/src/Core/MathFunctions.h ****   * the typename dummy by an integer template parameter, it doesn't work anymore!
  51:./Eigen/src/Core/MathFunctions.h ****   */
  52:./Eigen/src/Core/MathFunctions.h **** 
  53:./Eigen/src/Core/MathFunctions.h **** template<typename T, typename dummy = void>
  54:./Eigen/src/Core/MathFunctions.h **** struct global_math_functions_filtering_base
  55:./Eigen/src/Core/MathFunctions.h **** {
  56:./Eigen/src/Core/MathFunctions.h ****   typedef T type;
  57:./Eigen/src/Core/MathFunctions.h **** };
  58:./Eigen/src/Core/MathFunctions.h **** 
  59:./Eigen/src/Core/MathFunctions.h **** template<typename T> struct always_void { typedef void type; };
  60:./Eigen/src/Core/MathFunctions.h **** 
  61:./Eigen/src/Core/MathFunctions.h **** template<typename T>
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 38


  62:./Eigen/src/Core/MathFunctions.h **** struct global_math_functions_filtering_base
  63:./Eigen/src/Core/MathFunctions.h ****   <T,
  64:./Eigen/src/Core/MathFunctions.h ****    typename always_void<typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl>::type
  65:./Eigen/src/Core/MathFunctions.h ****   >
  66:./Eigen/src/Core/MathFunctions.h **** {
  67:./Eigen/src/Core/MathFunctions.h ****   typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;
  68:./Eigen/src/Core/MathFunctions.h **** };
  69:./Eigen/src/Core/MathFunctions.h **** 
  70:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_MATHFUNC_IMPL(func, scalar) Eigen::internal::func##_impl<typename Eigen::internal::gl
  71:./Eigen/src/Core/MathFunctions.h **** #define EIGEN_MATHFUNC_RETVAL(func, scalar) typename Eigen::internal::func##_retval<typename Eigen:
  72:./Eigen/src/Core/MathFunctions.h **** 
  73:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
  74:./Eigen/src/Core/MathFunctions.h **** * Implementation of real                                                 *
  75:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
  76:./Eigen/src/Core/MathFunctions.h **** 
  77:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
  78:./Eigen/src/Core/MathFunctions.h **** struct real_default_impl
  79:./Eigen/src/Core/MathFunctions.h **** {
  80:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
  81:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
  82:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
  83:./Eigen/src/Core/MathFunctions.h ****   {
  84:./Eigen/src/Core/MathFunctions.h ****     return x;
  85:./Eigen/src/Core/MathFunctions.h ****   }
  86:./Eigen/src/Core/MathFunctions.h **** };
  87:./Eigen/src/Core/MathFunctions.h **** 
  88:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
  89:./Eigen/src/Core/MathFunctions.h **** struct real_default_impl<Scalar,true>
  90:./Eigen/src/Core/MathFunctions.h **** {
  91:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
  92:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
  93:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
  94:./Eigen/src/Core/MathFunctions.h ****   {
  95:./Eigen/src/Core/MathFunctions.h ****     using std::real;
  96:./Eigen/src/Core/MathFunctions.h ****     return real(x);
  97:./Eigen/src/Core/MathFunctions.h ****   }
  98:./Eigen/src/Core/MathFunctions.h **** };
  99:./Eigen/src/Core/MathFunctions.h **** 
 100:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};
 101:./Eigen/src/Core/MathFunctions.h **** 
 102:./Eigen/src/Core/MathFunctions.h **** #if defined(EIGEN_GPU_COMPILE_PHASE)
 103:./Eigen/src/Core/MathFunctions.h **** template<typename T>
 104:./Eigen/src/Core/MathFunctions.h **** struct real_impl<std::complex<T> >
 105:./Eigen/src/Core/MathFunctions.h **** {
 106:./Eigen/src/Core/MathFunctions.h ****   typedef T RealScalar;
 107:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 108:./Eigen/src/Core/MathFunctions.h ****   static inline T run(const std::complex<T>& x)
 109:./Eigen/src/Core/MathFunctions.h ****   {
 110:./Eigen/src/Core/MathFunctions.h ****     return x.real();
 111:./Eigen/src/Core/MathFunctions.h ****   }
 112:./Eigen/src/Core/MathFunctions.h **** };
 113:./Eigen/src/Core/MathFunctions.h **** #endif
 114:./Eigen/src/Core/MathFunctions.h **** 
 115:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 116:./Eigen/src/Core/MathFunctions.h **** struct real_retval
 117:./Eigen/src/Core/MathFunctions.h **** {
 118:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 39


 119:./Eigen/src/Core/MathFunctions.h **** };
 120:./Eigen/src/Core/MathFunctions.h **** 
 121:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 122:./Eigen/src/Core/MathFunctions.h **** * Implementation of imag                                                 *
 123:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 124:./Eigen/src/Core/MathFunctions.h **** 
 125:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
 126:./Eigen/src/Core/MathFunctions.h **** struct imag_default_impl
 127:./Eigen/src/Core/MathFunctions.h **** {
 128:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 129:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 130:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar&)
 131:./Eigen/src/Core/MathFunctions.h ****   {
 132:./Eigen/src/Core/MathFunctions.h ****     return RealScalar(0);
 133:./Eigen/src/Core/MathFunctions.h ****   }
 134:./Eigen/src/Core/MathFunctions.h **** };
 135:./Eigen/src/Core/MathFunctions.h **** 
 136:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 137:./Eigen/src/Core/MathFunctions.h **** struct imag_default_impl<Scalar,true>
 138:./Eigen/src/Core/MathFunctions.h **** {
 139:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 140:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 141:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 142:./Eigen/src/Core/MathFunctions.h ****   {
 143:./Eigen/src/Core/MathFunctions.h ****     using std::imag;
 144:./Eigen/src/Core/MathFunctions.h ****     return imag(x);
 145:./Eigen/src/Core/MathFunctions.h ****   }
 146:./Eigen/src/Core/MathFunctions.h **** };
 147:./Eigen/src/Core/MathFunctions.h **** 
 148:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};
 149:./Eigen/src/Core/MathFunctions.h **** 
 150:./Eigen/src/Core/MathFunctions.h **** #if defined(EIGEN_GPU_COMPILE_PHASE)
 151:./Eigen/src/Core/MathFunctions.h **** template<typename T>
 152:./Eigen/src/Core/MathFunctions.h **** struct imag_impl<std::complex<T> >
 153:./Eigen/src/Core/MathFunctions.h **** {
 154:./Eigen/src/Core/MathFunctions.h ****   typedef T RealScalar;
 155:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 156:./Eigen/src/Core/MathFunctions.h ****   static inline T run(const std::complex<T>& x)
 157:./Eigen/src/Core/MathFunctions.h ****   {
 158:./Eigen/src/Core/MathFunctions.h ****     return x.imag();
 159:./Eigen/src/Core/MathFunctions.h ****   }
 160:./Eigen/src/Core/MathFunctions.h **** };
 161:./Eigen/src/Core/MathFunctions.h **** #endif
 162:./Eigen/src/Core/MathFunctions.h **** 
 163:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 164:./Eigen/src/Core/MathFunctions.h **** struct imag_retval
 165:./Eigen/src/Core/MathFunctions.h **** {
 166:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
 167:./Eigen/src/Core/MathFunctions.h **** };
 168:./Eigen/src/Core/MathFunctions.h **** 
 169:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 170:./Eigen/src/Core/MathFunctions.h **** * Implementation of real_ref                                             *
 171:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 172:./Eigen/src/Core/MathFunctions.h **** 
 173:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 174:./Eigen/src/Core/MathFunctions.h **** struct real_ref_impl
 175:./Eigen/src/Core/MathFunctions.h **** {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 40


 176:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 177:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 178:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar& run(Scalar& x)
 179:./Eigen/src/Core/MathFunctions.h ****   {
 180:./Eigen/src/Core/MathFunctions.h ****     return reinterpret_cast<RealScalar*>(&x)[0];
 181:./Eigen/src/Core/MathFunctions.h ****   }
 182:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 183:./Eigen/src/Core/MathFunctions.h ****   static inline const RealScalar& run(const Scalar& x)
 184:./Eigen/src/Core/MathFunctions.h ****   {
 185:./Eigen/src/Core/MathFunctions.h ****     return reinterpret_cast<const RealScalar*>(&x)[0];
 186:./Eigen/src/Core/MathFunctions.h ****   }
 187:./Eigen/src/Core/MathFunctions.h **** };
 188:./Eigen/src/Core/MathFunctions.h **** 
 189:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 190:./Eigen/src/Core/MathFunctions.h **** struct real_ref_retval
 191:./Eigen/src/Core/MathFunctions.h **** {
 192:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real & type;
 193:./Eigen/src/Core/MathFunctions.h **** };
 194:./Eigen/src/Core/MathFunctions.h **** 
 195:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 196:./Eigen/src/Core/MathFunctions.h **** * Implementation of imag_ref                                             *
 197:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 198:./Eigen/src/Core/MathFunctions.h **** 
 199:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex>
 200:./Eigen/src/Core/MathFunctions.h **** struct imag_ref_default_impl
 201:./Eigen/src/Core/MathFunctions.h **** {
 202:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 203:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 204:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar& run(Scalar& x)
 205:./Eigen/src/Core/MathFunctions.h ****   {
 206:./Eigen/src/Core/MathFunctions.h ****     return reinterpret_cast<RealScalar*>(&x)[1];
 207:./Eigen/src/Core/MathFunctions.h ****   }
 208:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 209:./Eigen/src/Core/MathFunctions.h ****   static inline const RealScalar& run(const Scalar& x)
 210:./Eigen/src/Core/MathFunctions.h ****   {
 211:./Eigen/src/Core/MathFunctions.h ****     return reinterpret_cast<RealScalar*>(&x)[1];
 212:./Eigen/src/Core/MathFunctions.h ****   }
 213:./Eigen/src/Core/MathFunctions.h **** };
 214:./Eigen/src/Core/MathFunctions.h **** 
 215:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 216:./Eigen/src/Core/MathFunctions.h **** struct imag_ref_default_impl<Scalar, false>
 217:./Eigen/src/Core/MathFunctions.h **** {
 218:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 219:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(Scalar&)
 220:./Eigen/src/Core/MathFunctions.h ****   {
 221:./Eigen/src/Core/MathFunctions.h ****     return Scalar(0);
 222:./Eigen/src/Core/MathFunctions.h ****   }
 223:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 224:./Eigen/src/Core/MathFunctions.h ****   static inline const Scalar run(const Scalar&)
 225:./Eigen/src/Core/MathFunctions.h ****   {
 226:./Eigen/src/Core/MathFunctions.h ****     return Scalar(0);
 227:./Eigen/src/Core/MathFunctions.h ****   }
 228:./Eigen/src/Core/MathFunctions.h **** };
 229:./Eigen/src/Core/MathFunctions.h **** 
 230:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 231:./Eigen/src/Core/MathFunctions.h **** struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};
 232:./Eigen/src/Core/MathFunctions.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 41


 233:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 234:./Eigen/src/Core/MathFunctions.h **** struct imag_ref_retval
 235:./Eigen/src/Core/MathFunctions.h **** {
 236:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real & type;
 237:./Eigen/src/Core/MathFunctions.h **** };
 238:./Eigen/src/Core/MathFunctions.h **** 
 239:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 240:./Eigen/src/Core/MathFunctions.h **** * Implementation of conj                                                 *
 241:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 242:./Eigen/src/Core/MathFunctions.h **** 
 243:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
 244:./Eigen/src/Core/MathFunctions.h **** struct conj_default_impl
 245:./Eigen/src/Core/MathFunctions.h **** {
 246:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 247:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 248:./Eigen/src/Core/MathFunctions.h ****   {
 249:./Eigen/src/Core/MathFunctions.h ****     return x;
 250:./Eigen/src/Core/MathFunctions.h ****   }
 251:./Eigen/src/Core/MathFunctions.h **** };
 252:./Eigen/src/Core/MathFunctions.h **** 
 253:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 254:./Eigen/src/Core/MathFunctions.h **** struct conj_default_impl<Scalar,true>
 255:./Eigen/src/Core/MathFunctions.h **** {
 256:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 257:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 258:./Eigen/src/Core/MathFunctions.h ****   {
 259:./Eigen/src/Core/MathFunctions.h ****     using std::conj;
 260:./Eigen/src/Core/MathFunctions.h ****     return conj(x);
 261:./Eigen/src/Core/MathFunctions.h ****   }
 262:./Eigen/src/Core/MathFunctions.h **** };
 263:./Eigen/src/Core/MathFunctions.h **** 
 264:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
 265:./Eigen/src/Core/MathFunctions.h **** struct conj_impl : conj_default_impl<Scalar, IsComplex> {};
 266:./Eigen/src/Core/MathFunctions.h **** 
 267:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 268:./Eigen/src/Core/MathFunctions.h **** struct conj_retval
 269:./Eigen/src/Core/MathFunctions.h **** {
 270:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 271:./Eigen/src/Core/MathFunctions.h **** };
 272:./Eigen/src/Core/MathFunctions.h **** 
 273:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 274:./Eigen/src/Core/MathFunctions.h **** * Implementation of abs2                                                 *
 275:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 276:./Eigen/src/Core/MathFunctions.h **** 
 277:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar,bool IsComplex>
 278:./Eigen/src/Core/MathFunctions.h **** struct abs2_impl_default
 279:./Eigen/src/Core/MathFunctions.h **** {
 280:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 281:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 282:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 283:./Eigen/src/Core/MathFunctions.h ****   {
 284:./Eigen/src/Core/MathFunctions.h ****     return x*x;
 285:./Eigen/src/Core/MathFunctions.h ****   }
 286:./Eigen/src/Core/MathFunctions.h **** };
 287:./Eigen/src/Core/MathFunctions.h **** 
 288:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 289:./Eigen/src/Core/MathFunctions.h **** struct abs2_impl_default<Scalar, true> // IsComplex
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 42


 290:./Eigen/src/Core/MathFunctions.h **** {
 291:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 292:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 293:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 294:./Eigen/src/Core/MathFunctions.h ****   {
 295:./Eigen/src/Core/MathFunctions.h ****     return x.real()*x.real() + x.imag()*x.imag();
 296:./Eigen/src/Core/MathFunctions.h ****   }
 297:./Eigen/src/Core/MathFunctions.h **** };
 298:./Eigen/src/Core/MathFunctions.h **** 
 299:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 300:./Eigen/src/Core/MathFunctions.h **** struct abs2_impl
 301:./Eigen/src/Core/MathFunctions.h **** {
 302:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 303:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 304:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 305:./Eigen/src/Core/MathFunctions.h ****   {
 306:./Eigen/src/Core/MathFunctions.h ****     return abs2_impl_default<Scalar,NumTraits<Scalar>::IsComplex>::run(x);
 307:./Eigen/src/Core/MathFunctions.h ****   }
 308:./Eigen/src/Core/MathFunctions.h **** };
 309:./Eigen/src/Core/MathFunctions.h **** 
 310:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 311:./Eigen/src/Core/MathFunctions.h **** struct abs2_retval
 312:./Eigen/src/Core/MathFunctions.h **** {
 313:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
 314:./Eigen/src/Core/MathFunctions.h **** };
 315:./Eigen/src/Core/MathFunctions.h **** 
 316:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 317:./Eigen/src/Core/MathFunctions.h **** * Implementation of sqrt/rsqrt                                             *
 318:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 319:./Eigen/src/Core/MathFunctions.h **** 
 320:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 321:./Eigen/src/Core/MathFunctions.h **** struct sqrt_impl
 322:./Eigen/src/Core/MathFunctions.h **** {
 323:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 324:./Eigen/src/Core/MathFunctions.h ****   static EIGEN_ALWAYS_INLINE Scalar run(const Scalar& x)
 325:./Eigen/src/Core/MathFunctions.h ****   {
 326:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(sqrt);
 327:./Eigen/src/Core/MathFunctions.h ****     return sqrt(x);
 328:./Eigen/src/Core/MathFunctions.h ****   }
 329:./Eigen/src/Core/MathFunctions.h **** };
 330:./Eigen/src/Core/MathFunctions.h **** 
 331:./Eigen/src/Core/MathFunctions.h **** // Complex sqrt defined in MathFunctionsImpl.h.
 332:./Eigen/src/Core/MathFunctions.h **** template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_sqrt(const std::complex<T>& a_x);
 333:./Eigen/src/Core/MathFunctions.h **** 
 334:./Eigen/src/Core/MathFunctions.h **** // Custom implementation is faster than `std::sqrt`, works on
 335:./Eigen/src/Core/MathFunctions.h **** // GPU, and correctly handles special cases (unlike MSVC).
 336:./Eigen/src/Core/MathFunctions.h **** template<typename T>
 337:./Eigen/src/Core/MathFunctions.h **** struct sqrt_impl<std::complex<T> >
 338:./Eigen/src/Core/MathFunctions.h **** {
 339:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 340:./Eigen/src/Core/MathFunctions.h ****   static EIGEN_ALWAYS_INLINE std::complex<T> run(const std::complex<T>& x)
 341:./Eigen/src/Core/MathFunctions.h ****   {
 342:./Eigen/src/Core/MathFunctions.h ****     return complex_sqrt<T>(x);
 343:./Eigen/src/Core/MathFunctions.h ****   }
 344:./Eigen/src/Core/MathFunctions.h **** };
 345:./Eigen/src/Core/MathFunctions.h **** 
 346:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 43


 347:./Eigen/src/Core/MathFunctions.h **** struct sqrt_retval
 348:./Eigen/src/Core/MathFunctions.h **** {
 349:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 350:./Eigen/src/Core/MathFunctions.h **** };
 351:./Eigen/src/Core/MathFunctions.h **** 
 352:./Eigen/src/Core/MathFunctions.h **** // Default implementation relies on numext::sqrt, at bottom of file.
 353:./Eigen/src/Core/MathFunctions.h **** template<typename T>
 354:./Eigen/src/Core/MathFunctions.h **** struct rsqrt_impl;
 355:./Eigen/src/Core/MathFunctions.h **** 
 356:./Eigen/src/Core/MathFunctions.h **** // Complex rsqrt defined in MathFunctionsImpl.h.
 357:./Eigen/src/Core/MathFunctions.h **** template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_rsqrt(const std::complex<T>& a_x);
 358:./Eigen/src/Core/MathFunctions.h **** 
 359:./Eigen/src/Core/MathFunctions.h **** template<typename T>
 360:./Eigen/src/Core/MathFunctions.h **** struct rsqrt_impl<std::complex<T> >
 361:./Eigen/src/Core/MathFunctions.h **** {
 362:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 363:./Eigen/src/Core/MathFunctions.h ****   static EIGEN_ALWAYS_INLINE std::complex<T> run(const std::complex<T>& x)
 364:./Eigen/src/Core/MathFunctions.h ****   {
 365:./Eigen/src/Core/MathFunctions.h ****     return complex_rsqrt<T>(x);
 366:./Eigen/src/Core/MathFunctions.h ****   }
 367:./Eigen/src/Core/MathFunctions.h **** };
 368:./Eigen/src/Core/MathFunctions.h **** 
 369:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 370:./Eigen/src/Core/MathFunctions.h **** struct rsqrt_retval
 371:./Eigen/src/Core/MathFunctions.h **** {
 372:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 373:./Eigen/src/Core/MathFunctions.h **** };
 374:./Eigen/src/Core/MathFunctions.h **** 
 375:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 376:./Eigen/src/Core/MathFunctions.h **** * Implementation of norm1                                                *
 377:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 378:./Eigen/src/Core/MathFunctions.h **** 
 379:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex>
 380:./Eigen/src/Core/MathFunctions.h **** struct norm1_default_impl;
 381:./Eigen/src/Core/MathFunctions.h **** 
 382:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 383:./Eigen/src/Core/MathFunctions.h **** struct norm1_default_impl<Scalar,true>
 384:./Eigen/src/Core/MathFunctions.h **** {
 385:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 386:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 387:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 388:./Eigen/src/Core/MathFunctions.h ****   {
 389:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(abs);
 390:./Eigen/src/Core/MathFunctions.h ****     return abs(x.real()) + abs(x.imag());
 391:./Eigen/src/Core/MathFunctions.h ****   }
 392:./Eigen/src/Core/MathFunctions.h **** };
 393:./Eigen/src/Core/MathFunctions.h **** 
 394:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 395:./Eigen/src/Core/MathFunctions.h **** struct norm1_default_impl<Scalar, false>
 396:./Eigen/src/Core/MathFunctions.h **** {
 397:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 398:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 399:./Eigen/src/Core/MathFunctions.h ****   {
 400:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(abs);
 401:./Eigen/src/Core/MathFunctions.h ****     return abs(x);
 402:./Eigen/src/Core/MathFunctions.h ****   }
 403:./Eigen/src/Core/MathFunctions.h **** };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 44


 404:./Eigen/src/Core/MathFunctions.h **** 
 405:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 406:./Eigen/src/Core/MathFunctions.h **** struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};
 407:./Eigen/src/Core/MathFunctions.h **** 
 408:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 409:./Eigen/src/Core/MathFunctions.h **** struct norm1_retval
 410:./Eigen/src/Core/MathFunctions.h **** {
 411:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
 412:./Eigen/src/Core/MathFunctions.h **** };
 413:./Eigen/src/Core/MathFunctions.h **** 
 414:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 415:./Eigen/src/Core/MathFunctions.h **** * Implementation of hypot                                                *
 416:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 417:./Eigen/src/Core/MathFunctions.h **** 
 418:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> struct hypot_impl;
 419:./Eigen/src/Core/MathFunctions.h **** 
 420:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 421:./Eigen/src/Core/MathFunctions.h **** struct hypot_retval
 422:./Eigen/src/Core/MathFunctions.h **** {
 423:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
 424:./Eigen/src/Core/MathFunctions.h **** };
 425:./Eigen/src/Core/MathFunctions.h **** 
 426:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 427:./Eigen/src/Core/MathFunctions.h **** * Implementation of cast                                                 *
 428:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 429:./Eigen/src/Core/MathFunctions.h **** 
 430:./Eigen/src/Core/MathFunctions.h **** template<typename OldType, typename NewType, typename EnableIf = void>
 431:./Eigen/src/Core/MathFunctions.h **** struct cast_impl
 432:./Eigen/src/Core/MathFunctions.h **** {
 433:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 434:./Eigen/src/Core/MathFunctions.h ****   static inline NewType run(const OldType& x)
 435:./Eigen/src/Core/MathFunctions.h ****   {
 436:./Eigen/src/Core/MathFunctions.h ****     return static_cast<NewType>(x);
 437:./Eigen/src/Core/MathFunctions.h ****   }
 438:./Eigen/src/Core/MathFunctions.h **** };
 439:./Eigen/src/Core/MathFunctions.h **** 
 440:./Eigen/src/Core/MathFunctions.h **** // Casting from S -> Complex<T> leads to an implicit conversion from S to T,
 441:./Eigen/src/Core/MathFunctions.h **** // generating warnings on clang.  Here we explicitly cast the real component.
 442:./Eigen/src/Core/MathFunctions.h **** template<typename OldType, typename NewType>
 443:./Eigen/src/Core/MathFunctions.h **** struct cast_impl<OldType, NewType,
 444:./Eigen/src/Core/MathFunctions.h ****   typename internal::enable_if<
 445:./Eigen/src/Core/MathFunctions.h ****     !NumTraits<OldType>::IsComplex && NumTraits<NewType>::IsComplex
 446:./Eigen/src/Core/MathFunctions.h ****   >::type>
 447:./Eigen/src/Core/MathFunctions.h **** {
 448:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 449:./Eigen/src/Core/MathFunctions.h ****   static inline NewType run(const OldType& x)
 450:./Eigen/src/Core/MathFunctions.h ****   {
 451:./Eigen/src/Core/MathFunctions.h ****     typedef typename NumTraits<NewType>::Real NewReal;
 452:./Eigen/src/Core/MathFunctions.h ****     return static_cast<NewType>(static_cast<NewReal>(x));
 453:./Eigen/src/Core/MathFunctions.h ****   }
 454:./Eigen/src/Core/MathFunctions.h **** };
 455:./Eigen/src/Core/MathFunctions.h **** 
 456:./Eigen/src/Core/MathFunctions.h **** // here, for once, we're plainly returning NewType: we don't want cast to do weird things.
 457:./Eigen/src/Core/MathFunctions.h **** 
 458:./Eigen/src/Core/MathFunctions.h **** template<typename OldType, typename NewType>
 459:./Eigen/src/Core/MathFunctions.h **** EIGEN_DEVICE_FUNC
 460:./Eigen/src/Core/MathFunctions.h **** inline NewType cast(const OldType& x)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 45


 461:./Eigen/src/Core/MathFunctions.h **** {
 462:./Eigen/src/Core/MathFunctions.h ****   return cast_impl<OldType, NewType>::run(x);
 463:./Eigen/src/Core/MathFunctions.h **** }
 464:./Eigen/src/Core/MathFunctions.h **** 
 465:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 466:./Eigen/src/Core/MathFunctions.h **** * Implementation of round                                                   *
 467:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 468:./Eigen/src/Core/MathFunctions.h **** 
 469:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 470:./Eigen/src/Core/MathFunctions.h **** struct round_impl
 471:./Eigen/src/Core/MathFunctions.h **** {
 472:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 473:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 474:./Eigen/src/Core/MathFunctions.h ****   {
 475:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
 476:./Eigen/src/Core/MathFunctions.h **** #if EIGEN_HAS_CXX11_MATH
 477:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(round);
 478:./Eigen/src/Core/MathFunctions.h **** #endif
 479:./Eigen/src/Core/MathFunctions.h ****     return Scalar(round(x));
 480:./Eigen/src/Core/MathFunctions.h ****   }
 481:./Eigen/src/Core/MathFunctions.h **** };
 482:./Eigen/src/Core/MathFunctions.h **** 
 483:./Eigen/src/Core/MathFunctions.h **** #if !EIGEN_HAS_CXX11_MATH
 484:./Eigen/src/Core/MathFunctions.h **** #if EIGEN_HAS_C99_MATH
 485:./Eigen/src/Core/MathFunctions.h **** // Use ::roundf for float.
 486:./Eigen/src/Core/MathFunctions.h **** template<>
 487:./Eigen/src/Core/MathFunctions.h **** struct round_impl<float> {
 488:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 489:./Eigen/src/Core/MathFunctions.h ****   static inline float run(const float& x)
 490:./Eigen/src/Core/MathFunctions.h ****   {
 491:./Eigen/src/Core/MathFunctions.h ****     return ::roundf(x);
 492:./Eigen/src/Core/MathFunctions.h ****   }
 493:./Eigen/src/Core/MathFunctions.h **** };
 494:./Eigen/src/Core/MathFunctions.h **** #else
 495:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 496:./Eigen/src/Core/MathFunctions.h **** struct round_using_floor_ceil_impl
 497:./Eigen/src/Core/MathFunctions.h **** {
 498:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 499:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 500:./Eigen/src/Core/MathFunctions.h ****   {
 501:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
 502:./Eigen/src/Core/MathFunctions.h ****     // Without C99 round/roundf, resort to floor/ceil.
 503:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(floor);
 504:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(ceil);
 505:./Eigen/src/Core/MathFunctions.h ****     // If not enough precision to resolve a decimal at all, return the input.
 506:./Eigen/src/Core/MathFunctions.h ****     // Otherwise, adding 0.5 can trigger an increment by 1.
 507:./Eigen/src/Core/MathFunctions.h ****     const Scalar limit = Scalar(1ull << (NumTraits<Scalar>::digits() - 1));
 508:./Eigen/src/Core/MathFunctions.h ****     if (x >= limit || x <= -limit) {
 509:./Eigen/src/Core/MathFunctions.h ****       return x;
 510:./Eigen/src/Core/MathFunctions.h ****     }
 511:./Eigen/src/Core/MathFunctions.h ****     return (x > Scalar(0)) ? Scalar(floor(x + Scalar(0.5))) : Scalar(ceil(x - Scalar(0.5)));
 512:./Eigen/src/Core/MathFunctions.h ****   }
 513:./Eigen/src/Core/MathFunctions.h **** };
 514:./Eigen/src/Core/MathFunctions.h **** 
 515:./Eigen/src/Core/MathFunctions.h **** template<>
 516:./Eigen/src/Core/MathFunctions.h **** struct round_impl<float> : round_using_floor_ceil_impl<float> {};
 517:./Eigen/src/Core/MathFunctions.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 46


 518:./Eigen/src/Core/MathFunctions.h **** template<>
 519:./Eigen/src/Core/MathFunctions.h **** struct round_impl<double> : round_using_floor_ceil_impl<double> {};
 520:./Eigen/src/Core/MathFunctions.h **** #endif // EIGEN_HAS_C99_MATH
 521:./Eigen/src/Core/MathFunctions.h **** #endif // !EIGEN_HAS_CXX11_MATH
 522:./Eigen/src/Core/MathFunctions.h **** 
 523:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 524:./Eigen/src/Core/MathFunctions.h **** struct round_retval
 525:./Eigen/src/Core/MathFunctions.h **** {
 526:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 527:./Eigen/src/Core/MathFunctions.h **** };
 528:./Eigen/src/Core/MathFunctions.h **** 
 529:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 530:./Eigen/src/Core/MathFunctions.h **** * Implementation of rint                                                    *
 531:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 532:./Eigen/src/Core/MathFunctions.h **** 
 533:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 534:./Eigen/src/Core/MathFunctions.h **** struct rint_impl {
 535:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 536:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x)
 537:./Eigen/src/Core/MathFunctions.h ****   {
 538:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
 539:./Eigen/src/Core/MathFunctions.h **** #if EIGEN_HAS_CXX11_MATH
 540:./Eigen/src/Core/MathFunctions.h ****       EIGEN_USING_STD(rint);
 541:./Eigen/src/Core/MathFunctions.h **** #endif
 542:./Eigen/src/Core/MathFunctions.h ****     return rint(x);
 543:./Eigen/src/Core/MathFunctions.h ****   }
 544:./Eigen/src/Core/MathFunctions.h **** };
 545:./Eigen/src/Core/MathFunctions.h **** 
 546:./Eigen/src/Core/MathFunctions.h **** #if !EIGEN_HAS_CXX11_MATH
 547:./Eigen/src/Core/MathFunctions.h **** template<>
 548:./Eigen/src/Core/MathFunctions.h **** struct rint_impl<double> {
 549:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 550:./Eigen/src/Core/MathFunctions.h ****   static inline double run(const double& x)
 551:./Eigen/src/Core/MathFunctions.h ****   {
 552:./Eigen/src/Core/MathFunctions.h ****     return ::rint(x);
 553:./Eigen/src/Core/MathFunctions.h ****   }
 554:./Eigen/src/Core/MathFunctions.h **** };
 555:./Eigen/src/Core/MathFunctions.h **** template<>
 556:./Eigen/src/Core/MathFunctions.h **** struct rint_impl<float> {
 557:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 558:./Eigen/src/Core/MathFunctions.h ****   static inline float run(const float& x)
 559:./Eigen/src/Core/MathFunctions.h ****   {
 560:./Eigen/src/Core/MathFunctions.h ****     return ::rintf(x);
 561:./Eigen/src/Core/MathFunctions.h ****   }
 562:./Eigen/src/Core/MathFunctions.h **** };
 563:./Eigen/src/Core/MathFunctions.h **** #endif
 564:./Eigen/src/Core/MathFunctions.h **** 
 565:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 566:./Eigen/src/Core/MathFunctions.h **** struct rint_retval
 567:./Eigen/src/Core/MathFunctions.h **** {
 568:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 569:./Eigen/src/Core/MathFunctions.h **** };
 570:./Eigen/src/Core/MathFunctions.h **** 
 571:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 572:./Eigen/src/Core/MathFunctions.h **** * Implementation of arg                                                     *
 573:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 574:./Eigen/src/Core/MathFunctions.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 47


 575:./Eigen/src/Core/MathFunctions.h **** // Visual Studio 2017 has a bug where arg(float) returns 0 for negative inputs.
 576:./Eigen/src/Core/MathFunctions.h **** // This seems to be fixed in VS 2019.
 577:./Eigen/src/Core/MathFunctions.h **** #if EIGEN_HAS_CXX11_MATH && (!EIGEN_COMP_MSVC || EIGEN_COMP_MSVC >= 1920)
 578:./Eigen/src/Core/MathFunctions.h **** // std::arg is only defined for types of std::complex, or integer types or float/double/long double
 579:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar,
 580:./Eigen/src/Core/MathFunctions.h ****           bool HasStdImpl = NumTraits<Scalar>::IsComplex || is_integral<Scalar>::value
 581:./Eigen/src/Core/MathFunctions.h ****                             || is_same<Scalar, float>::value || is_same<Scalar, double>::value
 582:./Eigen/src/Core/MathFunctions.h ****                             || is_same<Scalar, long double>::value >
 583:./Eigen/src/Core/MathFunctions.h **** struct arg_default_impl;
 584:./Eigen/src/Core/MathFunctions.h **** 
 585:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 586:./Eigen/src/Core/MathFunctions.h **** struct arg_default_impl<Scalar, true> {
 587:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 588:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 589:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 590:./Eigen/src/Core/MathFunctions.h ****   {
 591:./Eigen/src/Core/MathFunctions.h ****     #if defined(EIGEN_HIP_DEVICE_COMPILE)
 592:./Eigen/src/Core/MathFunctions.h ****     // HIP does not seem to have a native device side implementation for the math routine "arg"
 593:./Eigen/src/Core/MathFunctions.h ****     using std::arg;
 594:./Eigen/src/Core/MathFunctions.h ****     #else
 595:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(arg);
 596:./Eigen/src/Core/MathFunctions.h ****     #endif
 597:./Eigen/src/Core/MathFunctions.h ****     return static_cast<RealScalar>(arg(x));
 598:./Eigen/src/Core/MathFunctions.h ****   }
 599:./Eigen/src/Core/MathFunctions.h **** };
 600:./Eigen/src/Core/MathFunctions.h **** 
 601:./Eigen/src/Core/MathFunctions.h **** // Must be non-complex floating-point type (e.g. half/bfloat16).
 602:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 603:./Eigen/src/Core/MathFunctions.h **** struct arg_default_impl<Scalar, false> {
 604:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 605:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 606:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 607:./Eigen/src/Core/MathFunctions.h ****   {
 608:./Eigen/src/Core/MathFunctions.h ****     return (x < Scalar(0)) ? RealScalar(EIGEN_PI) : RealScalar(0);
 609:./Eigen/src/Core/MathFunctions.h ****   }
 610:./Eigen/src/Core/MathFunctions.h **** };
 611:./Eigen/src/Core/MathFunctions.h **** #else
 612:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
 613:./Eigen/src/Core/MathFunctions.h **** struct arg_default_impl
 614:./Eigen/src/Core/MathFunctions.h **** {
 615:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 616:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 617:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 618:./Eigen/src/Core/MathFunctions.h ****   {
 619:./Eigen/src/Core/MathFunctions.h ****     return (x < RealScalar(0)) ? RealScalar(EIGEN_PI) : RealScalar(0);
 620:./Eigen/src/Core/MathFunctions.h ****   }
 621:./Eigen/src/Core/MathFunctions.h **** };
 622:./Eigen/src/Core/MathFunctions.h **** 
 623:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 624:./Eigen/src/Core/MathFunctions.h **** struct arg_default_impl<Scalar,true>
 625:./Eigen/src/Core/MathFunctions.h **** {
 626:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real RealScalar;
 627:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC
 628:./Eigen/src/Core/MathFunctions.h ****   static inline RealScalar run(const Scalar& x)
 629:./Eigen/src/Core/MathFunctions.h ****   {
 630:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(arg);
 631:./Eigen/src/Core/MathFunctions.h ****     return arg(x);
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 48


 632:./Eigen/src/Core/MathFunctions.h ****   }
 633:./Eigen/src/Core/MathFunctions.h **** };
 634:./Eigen/src/Core/MathFunctions.h **** #endif
 635:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};
 636:./Eigen/src/Core/MathFunctions.h **** 
 637:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 638:./Eigen/src/Core/MathFunctions.h **** struct arg_retval
 639:./Eigen/src/Core/MathFunctions.h **** {
 640:./Eigen/src/Core/MathFunctions.h ****   typedef typename NumTraits<Scalar>::Real type;
 641:./Eigen/src/Core/MathFunctions.h **** };
 642:./Eigen/src/Core/MathFunctions.h **** 
 643:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 644:./Eigen/src/Core/MathFunctions.h **** * Implementation of expm1                                                   *
 645:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 646:./Eigen/src/Core/MathFunctions.h **** 
 647:./Eigen/src/Core/MathFunctions.h **** // This implementation is based on GSL Math's expm1.
 648:./Eigen/src/Core/MathFunctions.h **** namespace std_fallback {
 649:./Eigen/src/Core/MathFunctions.h ****   // fallback expm1 implementation in case there is no expm1(Scalar) function in namespace of Scala
 650:./Eigen/src/Core/MathFunctions.h ****   // or that there is no suitable std::expm1 function available. Implementation
 651:./Eigen/src/Core/MathFunctions.h ****   // attributed to Kahan. See: http://www.plunk.org/~hatch/rightway.php.
 652:./Eigen/src/Core/MathFunctions.h ****   template<typename Scalar>
 653:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC inline Scalar expm1(const Scalar& x) {
 654:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
 655:./Eigen/src/Core/MathFunctions.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 656:./Eigen/src/Core/MathFunctions.h **** 
 657:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(exp);
 658:./Eigen/src/Core/MathFunctions.h ****     Scalar u = exp(x);
 659:./Eigen/src/Core/MathFunctions.h ****     if (numext::equal_strict(u, Scalar(1))) {
 660:./Eigen/src/Core/MathFunctions.h ****       return x;
 661:./Eigen/src/Core/MathFunctions.h ****     }
 662:./Eigen/src/Core/MathFunctions.h ****     Scalar um1 = u - RealScalar(1);
 663:./Eigen/src/Core/MathFunctions.h ****     if (numext::equal_strict(um1, Scalar(-1))) {
 664:./Eigen/src/Core/MathFunctions.h ****       return RealScalar(-1);
 665:./Eigen/src/Core/MathFunctions.h ****     }
 666:./Eigen/src/Core/MathFunctions.h **** 
 667:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(log);
 668:./Eigen/src/Core/MathFunctions.h ****     Scalar logu = log(u);
 669:./Eigen/src/Core/MathFunctions.h ****     return numext::equal_strict(u, logu) ? u : (u - RealScalar(1)) * x / logu;
 670:./Eigen/src/Core/MathFunctions.h ****   }
 671:./Eigen/src/Core/MathFunctions.h **** }
 672:./Eigen/src/Core/MathFunctions.h **** 
 673:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 674:./Eigen/src/Core/MathFunctions.h **** struct expm1_impl {
 675:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
 676:./Eigen/src/Core/MathFunctions.h ****   {
 677:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
 678:./Eigen/src/Core/MathFunctions.h ****     #if EIGEN_HAS_CXX11_MATH
 679:./Eigen/src/Core/MathFunctions.h ****     using std::expm1;
 680:./Eigen/src/Core/MathFunctions.h ****     #else
 681:./Eigen/src/Core/MathFunctions.h ****     using std_fallback::expm1;
 682:./Eigen/src/Core/MathFunctions.h ****     #endif
 683:./Eigen/src/Core/MathFunctions.h ****     return expm1(x);
 684:./Eigen/src/Core/MathFunctions.h ****   }
 685:./Eigen/src/Core/MathFunctions.h **** };
 686:./Eigen/src/Core/MathFunctions.h **** 
 687:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 688:./Eigen/src/Core/MathFunctions.h **** struct expm1_retval
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 49


 689:./Eigen/src/Core/MathFunctions.h **** {
 690:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 691:./Eigen/src/Core/MathFunctions.h **** };
 692:./Eigen/src/Core/MathFunctions.h **** 
 693:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 694:./Eigen/src/Core/MathFunctions.h **** * Implementation of log                                                     *
 695:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 696:./Eigen/src/Core/MathFunctions.h **** 
 697:./Eigen/src/Core/MathFunctions.h **** // Complex log defined in MathFunctionsImpl.h.
 698:./Eigen/src/Core/MathFunctions.h **** template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_log(const std::complex<T>& z);
 699:./Eigen/src/Core/MathFunctions.h **** 
 700:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 701:./Eigen/src/Core/MathFunctions.h **** struct log_impl {
 702:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
 703:./Eigen/src/Core/MathFunctions.h ****   {
 704:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(log);
 705:./Eigen/src/Core/MathFunctions.h ****     return static_cast<Scalar>(log(x));
 706:./Eigen/src/Core/MathFunctions.h ****   }
 707:./Eigen/src/Core/MathFunctions.h **** };
 708:./Eigen/src/Core/MathFunctions.h **** 
 709:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 710:./Eigen/src/Core/MathFunctions.h **** struct log_impl<std::complex<Scalar> > {
 711:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC static inline std::complex<Scalar> run(const std::complex<Scalar>& z)
 712:./Eigen/src/Core/MathFunctions.h ****   {
 713:./Eigen/src/Core/MathFunctions.h ****     return complex_log(z);
 714:./Eigen/src/Core/MathFunctions.h ****   }
 715:./Eigen/src/Core/MathFunctions.h **** };
 716:./Eigen/src/Core/MathFunctions.h **** 
 717:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 718:./Eigen/src/Core/MathFunctions.h **** * Implementation of log1p                                                   *
 719:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 720:./Eigen/src/Core/MathFunctions.h **** 
 721:./Eigen/src/Core/MathFunctions.h **** namespace std_fallback {
 722:./Eigen/src/Core/MathFunctions.h ****   // fallback log1p implementation in case there is no log1p(Scalar) function in namespace of Scala
 723:./Eigen/src/Core/MathFunctions.h ****   // or that there is no suitable std::log1p function available
 724:./Eigen/src/Core/MathFunctions.h ****   template<typename Scalar>
 725:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC inline Scalar log1p(const Scalar& x) {
 726:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
 727:./Eigen/src/Core/MathFunctions.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 728:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(log);
 729:./Eigen/src/Core/MathFunctions.h ****     Scalar x1p = RealScalar(1) + x;
 730:./Eigen/src/Core/MathFunctions.h ****     Scalar log_1p = log_impl<Scalar>::run(x1p);
 731:./Eigen/src/Core/MathFunctions.h ****     const bool is_small = numext::equal_strict(x1p, Scalar(1));
 732:./Eigen/src/Core/MathFunctions.h ****     const bool is_inf = numext::equal_strict(x1p, log_1p);
 733:./Eigen/src/Core/MathFunctions.h ****     return (is_small || is_inf) ? x : x * (log_1p / (x1p - RealScalar(1)));
 734:./Eigen/src/Core/MathFunctions.h ****   }
 735:./Eigen/src/Core/MathFunctions.h **** }
 736:./Eigen/src/Core/MathFunctions.h **** 
 737:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 738:./Eigen/src/Core/MathFunctions.h **** struct log1p_impl {
 739:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
 740:./Eigen/src/Core/MathFunctions.h ****   {
 741:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
 742:./Eigen/src/Core/MathFunctions.h ****     #if EIGEN_HAS_CXX11_MATH
 743:./Eigen/src/Core/MathFunctions.h ****     using std::log1p;
 744:./Eigen/src/Core/MathFunctions.h ****     #else
 745:./Eigen/src/Core/MathFunctions.h ****     using std_fallback::log1p;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 50


 746:./Eigen/src/Core/MathFunctions.h ****     #endif
 747:./Eigen/src/Core/MathFunctions.h ****     return log1p(x);
 748:./Eigen/src/Core/MathFunctions.h ****   }
 749:./Eigen/src/Core/MathFunctions.h **** };
 750:./Eigen/src/Core/MathFunctions.h **** 
 751:./Eigen/src/Core/MathFunctions.h **** // Specialization for complex types that are not supported by std::log1p.
 752:./Eigen/src/Core/MathFunctions.h **** template <typename RealScalar>
 753:./Eigen/src/Core/MathFunctions.h **** struct log1p_impl<std::complex<RealScalar> > {
 754:./Eigen/src/Core/MathFunctions.h ****   EIGEN_DEVICE_FUNC static inline std::complex<RealScalar> run(
 755:./Eigen/src/Core/MathFunctions.h ****       const std::complex<RealScalar>& x) {
 756:./Eigen/src/Core/MathFunctions.h ****     EIGEN_STATIC_ASSERT_NON_INTEGER(RealScalar)
 757:./Eigen/src/Core/MathFunctions.h ****     return std_fallback::log1p(x);
 758:./Eigen/src/Core/MathFunctions.h ****   }
 759:./Eigen/src/Core/MathFunctions.h **** };
 760:./Eigen/src/Core/MathFunctions.h **** 
 761:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 762:./Eigen/src/Core/MathFunctions.h **** struct log1p_retval
 763:./Eigen/src/Core/MathFunctions.h **** {
 764:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 765:./Eigen/src/Core/MathFunctions.h **** };
 766:./Eigen/src/Core/MathFunctions.h **** 
 767:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 768:./Eigen/src/Core/MathFunctions.h **** * Implementation of pow                                                  *
 769:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 770:./Eigen/src/Core/MathFunctions.h **** 
 771:./Eigen/src/Core/MathFunctions.h **** template<typename ScalarX,typename ScalarY, bool IsInteger = NumTraits<ScalarX>::IsInteger&&NumTrai
 772:./Eigen/src/Core/MathFunctions.h **** struct pow_impl
 773:./Eigen/src/Core/MathFunctions.h **** {
 774:./Eigen/src/Core/MathFunctions.h ****   //typedef Scalar retval;
 775:./Eigen/src/Core/MathFunctions.h ****   typedef typename ScalarBinaryOpTraits<ScalarX,ScalarY,internal::scalar_pow_op<ScalarX,ScalarY> >:
 776:./Eigen/src/Core/MathFunctions.h ****   static EIGEN_DEVICE_FUNC inline result_type run(const ScalarX& x, const ScalarY& y)
 777:./Eigen/src/Core/MathFunctions.h ****   {
 778:./Eigen/src/Core/MathFunctions.h ****     EIGEN_USING_STD(pow);
 779:./Eigen/src/Core/MathFunctions.h ****     return pow(x, y);
 780:./Eigen/src/Core/MathFunctions.h ****   }
 781:./Eigen/src/Core/MathFunctions.h **** };
 782:./Eigen/src/Core/MathFunctions.h **** 
 783:./Eigen/src/Core/MathFunctions.h **** template<typename ScalarX,typename ScalarY>
 784:./Eigen/src/Core/MathFunctions.h **** struct pow_impl<ScalarX,ScalarY, true>
 785:./Eigen/src/Core/MathFunctions.h **** {
 786:./Eigen/src/Core/MathFunctions.h ****   typedef ScalarX result_type;
 787:./Eigen/src/Core/MathFunctions.h ****   static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)
 788:./Eigen/src/Core/MathFunctions.h ****   {
 789:./Eigen/src/Core/MathFunctions.h ****     ScalarX res(1);
 790:./Eigen/src/Core/MathFunctions.h ****     eigen_assert(!NumTraits<ScalarY>::IsSigned || y >= 0);
 791:./Eigen/src/Core/MathFunctions.h ****     if(y & 1) res *= x;
 792:./Eigen/src/Core/MathFunctions.h ****     y >>= 1;
 793:./Eigen/src/Core/MathFunctions.h ****     while(y)
 794:./Eigen/src/Core/MathFunctions.h ****     {
 795:./Eigen/src/Core/MathFunctions.h ****       x *= x;
 796:./Eigen/src/Core/MathFunctions.h ****       if(y&1) res *= x;
 797:./Eigen/src/Core/MathFunctions.h ****       y >>= 1;
 798:./Eigen/src/Core/MathFunctions.h ****     }
 799:./Eigen/src/Core/MathFunctions.h ****     return res;
 800:./Eigen/src/Core/MathFunctions.h ****   }
 801:./Eigen/src/Core/MathFunctions.h **** };
 802:./Eigen/src/Core/MathFunctions.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 51


 803:./Eigen/src/Core/MathFunctions.h **** /****************************************************************************
 804:./Eigen/src/Core/MathFunctions.h **** * Implementation of random                                               *
 805:./Eigen/src/Core/MathFunctions.h **** ****************************************************************************/
 806:./Eigen/src/Core/MathFunctions.h **** 
 807:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar,
 808:./Eigen/src/Core/MathFunctions.h ****          bool IsComplex,
 809:./Eigen/src/Core/MathFunctions.h ****          bool IsInteger>
 810:./Eigen/src/Core/MathFunctions.h **** struct random_default_impl {};
 811:./Eigen/src/Core/MathFunctions.h **** 
 812:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 813:./Eigen/src/Core/MathFunctions.h **** struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::I
 814:./Eigen/src/Core/MathFunctions.h **** 
 815:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 816:./Eigen/src/Core/MathFunctions.h **** struct random_retval
 817:./Eigen/src/Core/MathFunctions.h **** {
 818:./Eigen/src/Core/MathFunctions.h ****   typedef Scalar type;
 819:./Eigen/src/Core/MathFunctions.h **** };
 820:./Eigen/src/Core/MathFunctions.h **** 
 821:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, cons
 822:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();
 823:./Eigen/src/Core/MathFunctions.h **** 
 824:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 825:./Eigen/src/Core/MathFunctions.h **** struct random_default_impl<Scalar, false, false>
 826:./Eigen/src/Core/MathFunctions.h **** {
 827:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x, const Scalar& y)
 290              		.loc 8 827 24 is_stmt 1 view -0
 291              		.cfi_startproc
 292              		@ args = 0, pretend = 0, frame = 0
 293              		@ frame_needed = 0, uses_anonymous_args = 0
 294              		.loc 8 827 24 is_stmt 0 view .LVU32
 295 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 296              	.LCFI3:
 297              		.cfi_def_cfa_offset 24
 298              		.cfi_offset 3, -24
 299              		.cfi_offset 4, -20
 300              		.cfi_offset 5, -16
 301              		.cfi_offset 6, -12
 302              		.cfi_offset 7, -8
 303              		.cfi_offset 14, -4
 828:./Eigen/src/Core/MathFunctions.h ****   {
 829:./Eigen/src/Core/MathFunctions.h ****     return x + (y-x) * Scalar(std::rand()) / Scalar(RAND_MAX);
 304              		.loc 8 829 14 view .LVU33
 305 0002 D0E90067 		ldrd	r6, [r0]
 306              		.loc 8 829 18 view .LVU34
 307 0006 3246     		mov	r2, r6
 308 0008 3B46     		mov	r3, r7
 309 000a D1E90001 		ldrd	r0, [r1]
 310              	.LVL16:
 311              		.loc 8 829 18 view .LVU35
 312 000e FFF7FEFF 		bl	__aeabi_dsub
 313              	.LVL17:
 314              		.loc 8 829 18 view .LVU36
 315 0012 0446     		mov	r4, r0
 316 0014 0D46     		mov	r5, r1
 317              		.loc 8 829 40 view .LVU37
 318 0016 FFF7FEFF 		bl	rand
 319              	.LVL18:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 52


 320              		.loc 8 829 24 view .LVU38
 321 001a FFF7FEFF 		bl	__aeabi_i2d
 322              	.LVL19:
 323 001e 0246     		mov	r2, r0
 324 0020 0B46     		mov	r3, r1
 325              		.loc 8 829 22 view .LVU39
 326 0022 2046     		mov	r0, r4
 327 0024 2946     		mov	r1, r5
 328 0026 FFF7FEFF 		bl	__aeabi_dmul
 329              	.LVL20:
 330              		.loc 8 829 44 view .LVU40
 331 002a 07A3     		adr	r3, .L24
 332 002c D3E90023 		ldrd	r2, [r3]
 333 0030 FFF7FEFF 		bl	__aeabi_ddiv
 334              	.LVL21:
 335 0034 0246     		mov	r2, r0
 336 0036 0B46     		mov	r3, r1
 337              		.loc 8 829 61 view .LVU41
 338 0038 3046     		mov	r0, r6
 339 003a 3946     		mov	r1, r7
 340 003c FFF7FEFF 		bl	__aeabi_dadd
 341              	.LVL22:
 830:./Eigen/src/Core/MathFunctions.h ****   }
 342              		.loc 8 830 3 view .LVU42
 343 0040 41EC100B 		vmov	d0, r0, r1
 344 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 345              	.L25:
 346 0046 00BF     		.align	3
 347              	.L24:
 348 0048 0000C0FF 		.word	-4194304
 349 004c FFFFDF41 		.word	1105199103
 350              		.cfi_endproc
 351              	.LFE9540:
 352              		.cantunwind
 353              		.fnend
 355              		.section	.text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv,"axG",%progbits,_ZN5Eigen8
 356              		.align	1
 357              		.weak	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv
 358              		.syntax unified
 359              		.thumb
 360              		.thumb_func
 362              	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv:
 363              		.fnstart
 364              	.LFB9538:
 831:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run()
 365              		.loc 8 831 24 is_stmt 1 view -0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 16
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369 0000 00B5     		push	{lr}
 370              	.LCFI4:
 371              		.cfi_def_cfa_offset 4
 372              		.cfi_offset 14, -4
 373 0002 85B0     		sub	sp, sp, #20
 374              	.LCFI5:
 375              		.cfi_def_cfa_offset 24
 832:./Eigen/src/Core/MathFunctions.h ****   {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 53


 833:./Eigen/src/Core/MathFunctions.h ****     return run(Scalar(NumTraits<Scalar>::IsSigned ? -1 : 0), Scalar(1));
 376              		.loc 8 833 16 is_stmt 0 view .LVU44
 377 0004 0022     		movs	r2, #0
 378 0006 074B     		ldr	r3, .L28
 379 0008 CDE90023 		strd	r2, [sp]
 380              		.loc 8 833 62 view .LVU45
 381 000c 0022     		movs	r2, #0
 382 000e 064B     		ldr	r3, .L28+4
 383 0010 CDE90223 		strd	r2, [sp, #8]
 384              		.loc 8 833 15 view .LVU46
 385 0014 02A9     		add	r1, sp, #8
 386 0016 6846     		mov	r0, sp
 387 0018 FFF7FEFF 		bl	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_
 388              	.LVL23:
 834:./Eigen/src/Core/MathFunctions.h ****   }
 389              		.loc 8 834 3 view .LVU47
 390 001c 05B0     		add	sp, sp, #20
 391              	.LCFI6:
 392              		.cfi_def_cfa_offset 4
 393              		@ sp needed
 394 001e 5DF804FB 		ldr	pc, [sp], #4
 395              	.L29:
 396 0022 00BF     		.align	2
 397              	.L28:
 398 0024 0000F0BF 		.word	-1074790400
 399 0028 0000F03F 		.word	1072693248
 400              		.cfi_endproc
 401              	.LFE9538:
 402              		.cantunwind
 403              		.fnend
 405              		.section	.text._ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3E
 406              		.align	1
 407              		.weak	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0EL
 408              		.syntax unified
 409              		.thumb
 410              		.thumb_func
 412              	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3E
 413              		.fnstart
 414              	.LVL24:
 415              	.LFB9519:
 416              		.file 9 "./Eigen/src/Core/AssignEvaluator.h"
   1:./Eigen/src/Core/AssignEvaluator.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/AssignEvaluator.h **** // for linear algebra.
   3:./Eigen/src/Core/AssignEvaluator.h **** //
   4:./Eigen/src/Core/AssignEvaluator.h **** // Copyright (C) 2011 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/AssignEvaluator.h **** // Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/AssignEvaluator.h **** // Copyright (C) 2011-2012 Jitse Niesen <jitse@maths.leeds.ac.uk>
   7:./Eigen/src/Core/AssignEvaluator.h **** //
   8:./Eigen/src/Core/AssignEvaluator.h **** // This Source Code Form is subject to the terms of the Mozilla
   9:./Eigen/src/Core/AssignEvaluator.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
  10:./Eigen/src/Core/AssignEvaluator.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  11:./Eigen/src/Core/AssignEvaluator.h **** 
  12:./Eigen/src/Core/AssignEvaluator.h **** #ifndef EIGEN_ASSIGN_EVALUATOR_H
  13:./Eigen/src/Core/AssignEvaluator.h **** #define EIGEN_ASSIGN_EVALUATOR_H
  14:./Eigen/src/Core/AssignEvaluator.h **** 
  15:./Eigen/src/Core/AssignEvaluator.h **** namespace Eigen {
  16:./Eigen/src/Core/AssignEvaluator.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 54


  17:./Eigen/src/Core/AssignEvaluator.h **** // This implementation is based on Assign.h
  18:./Eigen/src/Core/AssignEvaluator.h **** 
  19:./Eigen/src/Core/AssignEvaluator.h **** namespace internal {
  20:./Eigen/src/Core/AssignEvaluator.h **** 
  21:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
  22:./Eigen/src/Core/AssignEvaluator.h **** * Part 1 : the logic deciding a strategy for traversal and unrolling       *
  23:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
  24:./Eigen/src/Core/AssignEvaluator.h **** 
  25:./Eigen/src/Core/AssignEvaluator.h **** // copy_using_evaluator_traits is based on assign_traits
  26:./Eigen/src/Core/AssignEvaluator.h **** 
  27:./Eigen/src/Core/AssignEvaluator.h **** template <typename DstEvaluator, typename SrcEvaluator, typename AssignFunc, int MaxPacketSize = -1
  28:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_traits
  29:./Eigen/src/Core/AssignEvaluator.h **** {
  30:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename DstEvaluator::XprType Dst;
  31:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Dst::Scalar DstScalar;
  32:./Eigen/src/Core/AssignEvaluator.h **** 
  33:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  34:./Eigen/src/Core/AssignEvaluator.h ****     DstFlags = DstEvaluator::Flags,
  35:./Eigen/src/Core/AssignEvaluator.h ****     SrcFlags = SrcEvaluator::Flags
  36:./Eigen/src/Core/AssignEvaluator.h ****   };
  37:./Eigen/src/Core/AssignEvaluator.h **** 
  38:./Eigen/src/Core/AssignEvaluator.h **** public:
  39:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  40:./Eigen/src/Core/AssignEvaluator.h ****     DstAlignment = DstEvaluator::Alignment,
  41:./Eigen/src/Core/AssignEvaluator.h ****     SrcAlignment = SrcEvaluator::Alignment,
  42:./Eigen/src/Core/AssignEvaluator.h ****     DstHasDirectAccess = (DstFlags & DirectAccessBit) == DirectAccessBit,
  43:./Eigen/src/Core/AssignEvaluator.h ****     JointAlignment = EIGEN_PLAIN_ENUM_MIN(DstAlignment,SrcAlignment)
  44:./Eigen/src/Core/AssignEvaluator.h ****   };
  45:./Eigen/src/Core/AssignEvaluator.h **** 
  46:./Eigen/src/Core/AssignEvaluator.h **** private:
  47:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  48:./Eigen/src/Core/AssignEvaluator.h ****     InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)
  49:./Eigen/src/Core/AssignEvaluator.h ****               : int(DstFlags)&RowMajorBit ? int(Dst::ColsAtCompileTime)
  50:./Eigen/src/Core/AssignEvaluator.h ****               : int(Dst::RowsAtCompileTime),
  51:./Eigen/src/Core/AssignEvaluator.h ****     InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)
  52:./Eigen/src/Core/AssignEvaluator.h ****               : int(DstFlags)&RowMajorBit ? int(Dst::MaxColsAtCompileTime)
  53:./Eigen/src/Core/AssignEvaluator.h ****               : int(Dst::MaxRowsAtCompileTime),
  54:./Eigen/src/Core/AssignEvaluator.h ****     RestrictedInnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(InnerSize,MaxPacketSize),
  55:./Eigen/src/Core/AssignEvaluator.h ****     RestrictedLinearSize = EIGEN_SIZE_MIN_PREFER_FIXED(Dst::SizeAtCompileTime,MaxPacketSize),
  56:./Eigen/src/Core/AssignEvaluator.h ****     OuterStride = int(outer_stride_at_compile_time<Dst>::ret),
  57:./Eigen/src/Core/AssignEvaluator.h ****     MaxSizeAtCompileTime = Dst::SizeAtCompileTime
  58:./Eigen/src/Core/AssignEvaluator.h ****   };
  59:./Eigen/src/Core/AssignEvaluator.h **** 
  60:./Eigen/src/Core/AssignEvaluator.h ****   // TODO distinguish between linear traversal and inner-traversals
  61:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename find_best_packet<DstScalar,RestrictedLinearSize>::type LinearPacketType;
  62:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename find_best_packet<DstScalar,RestrictedInnerSize>::type InnerPacketType;
  63:./Eigen/src/Core/AssignEvaluator.h **** 
  64:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  65:./Eigen/src/Core/AssignEvaluator.h ****     LinearPacketSize = unpacket_traits<LinearPacketType>::size,
  66:./Eigen/src/Core/AssignEvaluator.h ****     InnerPacketSize = unpacket_traits<InnerPacketType>::size
  67:./Eigen/src/Core/AssignEvaluator.h ****   };
  68:./Eigen/src/Core/AssignEvaluator.h **** 
  69:./Eigen/src/Core/AssignEvaluator.h **** public:
  70:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  71:./Eigen/src/Core/AssignEvaluator.h ****     LinearRequiredAlignment = unpacket_traits<LinearPacketType>::alignment,
  72:./Eigen/src/Core/AssignEvaluator.h ****     InnerRequiredAlignment = unpacket_traits<InnerPacketType>::alignment
  73:./Eigen/src/Core/AssignEvaluator.h ****   };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 55


  74:./Eigen/src/Core/AssignEvaluator.h **** 
  75:./Eigen/src/Core/AssignEvaluator.h **** private:
  76:./Eigen/src/Core/AssignEvaluator.h ****   enum {
  77:./Eigen/src/Core/AssignEvaluator.h ****     DstIsRowMajor = DstFlags&RowMajorBit,
  78:./Eigen/src/Core/AssignEvaluator.h ****     SrcIsRowMajor = SrcFlags&RowMajorBit,
  79:./Eigen/src/Core/AssignEvaluator.h ****     StorageOrdersAgree = (int(DstIsRowMajor) == int(SrcIsRowMajor)),
  80:./Eigen/src/Core/AssignEvaluator.h ****     MightVectorize = bool(StorageOrdersAgree)
  81:./Eigen/src/Core/AssignEvaluator.h ****                   && (int(DstFlags) & int(SrcFlags) & ActualPacketAccessBit)
  82:./Eigen/src/Core/AssignEvaluator.h ****                   && bool(functor_traits<AssignFunc>::PacketAccess),
  83:./Eigen/src/Core/AssignEvaluator.h ****     MayInnerVectorize  = MightVectorize
  84:./Eigen/src/Core/AssignEvaluator.h ****                        && int(InnerSize)!=Dynamic && int(InnerSize)%int(InnerPacketSize)==0
  85:./Eigen/src/Core/AssignEvaluator.h ****                        && int(OuterStride)!=Dynamic && int(OuterStride)%int(InnerPacketSize)==0
  86:./Eigen/src/Core/AssignEvaluator.h ****                        && (EIGEN_UNALIGNED_VECTORIZE  || int(JointAlignment)>=int(InnerRequiredAlig
  87:./Eigen/src/Core/AssignEvaluator.h ****     MayLinearize = bool(StorageOrdersAgree) && (int(DstFlags) & int(SrcFlags) & LinearAccessBit),
  88:./Eigen/src/Core/AssignEvaluator.h ****     MayLinearVectorize = bool(MightVectorize) && bool(MayLinearize) && bool(DstHasDirectAccess)
  89:./Eigen/src/Core/AssignEvaluator.h ****                        && (EIGEN_UNALIGNED_VECTORIZE || (int(DstAlignment)>=int(LinearRequiredAlign
  90:./Eigen/src/Core/AssignEvaluator.h ****       /* If the destination isn't aligned, we have to do runtime checks and we don't unroll,
  91:./Eigen/src/Core/AssignEvaluator.h ****          so it's only good for large enough sizes. */
  92:./Eigen/src/Core/AssignEvaluator.h ****     MaySliceVectorize  = bool(MightVectorize) && bool(DstHasDirectAccess)
  93:./Eigen/src/Core/AssignEvaluator.h ****                        && (int(InnerMaxSize)==Dynamic || int(InnerMaxSize)>=(EIGEN_UNALIGNED_VECTOR
  94:./Eigen/src/Core/AssignEvaluator.h ****       /* slice vectorization can be slow, so we only want it if the slices are big, which is
  95:./Eigen/src/Core/AssignEvaluator.h ****          indicated by InnerMaxSize rather than InnerSize, think of the case of a dynamic block
  96:./Eigen/src/Core/AssignEvaluator.h ****          in a fixed-size matrix
  97:./Eigen/src/Core/AssignEvaluator.h ****          However, with EIGEN_UNALIGNED_VECTORIZE and unrolling, slice vectorization is still worth 
  98:./Eigen/src/Core/AssignEvaluator.h ****   };
  99:./Eigen/src/Core/AssignEvaluator.h **** 
 100:./Eigen/src/Core/AssignEvaluator.h **** public:
 101:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 102:./Eigen/src/Core/AssignEvaluator.h ****     Traversal =  int(Dst::SizeAtCompileTime) == 0 ? int(AllAtOnceTraversal) // If compile-size is z
 103:./Eigen/src/Core/AssignEvaluator.h ****               : (int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize)) ? int(LinearVectori
 104:./Eigen/src/Core/AssignEvaluator.h ****               : int(MayInnerVectorize)   ? int(InnerVectorizedTraversal)
 105:./Eigen/src/Core/AssignEvaluator.h ****               : int(MayLinearVectorize)  ? int(LinearVectorizedTraversal)
 106:./Eigen/src/Core/AssignEvaluator.h ****               : int(MaySliceVectorize)   ? int(SliceVectorizedTraversal)
 107:./Eigen/src/Core/AssignEvaluator.h ****               : int(MayLinearize)        ? int(LinearTraversal)
 108:./Eigen/src/Core/AssignEvaluator.h ****                                          : int(DefaultTraversal),
 109:./Eigen/src/Core/AssignEvaluator.h ****     Vectorized = int(Traversal) == InnerVectorizedTraversal
 110:./Eigen/src/Core/AssignEvaluator.h ****               || int(Traversal) == LinearVectorizedTraversal
 111:./Eigen/src/Core/AssignEvaluator.h ****               || int(Traversal) == SliceVectorizedTraversal
 112:./Eigen/src/Core/AssignEvaluator.h ****   };
 113:./Eigen/src/Core/AssignEvaluator.h **** 
 114:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename conditional<int(Traversal)==LinearVectorizedTraversal, LinearPacketType, InnerPa
 115:./Eigen/src/Core/AssignEvaluator.h **** 
 116:./Eigen/src/Core/AssignEvaluator.h **** private:
 117:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 118:./Eigen/src/Core/AssignEvaluator.h ****     ActualPacketSize    = int(Traversal)==LinearVectorizedTraversal ? LinearPacketSize
 119:./Eigen/src/Core/AssignEvaluator.h ****                         : Vectorized ? InnerPacketSize
 120:./Eigen/src/Core/AssignEvaluator.h ****                         : 1,
 121:./Eigen/src/Core/AssignEvaluator.h ****     UnrollingLimit      = EIGEN_UNROLLING_LIMIT * ActualPacketSize,
 122:./Eigen/src/Core/AssignEvaluator.h ****     MayUnrollCompletely = int(Dst::SizeAtCompileTime) != Dynamic
 123:./Eigen/src/Core/AssignEvaluator.h ****                        && int(Dst::SizeAtCompileTime) * (int(DstEvaluator::CoeffReadCost)+int(SrcEv
 124:./Eigen/src/Core/AssignEvaluator.h ****     MayUnrollInner      = int(InnerSize) != Dynamic
 125:./Eigen/src/Core/AssignEvaluator.h ****                        && int(InnerSize) * (int(DstEvaluator::CoeffReadCost)+int(SrcEvaluator::Coef
 126:./Eigen/src/Core/AssignEvaluator.h ****   };
 127:./Eigen/src/Core/AssignEvaluator.h **** 
 128:./Eigen/src/Core/AssignEvaluator.h **** public:
 129:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 130:./Eigen/src/Core/AssignEvaluator.h ****     Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTr
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 56


 131:./Eigen/src/Core/AssignEvaluator.h ****                 ? (
 132:./Eigen/src/Core/AssignEvaluator.h ****                     int(MayUnrollCompletely) ? int(CompleteUnrolling)
 133:./Eigen/src/Core/AssignEvaluator.h ****                   : int(MayUnrollInner)      ? int(InnerUnrolling)
 134:./Eigen/src/Core/AssignEvaluator.h ****                                              : int(NoUnrolling)
 135:./Eigen/src/Core/AssignEvaluator.h ****                   )
 136:./Eigen/src/Core/AssignEvaluator.h ****               : int(Traversal) == int(LinearVectorizedTraversal)
 137:./Eigen/src/Core/AssignEvaluator.h ****                 ? ( bool(MayUnrollCompletely) && ( EIGEN_UNALIGNED_VECTORIZE || (int(DstAlignment)>
 138:./Eigen/src/Core/AssignEvaluator.h ****                           ? int(CompleteUnrolling)
 139:./Eigen/src/Core/AssignEvaluator.h ****                           : int(NoUnrolling) )
 140:./Eigen/src/Core/AssignEvaluator.h ****               : int(Traversal) == int(LinearTraversal)
 141:./Eigen/src/Core/AssignEvaluator.h ****                 ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling)
 142:./Eigen/src/Core/AssignEvaluator.h ****                                               : int(NoUnrolling) )
 143:./Eigen/src/Core/AssignEvaluator.h **** #if EIGEN_UNALIGNED_VECTORIZE
 144:./Eigen/src/Core/AssignEvaluator.h ****               : int(Traversal) == int(SliceVectorizedTraversal)
 145:./Eigen/src/Core/AssignEvaluator.h ****                 ? ( bool(MayUnrollInner) ? int(InnerUnrolling)
 146:./Eigen/src/Core/AssignEvaluator.h ****                                          : int(NoUnrolling) )
 147:./Eigen/src/Core/AssignEvaluator.h **** #endif
 148:./Eigen/src/Core/AssignEvaluator.h ****               : int(NoUnrolling)
 149:./Eigen/src/Core/AssignEvaluator.h ****   };
 150:./Eigen/src/Core/AssignEvaluator.h **** 
 151:./Eigen/src/Core/AssignEvaluator.h **** #ifdef EIGEN_DEBUG_ASSIGN
 152:./Eigen/src/Core/AssignEvaluator.h ****   static void debug()
 153:./Eigen/src/Core/AssignEvaluator.h ****   {
 154:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "DstXpr: " << typeid(typename DstEvaluator::XprType).name() << std::endl;
 155:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "SrcXpr: " << typeid(typename SrcEvaluator::XprType).name() << std::endl;
 156:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr.setf(std::ios::hex, std::ios::basefield);
 157:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "DstFlags" << " = " << DstFlags << " (" << demangle_flags(DstFlags) << " )" << std
 158:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "SrcFlags" << " = " << SrcFlags << " (" << demangle_flags(SrcFlags) << " )" << std
 159:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr.unsetf(std::ios::hex);
 160:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(DstAlignment)
 161:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(SrcAlignment)
 162:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(LinearRequiredAlignment)
 163:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(InnerRequiredAlignment)
 164:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(JointAlignment)
 165:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(InnerSize)
 166:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(InnerMaxSize)
 167:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(LinearPacketSize)
 168:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(InnerPacketSize)
 169:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(ActualPacketSize)
 170:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(StorageOrdersAgree)
 171:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MightVectorize)
 172:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MayLinearize)
 173:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MayInnerVectorize)
 174:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MayLinearVectorize)
 175:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MaySliceVectorize)
 176:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "Traversal" << " = " << Traversal << " (" << demangle_traversal(Traversal) << ")" 
 177:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(SrcEvaluator::CoeffReadCost)
 178:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(DstEvaluator::CoeffReadCost)
 179:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(Dst::SizeAtCompileTime)
 180:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(UnrollingLimit)
 181:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MayUnrollCompletely)
 182:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEBUG_VAR(MayUnrollInner)
 183:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << "Unrolling" << " = " << Unrolling << " (" << demangle_unrolling(Unrolling) << ")" 
 184:./Eigen/src/Core/AssignEvaluator.h ****     std::cerr << std::endl;
 185:./Eigen/src/Core/AssignEvaluator.h ****   }
 186:./Eigen/src/Core/AssignEvaluator.h **** #endif
 187:./Eigen/src/Core/AssignEvaluator.h **** };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 57


 188:./Eigen/src/Core/AssignEvaluator.h **** 
 189:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
 190:./Eigen/src/Core/AssignEvaluator.h **** * Part 2 : meta-unrollers
 191:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
 192:./Eigen/src/Core/AssignEvaluator.h **** 
 193:./Eigen/src/Core/AssignEvaluator.h **** /************************
 194:./Eigen/src/Core/AssignEvaluator.h **** *** Default traversal ***
 195:./Eigen/src/Core/AssignEvaluator.h **** ************************/
 196:./Eigen/src/Core/AssignEvaluator.h **** 
 197:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Index, int Stop>
 198:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling
 199:./Eigen/src/Core/AssignEvaluator.h **** {
 200:./Eigen/src/Core/AssignEvaluator.h ****   // FIXME: this is not very clean, perhaps this information should be provided by the kernel?
 201:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Kernel::DstEvaluatorType DstEvaluatorType;
 202:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename DstEvaluatorType::XprType DstXprType;
 203:./Eigen/src/Core/AssignEvaluator.h **** 
 204:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 205:./Eigen/src/Core/AssignEvaluator.h ****     outer = Index / DstXprType::InnerSizeAtCompileTime,
 206:./Eigen/src/Core/AssignEvaluator.h ****     inner = Index % DstXprType::InnerSizeAtCompileTime
 207:./Eigen/src/Core/AssignEvaluator.h ****   };
 208:./Eigen/src/Core/AssignEvaluator.h **** 
 209:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 210:./Eigen/src/Core/AssignEvaluator.h ****   {
 211:./Eigen/src/Core/AssignEvaluator.h ****     kernel.assignCoeffByOuterInner(outer, inner);
 212:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 213:./Eigen/src/Core/AssignEvaluator.h ****   }
 214:./Eigen/src/Core/AssignEvaluator.h **** };
 215:./Eigen/src/Core/AssignEvaluator.h **** 
 216:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Stop>
 217:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Stop, Stop>
 218:./Eigen/src/Core/AssignEvaluator.h **** {
 219:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }
 220:./Eigen/src/Core/AssignEvaluator.h **** };
 221:./Eigen/src/Core/AssignEvaluator.h **** 
 222:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Index_, int Stop>
 223:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_DefaultTraversal_InnerUnrolling
 224:./Eigen/src/Core/AssignEvaluator.h **** {
 225:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)
 226:./Eigen/src/Core/AssignEvaluator.h ****   {
 227:./Eigen/src/Core/AssignEvaluator.h ****     kernel.assignCoeffByOuterInner(outer, Index_);
 228:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Index_+1, Stop>::run(kernel, outer
 229:./Eigen/src/Core/AssignEvaluator.h ****   }
 230:./Eigen/src/Core/AssignEvaluator.h **** };
 231:./Eigen/src/Core/AssignEvaluator.h **** 
 232:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Stop>
 233:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Stop, Stop>
 234:./Eigen/src/Core/AssignEvaluator.h **** {
 235:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index) { }
 236:./Eigen/src/Core/AssignEvaluator.h **** };
 237:./Eigen/src/Core/AssignEvaluator.h **** 
 238:./Eigen/src/Core/AssignEvaluator.h **** /***********************
 239:./Eigen/src/Core/AssignEvaluator.h **** *** Linear traversal ***
 240:./Eigen/src/Core/AssignEvaluator.h **** ***********************/
 241:./Eigen/src/Core/AssignEvaluator.h **** 
 242:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Index, int Stop>
 243:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_LinearTraversal_CompleteUnrolling
 244:./Eigen/src/Core/AssignEvaluator.h **** {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 58


 245:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel& kernel)
 246:./Eigen/src/Core/AssignEvaluator.h ****   {
 247:./Eigen/src/Core/AssignEvaluator.h ****     kernel.assignCoeff(Index);
 248:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 249:./Eigen/src/Core/AssignEvaluator.h ****   }
 250:./Eigen/src/Core/AssignEvaluator.h **** };
 251:./Eigen/src/Core/AssignEvaluator.h **** 
 252:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Stop>
 253:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Stop, Stop>
 254:./Eigen/src/Core/AssignEvaluator.h **** {
 255:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }
 256:./Eigen/src/Core/AssignEvaluator.h **** };
 257:./Eigen/src/Core/AssignEvaluator.h **** 
 258:./Eigen/src/Core/AssignEvaluator.h **** /**************************
 259:./Eigen/src/Core/AssignEvaluator.h **** *** Inner vectorization ***
 260:./Eigen/src/Core/AssignEvaluator.h **** **************************/
 261:./Eigen/src/Core/AssignEvaluator.h **** 
 262:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Index, int Stop>
 263:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_innervec_CompleteUnrolling
 264:./Eigen/src/Core/AssignEvaluator.h **** {
 265:./Eigen/src/Core/AssignEvaluator.h ****   // FIXME: this is not very clean, perhaps this information should be provided by the kernel?
 266:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Kernel::DstEvaluatorType DstEvaluatorType;
 267:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename DstEvaluatorType::XprType DstXprType;
 268:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Kernel::PacketType PacketType;
 269:./Eigen/src/Core/AssignEvaluator.h **** 
 270:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 271:./Eigen/src/Core/AssignEvaluator.h ****     outer = Index / DstXprType::InnerSizeAtCompileTime,
 272:./Eigen/src/Core/AssignEvaluator.h ****     inner = Index % DstXprType::InnerSizeAtCompileTime,
 273:./Eigen/src/Core/AssignEvaluator.h ****     SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,
 274:./Eigen/src/Core/AssignEvaluator.h ****     DstAlignment = Kernel::AssignmentTraits::DstAlignment
 275:./Eigen/src/Core/AssignEvaluator.h ****   };
 276:./Eigen/src/Core/AssignEvaluator.h **** 
 277:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 278:./Eigen/src/Core/AssignEvaluator.h ****   {
 279:./Eigen/src/Core/AssignEvaluator.h ****     kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inner);
 280:./Eigen/src/Core/AssignEvaluator.h ****     enum { NextIndex = Index + unpacket_traits<PacketType>::size };
 281:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_innervec_CompleteUnrolling<Kernel, NextIndex, Stop>::run(kernel);
 282:./Eigen/src/Core/AssignEvaluator.h ****   }
 283:./Eigen/src/Core/AssignEvaluator.h **** };
 284:./Eigen/src/Core/AssignEvaluator.h **** 
 285:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Stop>
 286:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_innervec_CompleteUnrolling<Kernel, Stop, Stop>
 287:./Eigen/src/Core/AssignEvaluator.h **** {
 288:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }
 289:./Eigen/src/Core/AssignEvaluator.h **** };
 290:./Eigen/src/Core/AssignEvaluator.h **** 
 291:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Index_, int Stop, int SrcAlignment, int DstAlignment>
 292:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_innervec_InnerUnrolling
 293:./Eigen/src/Core/AssignEvaluator.h **** {
 294:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Kernel::PacketType PacketType;
 295:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)
 296:./Eigen/src/Core/AssignEvaluator.h ****   {
 297:./Eigen/src/Core/AssignEvaluator.h ****     kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, Index_)
 298:./Eigen/src/Core/AssignEvaluator.h ****     enum { NextIndex = Index_ + unpacket_traits<PacketType>::size };
 299:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_innervec_InnerUnrolling<Kernel, NextIndex, Stop, SrcAlignment, DstAlignmen
 300:./Eigen/src/Core/AssignEvaluator.h ****   }
 301:./Eigen/src/Core/AssignEvaluator.h **** };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 59


 302:./Eigen/src/Core/AssignEvaluator.h **** 
 303:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Stop, int SrcAlignment, int DstAlignment>
 304:./Eigen/src/Core/AssignEvaluator.h **** struct copy_using_evaluator_innervec_InnerUnrolling<Kernel, Stop, Stop, SrcAlignment, DstAlignment>
 305:./Eigen/src/Core/AssignEvaluator.h **** {
 306:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &, Index) { }
 307:./Eigen/src/Core/AssignEvaluator.h **** };
 308:./Eigen/src/Core/AssignEvaluator.h **** 
 309:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
 310:./Eigen/src/Core/AssignEvaluator.h **** * Part 3 : implementation of all cases
 311:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
 312:./Eigen/src/Core/AssignEvaluator.h **** 
 313:./Eigen/src/Core/AssignEvaluator.h **** // dense_assignment_loop is based on assign_impl
 314:./Eigen/src/Core/AssignEvaluator.h **** 
 315:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel,
 316:./Eigen/src/Core/AssignEvaluator.h ****          int Traversal = Kernel::AssignmentTraits::Traversal,
 317:./Eigen/src/Core/AssignEvaluator.h ****          int Unrolling = Kernel::AssignmentTraits::Unrolling>
 318:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop;
 319:./Eigen/src/Core/AssignEvaluator.h **** 
 320:./Eigen/src/Core/AssignEvaluator.h **** /************************
 321:./Eigen/src/Core/AssignEvaluator.h **** ***** Special Cases *****
 322:./Eigen/src/Core/AssignEvaluator.h **** ************************/
 323:./Eigen/src/Core/AssignEvaluator.h **** 
 324:./Eigen/src/Core/AssignEvaluator.h **** // Zero-sized assignment is a no-op.
 325:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel, int Unrolling>
 326:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, AllAtOnceTraversal, Unrolling>
 327:./Eigen/src/Core/AssignEvaluator.h **** {
 328:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel& /*kernel*/)
 329:./Eigen/src/Core/AssignEvaluator.h ****   {
 330:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 331:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_STATIC_ASSERT(int(DstXprType::SizeAtCompileTime) == 0,
 332:./Eigen/src/Core/AssignEvaluator.h ****       EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT)
 333:./Eigen/src/Core/AssignEvaluator.h ****   }
 334:./Eigen/src/Core/AssignEvaluator.h **** };
 335:./Eigen/src/Core/AssignEvaluator.h **** 
 336:./Eigen/src/Core/AssignEvaluator.h **** /************************
 337:./Eigen/src/Core/AssignEvaluator.h **** *** Default traversal ***
 338:./Eigen/src/Core/AssignEvaluator.h **** ************************/
 339:./Eigen/src/Core/AssignEvaluator.h **** 
 340:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 341:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>
 342:./Eigen/src/Core/AssignEvaluator.h **** {
 343:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)
 344:./Eigen/src/Core/AssignEvaluator.h ****   {
 345:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < kernel.outerSize(); ++outer) {
 346:./Eigen/src/Core/AssignEvaluator.h ****       for(Index inner = 0; inner < kernel.innerSize(); ++inner) {
 347:./Eigen/src/Core/AssignEvaluator.h ****         kernel.assignCoeffByOuterInner(outer, inner);
 348:./Eigen/src/Core/AssignEvaluator.h ****       }
 349:./Eigen/src/Core/AssignEvaluator.h ****     }
 350:./Eigen/src/Core/AssignEvaluator.h ****   }
 351:./Eigen/src/Core/AssignEvaluator.h **** };
 352:./Eigen/src/Core/AssignEvaluator.h **** 
 353:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 354:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, DefaultTraversal, CompleteUnrolling>
 355:./Eigen/src/Core/AssignEvaluator.h **** {
 356:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 357:./Eigen/src/Core/AssignEvaluator.h ****   {
 358:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 60


 359:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTim
 360:./Eigen/src/Core/AssignEvaluator.h ****   }
 361:./Eigen/src/Core/AssignEvaluator.h **** };
 362:./Eigen/src/Core/AssignEvaluator.h **** 
 363:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 364:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, DefaultTraversal, InnerUnrolling>
 365:./Eigen/src/Core/AssignEvaluator.h **** {
 366:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 367:./Eigen/src/Core/AssignEvaluator.h ****   {
 368:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 369:./Eigen/src/Core/AssignEvaluator.h **** 
 370:./Eigen/src/Core/AssignEvaluator.h ****     const Index outerSize = kernel.outerSize();
 371:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < outerSize; ++outer)
 372:./Eigen/src/Core/AssignEvaluator.h ****       copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, 0, DstXprType::InnerSizeAtCompil
 373:./Eigen/src/Core/AssignEvaluator.h ****   }
 374:./Eigen/src/Core/AssignEvaluator.h **** };
 375:./Eigen/src/Core/AssignEvaluator.h **** 
 376:./Eigen/src/Core/AssignEvaluator.h **** /***************************
 377:./Eigen/src/Core/AssignEvaluator.h **** *** Linear vectorization ***
 378:./Eigen/src/Core/AssignEvaluator.h **** ***************************/
 379:./Eigen/src/Core/AssignEvaluator.h **** 
 380:./Eigen/src/Core/AssignEvaluator.h **** 
 381:./Eigen/src/Core/AssignEvaluator.h **** // The goal of unaligned_dense_assignment_loop is simply to factorize the handling
 382:./Eigen/src/Core/AssignEvaluator.h **** // of the non vectorizable beginning and ending parts
 383:./Eigen/src/Core/AssignEvaluator.h **** 
 384:./Eigen/src/Core/AssignEvaluator.h **** template <bool IsAligned = false>
 385:./Eigen/src/Core/AssignEvaluator.h **** struct unaligned_dense_assignment_loop
 386:./Eigen/src/Core/AssignEvaluator.h **** {
 387:./Eigen/src/Core/AssignEvaluator.h ****   // if IsAligned = true, then do nothing
 388:./Eigen/src/Core/AssignEvaluator.h ****   template <typename Kernel>
 389:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index, Index) {}
 390:./Eigen/src/Core/AssignEvaluator.h **** };
 391:./Eigen/src/Core/AssignEvaluator.h **** 
 392:./Eigen/src/Core/AssignEvaluator.h **** template <>
 393:./Eigen/src/Core/AssignEvaluator.h **** struct unaligned_dense_assignment_loop<false>
 394:./Eigen/src/Core/AssignEvaluator.h **** {
 395:./Eigen/src/Core/AssignEvaluator.h ****   // MSVC must not inline this functions. If it does, it fails to optimize the
 396:./Eigen/src/Core/AssignEvaluator.h ****   // packet access path.
 397:./Eigen/src/Core/AssignEvaluator.h ****   // FIXME check which version exhibits this issue
 398:./Eigen/src/Core/AssignEvaluator.h **** #if EIGEN_COMP_MSVC
 399:./Eigen/src/Core/AssignEvaluator.h ****   template <typename Kernel>
 400:./Eigen/src/Core/AssignEvaluator.h ****   static EIGEN_DONT_INLINE void run(Kernel &kernel,
 401:./Eigen/src/Core/AssignEvaluator.h ****                                     Index start,
 402:./Eigen/src/Core/AssignEvaluator.h ****                                     Index end)
 403:./Eigen/src/Core/AssignEvaluator.h **** #else
 404:./Eigen/src/Core/AssignEvaluator.h ****   template <typename Kernel>
 405:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel,
 406:./Eigen/src/Core/AssignEvaluator.h ****                                       Index start,
 407:./Eigen/src/Core/AssignEvaluator.h ****                                       Index end)
 408:./Eigen/src/Core/AssignEvaluator.h **** #endif
 409:./Eigen/src/Core/AssignEvaluator.h ****   {
 410:./Eigen/src/Core/AssignEvaluator.h ****     for (Index index = start; index < end; ++index)
 411:./Eigen/src/Core/AssignEvaluator.h ****       kernel.assignCoeff(index);
 412:./Eigen/src/Core/AssignEvaluator.h ****   }
 413:./Eigen/src/Core/AssignEvaluator.h **** };
 414:./Eigen/src/Core/AssignEvaluator.h **** 
 415:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 61


 416:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>
 417:./Eigen/src/Core/AssignEvaluator.h **** {
 418:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 419:./Eigen/src/Core/AssignEvaluator.h ****   {
 420:./Eigen/src/Core/AssignEvaluator.h ****     const Index size = kernel.size();
 421:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::Scalar Scalar;
 422:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::PacketType PacketType;
 423:./Eigen/src/Core/AssignEvaluator.h ****     enum {
 424:./Eigen/src/Core/AssignEvaluator.h ****       requestedAlignment = Kernel::AssignmentTraits::LinearRequiredAlignment,
 425:./Eigen/src/Core/AssignEvaluator.h ****       packetSize = unpacket_traits<PacketType>::size,
 426:./Eigen/src/Core/AssignEvaluator.h ****       dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
 427:./Eigen/src/Core/AssignEvaluator.h ****       dstAlignment = packet_traits<Scalar>::AlignedOnScalar ? int(requestedAlignment)
 428:./Eigen/src/Core/AssignEvaluator.h ****                                                             : int(Kernel::AssignmentTraits::DstAlig
 429:./Eigen/src/Core/AssignEvaluator.h ****       srcAlignment = Kernel::AssignmentTraits::JointAlignment
 430:./Eigen/src/Core/AssignEvaluator.h ****     };
 431:./Eigen/src/Core/AssignEvaluator.h ****     const Index alignedStart = dstIsAligned ? 0 : internal::first_aligned<requestedAlignment>(kerne
 432:./Eigen/src/Core/AssignEvaluator.h ****     const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;
 433:./Eigen/src/Core/AssignEvaluator.h **** 
 434:./Eigen/src/Core/AssignEvaluator.h ****     unaligned_dense_assignment_loop<dstIsAligned!=0>::run(kernel, 0, alignedStart);
 435:./Eigen/src/Core/AssignEvaluator.h **** 
 436:./Eigen/src/Core/AssignEvaluator.h ****     for(Index index = alignedStart; index < alignedEnd; index += packetSize)
 437:./Eigen/src/Core/AssignEvaluator.h ****       kernel.template assignPacket<dstAlignment, srcAlignment, PacketType>(index);
 438:./Eigen/src/Core/AssignEvaluator.h **** 
 439:./Eigen/src/Core/AssignEvaluator.h ****     unaligned_dense_assignment_loop<>::run(kernel, alignedEnd, size);
 440:./Eigen/src/Core/AssignEvaluator.h ****   }
 441:./Eigen/src/Core/AssignEvaluator.h **** };
 442:./Eigen/src/Core/AssignEvaluator.h **** 
 443:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 444:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>
 445:./Eigen/src/Core/AssignEvaluator.h **** {
 446:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 447:./Eigen/src/Core/AssignEvaluator.h ****   {
 448:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 449:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::PacketType PacketType;
 450:./Eigen/src/Core/AssignEvaluator.h **** 
 451:./Eigen/src/Core/AssignEvaluator.h ****     enum { size = DstXprType::SizeAtCompileTime,
 452:./Eigen/src/Core/AssignEvaluator.h ****            packetSize =unpacket_traits<PacketType>::size,
 453:./Eigen/src/Core/AssignEvaluator.h ****            alignedSize = (int(size)/packetSize)*packetSize };
 454:./Eigen/src/Core/AssignEvaluator.h **** 
 455:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_innervec_CompleteUnrolling<Kernel, 0, alignedSize>::run(kernel);
 456:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, alignedSize, size>::run(kernel)
 457:./Eigen/src/Core/AssignEvaluator.h ****   }
 458:./Eigen/src/Core/AssignEvaluator.h **** };
 459:./Eigen/src/Core/AssignEvaluator.h **** 
 460:./Eigen/src/Core/AssignEvaluator.h **** /**************************
 461:./Eigen/src/Core/AssignEvaluator.h **** *** Inner vectorization ***
 462:./Eigen/src/Core/AssignEvaluator.h **** **************************/
 463:./Eigen/src/Core/AssignEvaluator.h **** 
 464:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 465:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, NoUnrolling>
 466:./Eigen/src/Core/AssignEvaluator.h **** {
 467:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename Kernel::PacketType PacketType;
 468:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 469:./Eigen/src/Core/AssignEvaluator.h ****     SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,
 470:./Eigen/src/Core/AssignEvaluator.h ****     DstAlignment = Kernel::AssignmentTraits::DstAlignment
 471:./Eigen/src/Core/AssignEvaluator.h ****   };
 472:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 62


 473:./Eigen/src/Core/AssignEvaluator.h ****   {
 474:./Eigen/src/Core/AssignEvaluator.h ****     const Index innerSize = kernel.innerSize();
 475:./Eigen/src/Core/AssignEvaluator.h ****     const Index outerSize = kernel.outerSize();
 476:./Eigen/src/Core/AssignEvaluator.h ****     const Index packetSize = unpacket_traits<PacketType>::size;
 477:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < outerSize; ++outer)
 478:./Eigen/src/Core/AssignEvaluator.h ****       for(Index inner = 0; inner < innerSize; inner+=packetSize)
 479:./Eigen/src/Core/AssignEvaluator.h ****         kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inn
 480:./Eigen/src/Core/AssignEvaluator.h ****   }
 481:./Eigen/src/Core/AssignEvaluator.h **** };
 482:./Eigen/src/Core/AssignEvaluator.h **** 
 483:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 484:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, CompleteUnrolling>
 485:./Eigen/src/Core/AssignEvaluator.h **** {
 486:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 487:./Eigen/src/Core/AssignEvaluator.h ****   {
 488:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 489:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_innervec_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(
 490:./Eigen/src/Core/AssignEvaluator.h ****   }
 491:./Eigen/src/Core/AssignEvaluator.h **** };
 492:./Eigen/src/Core/AssignEvaluator.h **** 
 493:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 494:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, InnerUnrolling>
 495:./Eigen/src/Core/AssignEvaluator.h **** {
 496:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 497:./Eigen/src/Core/AssignEvaluator.h ****   {
 498:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 499:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::AssignmentTraits Traits;
 500:./Eigen/src/Core/AssignEvaluator.h ****     const Index outerSize = kernel.outerSize();
 501:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < outerSize; ++outer)
 502:./Eigen/src/Core/AssignEvaluator.h ****       copy_using_evaluator_innervec_InnerUnrolling<Kernel, 0, DstXprType::InnerSizeAtCompileTime,
 503:./Eigen/src/Core/AssignEvaluator.h ****                                                    Traits::SrcAlignment, Traits::DstAlignment>::run
 504:./Eigen/src/Core/AssignEvaluator.h ****   }
 505:./Eigen/src/Core/AssignEvaluator.h **** };
 506:./Eigen/src/Core/AssignEvaluator.h **** 
 507:./Eigen/src/Core/AssignEvaluator.h **** /***********************
 508:./Eigen/src/Core/AssignEvaluator.h **** *** Linear traversal ***
 509:./Eigen/src/Core/AssignEvaluator.h **** ***********************/
 510:./Eigen/src/Core/AssignEvaluator.h **** 
 511:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 512:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, LinearTraversal, NoUnrolling>
 513:./Eigen/src/Core/AssignEvaluator.h **** {
 514:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 515:./Eigen/src/Core/AssignEvaluator.h ****   {
 516:./Eigen/src/Core/AssignEvaluator.h ****     const Index size = kernel.size();
 517:./Eigen/src/Core/AssignEvaluator.h ****     for(Index i = 0; i < size; ++i)
 518:./Eigen/src/Core/AssignEvaluator.h ****       kernel.assignCoeff(i);
 519:./Eigen/src/Core/AssignEvaluator.h ****   }
 520:./Eigen/src/Core/AssignEvaluator.h **** };
 521:./Eigen/src/Core/AssignEvaluator.h **** 
 522:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 523:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, LinearTraversal, CompleteUnrolling>
 524:./Eigen/src/Core/AssignEvaluator.h **** {
 525:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 526:./Eigen/src/Core/AssignEvaluator.h ****   {
 527:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 528:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime
 529:./Eigen/src/Core/AssignEvaluator.h ****   }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 63


 530:./Eigen/src/Core/AssignEvaluator.h **** };
 531:./Eigen/src/Core/AssignEvaluator.h **** 
 532:./Eigen/src/Core/AssignEvaluator.h **** /**************************
 533:./Eigen/src/Core/AssignEvaluator.h **** *** Slice vectorization ***
 534:./Eigen/src/Core/AssignEvaluator.h **** ***************************/
 535:./Eigen/src/Core/AssignEvaluator.h **** 
 536:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 537:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, NoUnrolling>
 538:./Eigen/src/Core/AssignEvaluator.h **** {
 539:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 540:./Eigen/src/Core/AssignEvaluator.h ****   {
 541:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::Scalar Scalar;
 542:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::PacketType PacketType;
 543:./Eigen/src/Core/AssignEvaluator.h ****     enum {
 544:./Eigen/src/Core/AssignEvaluator.h ****       packetSize = unpacket_traits<PacketType>::size,
 545:./Eigen/src/Core/AssignEvaluator.h ****       requestedAlignment = int(Kernel::AssignmentTraits::InnerRequiredAlignment),
 546:./Eigen/src/Core/AssignEvaluator.h ****       alignable = packet_traits<Scalar>::AlignedOnScalar || int(Kernel::AssignmentTraits::DstAlignm
 547:./Eigen/src/Core/AssignEvaluator.h ****       dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
 548:./Eigen/src/Core/AssignEvaluator.h ****       dstAlignment = alignable ? int(requestedAlignment)
 549:./Eigen/src/Core/AssignEvaluator.h ****                                : int(Kernel::AssignmentTraits::DstAlignment)
 550:./Eigen/src/Core/AssignEvaluator.h ****     };
 551:./Eigen/src/Core/AssignEvaluator.h ****     const Scalar *dst_ptr = kernel.dstDataPtr();
 552:./Eigen/src/Core/AssignEvaluator.h ****     if((!bool(dstIsAligned)) && (UIntPtr(dst_ptr) % sizeof(Scalar))>0)
 553:./Eigen/src/Core/AssignEvaluator.h ****     {
 554:./Eigen/src/Core/AssignEvaluator.h ****       // the pointer is not aligned-on scalar, so alignment is not possible
 555:./Eigen/src/Core/AssignEvaluator.h ****       return dense_assignment_loop<Kernel,DefaultTraversal,NoUnrolling>::run(kernel);
 556:./Eigen/src/Core/AssignEvaluator.h ****     }
 557:./Eigen/src/Core/AssignEvaluator.h ****     const Index packetAlignedMask = packetSize - 1;
 558:./Eigen/src/Core/AssignEvaluator.h ****     const Index innerSize = kernel.innerSize();
 559:./Eigen/src/Core/AssignEvaluator.h ****     const Index outerSize = kernel.outerSize();
 560:./Eigen/src/Core/AssignEvaluator.h ****     const Index alignedStep = alignable ? (packetSize - kernel.outerStride() % packetSize) & packet
 561:./Eigen/src/Core/AssignEvaluator.h ****     Index alignedStart = ((!alignable) || bool(dstIsAligned)) ? 0 : internal::first_aligned<request
 562:./Eigen/src/Core/AssignEvaluator.h **** 
 563:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < outerSize; ++outer)
 564:./Eigen/src/Core/AssignEvaluator.h ****     {
 565:./Eigen/src/Core/AssignEvaluator.h ****       const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);
 566:./Eigen/src/Core/AssignEvaluator.h ****       // do the non-vectorizable part of the assignment
 567:./Eigen/src/Core/AssignEvaluator.h ****       for(Index inner = 0; inner<alignedStart ; ++inner)
 568:./Eigen/src/Core/AssignEvaluator.h ****         kernel.assignCoeffByOuterInner(outer, inner);
 569:./Eigen/src/Core/AssignEvaluator.h **** 
 570:./Eigen/src/Core/AssignEvaluator.h ****       // do the vectorizable part of the assignment
 571:./Eigen/src/Core/AssignEvaluator.h ****       for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)
 572:./Eigen/src/Core/AssignEvaluator.h ****         kernel.template assignPacketByOuterInner<dstAlignment, Unaligned, PacketType>(outer, inner)
 573:./Eigen/src/Core/AssignEvaluator.h **** 
 574:./Eigen/src/Core/AssignEvaluator.h ****       // do the non-vectorizable part of the assignment
 575:./Eigen/src/Core/AssignEvaluator.h ****       for(Index inner = alignedEnd; inner<innerSize ; ++inner)
 576:./Eigen/src/Core/AssignEvaluator.h ****         kernel.assignCoeffByOuterInner(outer, inner);
 577:./Eigen/src/Core/AssignEvaluator.h **** 
 578:./Eigen/src/Core/AssignEvaluator.h ****       alignedStart = numext::mini((alignedStart+alignedStep)%packetSize, innerSize);
 579:./Eigen/src/Core/AssignEvaluator.h ****     }
 580:./Eigen/src/Core/AssignEvaluator.h ****   }
 581:./Eigen/src/Core/AssignEvaluator.h **** };
 582:./Eigen/src/Core/AssignEvaluator.h **** 
 583:./Eigen/src/Core/AssignEvaluator.h **** #if EIGEN_UNALIGNED_VECTORIZE
 584:./Eigen/src/Core/AssignEvaluator.h **** template<typename Kernel>
 585:./Eigen/src/Core/AssignEvaluator.h **** struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>
 586:./Eigen/src/Core/AssignEvaluator.h **** {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 64


 587:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
 588:./Eigen/src/Core/AssignEvaluator.h ****   {
 589:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
 590:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Kernel::PacketType PacketType;
 591:./Eigen/src/Core/AssignEvaluator.h **** 
 592:./Eigen/src/Core/AssignEvaluator.h ****     enum { innerSize = DstXprType::InnerSizeAtCompileTime,
 593:./Eigen/src/Core/AssignEvaluator.h ****            packetSize =unpacket_traits<PacketType>::size,
 594:./Eigen/src/Core/AssignEvaluator.h ****            vectorizableSize = (int(innerSize) / int(packetSize)) * int(packetSize),
 595:./Eigen/src/Core/AssignEvaluator.h ****            size = DstXprType::SizeAtCompileTime };
 596:./Eigen/src/Core/AssignEvaluator.h **** 
 597:./Eigen/src/Core/AssignEvaluator.h ****     for(Index outer = 0; outer < kernel.outerSize(); ++outer)
 598:./Eigen/src/Core/AssignEvaluator.h ****     {
 599:./Eigen/src/Core/AssignEvaluator.h ****       copy_using_evaluator_innervec_InnerUnrolling<Kernel, 0, vectorizableSize, 0, 0>::run(kernel, 
 600:./Eigen/src/Core/AssignEvaluator.h ****       copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, vectorizableSize, innerSize>::ru
 601:./Eigen/src/Core/AssignEvaluator.h ****     }
 602:./Eigen/src/Core/AssignEvaluator.h ****   }
 603:./Eigen/src/Core/AssignEvaluator.h **** };
 604:./Eigen/src/Core/AssignEvaluator.h **** #endif
 605:./Eigen/src/Core/AssignEvaluator.h **** 
 606:./Eigen/src/Core/AssignEvaluator.h **** 
 607:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
 608:./Eigen/src/Core/AssignEvaluator.h **** * Part 4 : Generic dense assignment kernel
 609:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
 610:./Eigen/src/Core/AssignEvaluator.h **** 
 611:./Eigen/src/Core/AssignEvaluator.h **** // This class generalize the assignment of a coefficient (or packet) from one dense evaluator
 612:./Eigen/src/Core/AssignEvaluator.h **** // to another dense writable evaluator.
 613:./Eigen/src/Core/AssignEvaluator.h **** // It is parametrized by the two evaluators, and the actual assignment functor.
 614:./Eigen/src/Core/AssignEvaluator.h **** // This abstraction level permits to keep the evaluation loops as simple and as generic as possible
 615:./Eigen/src/Core/AssignEvaluator.h **** // One can customize the assignment using this generic dense_assignment_kernel with different
 616:./Eigen/src/Core/AssignEvaluator.h **** // functors, or by completely overloading it, by-passing a functor.
 617:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor, int Version = Sp
 618:./Eigen/src/Core/AssignEvaluator.h **** class generic_dense_assignment_kernel
 619:./Eigen/src/Core/AssignEvaluator.h **** {
 620:./Eigen/src/Core/AssignEvaluator.h **** protected:
 621:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename DstEvaluatorTypeT::XprType DstXprType;
 622:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename SrcEvaluatorTypeT::XprType SrcXprType;
 623:./Eigen/src/Core/AssignEvaluator.h **** public:
 624:./Eigen/src/Core/AssignEvaluator.h **** 
 625:./Eigen/src/Core/AssignEvaluator.h ****   typedef DstEvaluatorTypeT DstEvaluatorType;
 626:./Eigen/src/Core/AssignEvaluator.h ****   typedef SrcEvaluatorTypeT SrcEvaluatorType;
 627:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename DstEvaluatorType::Scalar Scalar;
 628:./Eigen/src/Core/AssignEvaluator.h ****   typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTrai
 629:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename AssignmentTraits::PacketType PacketType;
 630:./Eigen/src/Core/AssignEvaluator.h **** 
 631:./Eigen/src/Core/AssignEvaluator.h **** 
 632:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 633:./Eigen/src/Core/AssignEvaluator.h ****   generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor
 634:./Eigen/src/Core/AssignEvaluator.h ****     : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)
 635:./Eigen/src/Core/AssignEvaluator.h ****   {
 636:./Eigen/src/Core/AssignEvaluator.h ****     #ifdef EIGEN_DEBUG_ASSIGN
 637:./Eigen/src/Core/AssignEvaluator.h ****     AssignmentTraits::debug();
 638:./Eigen/src/Core/AssignEvaluator.h ****     #endif
 639:./Eigen/src/Core/AssignEvaluator.h ****   }
 640:./Eigen/src/Core/AssignEvaluator.h **** 
 641:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index size() const EIGEN_NOEXCEPT { return m_dstExpr.size(); }
 642:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index innerSize() const EIGEN_NOEXCEPT { return m_dstExpr.inner
 643:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerSize() const EIGEN_NOEXCEPT { return m_dstExpr.outer
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 65


 644:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_dstExpr.rows(); }
 645:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_dstExpr.cols(); }
 646:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerStride() const EIGEN_NOEXCEPT { return m_dstExpr.out
 647:./Eigen/src/Core/AssignEvaluator.h **** 
 648:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() EIGEN_NOEXCEPT { return m_dst; }
 649:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const EIGEN_NOEXCEPT { return m_src; }
 650:./Eigen/src/Core/AssignEvaluator.h **** 
 651:./Eigen/src/Core/AssignEvaluator.h ****   /// Assign src(row,col) to dst(row,col) through the assignment functor.
 652:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)
 653:./Eigen/src/Core/AssignEvaluator.h ****   {
 654:./Eigen/src/Core/AssignEvaluator.h ****     m_functor.assignCoeff(m_dst.coeffRef(row,col), m_src.coeff(row,col));
 655:./Eigen/src/Core/AssignEvaluator.h ****   }
 656:./Eigen/src/Core/AssignEvaluator.h **** 
 657:./Eigen/src/Core/AssignEvaluator.h ****   /// \sa assignCoeff(Index,Index)
 658:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)
 417              		.loc 9 658 46 is_stmt 1 view -0
 418              		.cfi_startproc
 419              		@ args = 0, pretend = 0, frame = 0
 420              		@ frame_needed = 0, uses_anonymous_args = 0
 421              		.loc 9 658 46 is_stmt 0 view .LVU49
 422 0000 10B5     		push	{r4, lr}
 423              	.LCFI7:
 424              		.cfi_def_cfa_offset 8
 425              		.cfi_offset 4, -8
 426              		.cfi_offset 14, -4
 659:./Eigen/src/Core/AssignEvaluator.h ****   {
 660:./Eigen/src/Core/AssignEvaluator.h ****     m_functor.assignCoeff(m_dst.coeffRef(index), m_src.coeff(index));
 427              		.loc 9 660 27 view .LVU50
 428 0002 0368     		ldr	r3, [r0]
 429              	.LVL25:
 430              	.LBB346:
 431              	.LBI346:
 432              		.file 10 "./Eigen/src/Core/CoreEvaluators.h"
   1:./Eigen/src/Core/CoreEvaluators.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/CoreEvaluators.h **** // for linear algebra.
   3:./Eigen/src/Core/CoreEvaluators.h **** //
   4:./Eigen/src/Core/CoreEvaluators.h **** // Copyright (C) 2011 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/CoreEvaluators.h **** // Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/CoreEvaluators.h **** // Copyright (C) 2011-2012 Jitse Niesen <jitse@maths.leeds.ac.uk>
   7:./Eigen/src/Core/CoreEvaluators.h **** //
   8:./Eigen/src/Core/CoreEvaluators.h **** // This Source Code Form is subject to the terms of the Mozilla
   9:./Eigen/src/Core/CoreEvaluators.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
  10:./Eigen/src/Core/CoreEvaluators.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  11:./Eigen/src/Core/CoreEvaluators.h **** 
  12:./Eigen/src/Core/CoreEvaluators.h **** 
  13:./Eigen/src/Core/CoreEvaluators.h **** #ifndef EIGEN_COREEVALUATORS_H
  14:./Eigen/src/Core/CoreEvaluators.h **** #define EIGEN_COREEVALUATORS_H
  15:./Eigen/src/Core/CoreEvaluators.h **** 
  16:./Eigen/src/Core/CoreEvaluators.h **** namespace Eigen {
  17:./Eigen/src/Core/CoreEvaluators.h **** 
  18:./Eigen/src/Core/CoreEvaluators.h **** namespace internal {
  19:./Eigen/src/Core/CoreEvaluators.h **** 
  20:./Eigen/src/Core/CoreEvaluators.h **** // This class returns the evaluator kind from the expression storage kind.
  21:./Eigen/src/Core/CoreEvaluators.h **** // Default assumes index based accessors
  22:./Eigen/src/Core/CoreEvaluators.h **** template<typename StorageKind>
  23:./Eigen/src/Core/CoreEvaluators.h **** struct storage_kind_to_evaluator_kind {
  24:./Eigen/src/Core/CoreEvaluators.h ****   typedef IndexBased Kind;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 66


  25:./Eigen/src/Core/CoreEvaluators.h **** };
  26:./Eigen/src/Core/CoreEvaluators.h **** 
  27:./Eigen/src/Core/CoreEvaluators.h **** // This class returns the evaluator shape from the expression storage kind.
  28:./Eigen/src/Core/CoreEvaluators.h **** // It can be Dense, Sparse, Triangular, Diagonal, SelfAdjoint, Band, etc.
  29:./Eigen/src/Core/CoreEvaluators.h **** template<typename StorageKind> struct storage_kind_to_shape;
  30:./Eigen/src/Core/CoreEvaluators.h **** 
  31:./Eigen/src/Core/CoreEvaluators.h **** template<> struct storage_kind_to_shape<Dense>                  { typedef DenseShape Shape;        
  32:./Eigen/src/Core/CoreEvaluators.h **** template<> struct storage_kind_to_shape<SolverStorage>          { typedef SolverShape Shape;       
  33:./Eigen/src/Core/CoreEvaluators.h **** template<> struct storage_kind_to_shape<PermutationStorage>     { typedef PermutationShape Shape;  
  34:./Eigen/src/Core/CoreEvaluators.h **** template<> struct storage_kind_to_shape<TranspositionsStorage>  { typedef TranspositionsShape Shape
  35:./Eigen/src/Core/CoreEvaluators.h **** 
  36:./Eigen/src/Core/CoreEvaluators.h **** // Evaluators have to be specialized with respect to various criteria such as:
  37:./Eigen/src/Core/CoreEvaluators.h **** //  - storage/structure/shape
  38:./Eigen/src/Core/CoreEvaluators.h **** //  - scalar type
  39:./Eigen/src/Core/CoreEvaluators.h **** //  - etc.
  40:./Eigen/src/Core/CoreEvaluators.h **** // Therefore, we need specialization of evaluator providing additional template arguments for each 
  41:./Eigen/src/Core/CoreEvaluators.h **** // We currently distinguish the following kind of evaluators:
  42:./Eigen/src/Core/CoreEvaluators.h **** // - unary_evaluator    for expressions taking only one arguments (CwiseUnaryOp, CwiseUnaryView, Tr
  43:./Eigen/src/Core/CoreEvaluators.h **** // - binary_evaluator   for expression taking two arguments (CwiseBinaryOp)
  44:./Eigen/src/Core/CoreEvaluators.h **** // - ternary_evaluator   for expression taking three arguments (CwiseTernaryOp)
  45:./Eigen/src/Core/CoreEvaluators.h **** // - product_evaluator  for linear algebra products (Product); special case of binary_evaluator bec
  46:./Eigen/src/Core/CoreEvaluators.h **** // - mapbase_evaluator  for Map, Block, Ref
  47:./Eigen/src/Core/CoreEvaluators.h **** // - block_evaluator    for Block (special dispatching to a mapbase_evaluator or unary_evaluator)
  48:./Eigen/src/Core/CoreEvaluators.h **** 
  49:./Eigen/src/Core/CoreEvaluators.h **** template< typename T,
  50:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg1Kind   = typename evaluator_traits<typename T::Arg1>::Kind,
  51:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg2Kind   = typename evaluator_traits<typename T::Arg2>::Kind,
  52:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg3Kind   = typename evaluator_traits<typename T::Arg3>::Kind,
  53:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg1Scalar = typename traits<typename T::Arg1>::Scalar,
  54:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg2Scalar = typename traits<typename T::Arg2>::Scalar,
  55:./Eigen/src/Core/CoreEvaluators.h ****           typename Arg3Scalar = typename traits<typename T::Arg3>::Scalar> struct ternary_evaluator
  56:./Eigen/src/Core/CoreEvaluators.h **** 
  57:./Eigen/src/Core/CoreEvaluators.h **** template< typename T,
  58:./Eigen/src/Core/CoreEvaluators.h ****           typename LhsKind   = typename evaluator_traits<typename T::Lhs>::Kind,
  59:./Eigen/src/Core/CoreEvaluators.h ****           typename RhsKind   = typename evaluator_traits<typename T::Rhs>::Kind,
  60:./Eigen/src/Core/CoreEvaluators.h ****           typename LhsScalar = typename traits<typename T::Lhs>::Scalar,
  61:./Eigen/src/Core/CoreEvaluators.h ****           typename RhsScalar = typename traits<typename T::Rhs>::Scalar> struct binary_evaluator;
  62:./Eigen/src/Core/CoreEvaluators.h **** 
  63:./Eigen/src/Core/CoreEvaluators.h **** template< typename T,
  64:./Eigen/src/Core/CoreEvaluators.h ****           typename Kind   = typename evaluator_traits<typename T::NestedExpression>::Kind,
  65:./Eigen/src/Core/CoreEvaluators.h ****           typename Scalar = typename T::Scalar> struct unary_evaluator;
  66:./Eigen/src/Core/CoreEvaluators.h **** 
  67:./Eigen/src/Core/CoreEvaluators.h **** // evaluator_traits<T> contains traits for evaluator<T>
  68:./Eigen/src/Core/CoreEvaluators.h **** 
  69:./Eigen/src/Core/CoreEvaluators.h **** template<typename T>
  70:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator_traits_base
  71:./Eigen/src/Core/CoreEvaluators.h **** {
  72:./Eigen/src/Core/CoreEvaluators.h ****   // by default, get evaluator kind and shape from storage
  73:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename storage_kind_to_evaluator_kind<typename traits<T>::StorageKind>::Kind Kind;
  74:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename storage_kind_to_shape<typename traits<T>::StorageKind>::Shape Shape;
  75:./Eigen/src/Core/CoreEvaluators.h **** };
  76:./Eigen/src/Core/CoreEvaluators.h **** 
  77:./Eigen/src/Core/CoreEvaluators.h **** // Default evaluator traits
  78:./Eigen/src/Core/CoreEvaluators.h **** template<typename T>
  79:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator_traits : public evaluator_traits_base<T>
  80:./Eigen/src/Core/CoreEvaluators.h **** {
  81:./Eigen/src/Core/CoreEvaluators.h **** };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 67


  82:./Eigen/src/Core/CoreEvaluators.h **** 
  83:./Eigen/src/Core/CoreEvaluators.h **** template<typename T, typename Shape = typename evaluator_traits<T>::Shape >
  84:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator_assume_aliasing {
  85:./Eigen/src/Core/CoreEvaluators.h ****   static const bool value = false;
  86:./Eigen/src/Core/CoreEvaluators.h **** };
  87:./Eigen/src/Core/CoreEvaluators.h **** 
  88:./Eigen/src/Core/CoreEvaluators.h **** // By default, we assume a unary expression:
  89:./Eigen/src/Core/CoreEvaluators.h **** template<typename T>
  90:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator : public unary_evaluator<T>
  91:./Eigen/src/Core/CoreEvaluators.h **** {
  92:./Eigen/src/Core/CoreEvaluators.h ****   typedef unary_evaluator<T> Base;
  93:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  94:./Eigen/src/Core/CoreEvaluators.h ****   explicit evaluator(const T& xpr) : Base(xpr) {}
  95:./Eigen/src/Core/CoreEvaluators.h **** };
  96:./Eigen/src/Core/CoreEvaluators.h **** 
  97:./Eigen/src/Core/CoreEvaluators.h **** 
  98:./Eigen/src/Core/CoreEvaluators.h **** // TODO: Think about const-correctness
  99:./Eigen/src/Core/CoreEvaluators.h **** template<typename T>
 100:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator<const T>
 101:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator<T>
 102:./Eigen/src/Core/CoreEvaluators.h **** {
 103:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 104:./Eigen/src/Core/CoreEvaluators.h ****   explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}
 105:./Eigen/src/Core/CoreEvaluators.h **** };
 106:./Eigen/src/Core/CoreEvaluators.h **** 
 107:./Eigen/src/Core/CoreEvaluators.h **** // ---------- base class for all evaluators ----------
 108:./Eigen/src/Core/CoreEvaluators.h **** 
 109:./Eigen/src/Core/CoreEvaluators.h **** template<typename ExpressionType>
 110:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator_base
 111:./Eigen/src/Core/CoreEvaluators.h **** {
 112:./Eigen/src/Core/CoreEvaluators.h ****   // TODO that's not very nice to have to propagate all these traits. They are currently only neede
 113:./Eigen/src/Core/CoreEvaluators.h ****   typedef traits<ExpressionType> ExpressionTraits;
 114:./Eigen/src/Core/CoreEvaluators.h **** 
 115:./Eigen/src/Core/CoreEvaluators.h ****   enum {
 116:./Eigen/src/Core/CoreEvaluators.h ****     Alignment = 0
 117:./Eigen/src/Core/CoreEvaluators.h ****   };
 118:./Eigen/src/Core/CoreEvaluators.h ****   // noncopyable:
 119:./Eigen/src/Core/CoreEvaluators.h ****   // Don't make this class inherit noncopyable as this kills EBO (Empty Base Optimization)
 120:./Eigen/src/Core/CoreEvaluators.h ****   // and make complex evaluator much larger than then should do.
 121:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE evaluator_base() {}
 122:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
 123:./Eigen/src/Core/CoreEvaluators.h **** private:
 124:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC evaluator_base(const evaluator_base&);
 125:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC const evaluator_base& operator=(const evaluator_base&);
 126:./Eigen/src/Core/CoreEvaluators.h **** };
 127:./Eigen/src/Core/CoreEvaluators.h **** 
 128:./Eigen/src/Core/CoreEvaluators.h **** // -------------------- Matrix and Array --------------------
 129:./Eigen/src/Core/CoreEvaluators.h **** //
 130:./Eigen/src/Core/CoreEvaluators.h **** // evaluator<PlainObjectBase> is a common base class for the
 131:./Eigen/src/Core/CoreEvaluators.h **** // Matrix and Array evaluators.
 132:./Eigen/src/Core/CoreEvaluators.h **** // Here we directly specialize evaluator. This is not really a unary expression, and it is, by defi
 133:./Eigen/src/Core/CoreEvaluators.h **** // so no need for more sophisticated dispatching.
 134:./Eigen/src/Core/CoreEvaluators.h **** 
 135:./Eigen/src/Core/CoreEvaluators.h **** // this helper permits to completely eliminate m_outerStride if it is known at compiletime.
 136:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,int OuterStride> class plainobjectbase_evaluator_data {
 137:./Eigen/src/Core/CoreEvaluators.h **** public:
 138:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 68


 139:./Eigen/src/Core/CoreEvaluators.h ****   plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr)
 140:./Eigen/src/Core/CoreEvaluators.h ****   {
 141:./Eigen/src/Core/CoreEvaluators.h **** #ifndef EIGEN_INTERNAL_DEBUGGING
 142:./Eigen/src/Core/CoreEvaluators.h ****     EIGEN_UNUSED_VARIABLE(outerStride);
 143:./Eigen/src/Core/CoreEvaluators.h **** #endif
 144:./Eigen/src/Core/CoreEvaluators.h ****     eigen_internal_assert(outerStride==OuterStride);
 145:./Eigen/src/Core/CoreEvaluators.h ****   }
 146:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
 147:./Eigen/src/Core/CoreEvaluators.h ****   Index outerStride() const EIGEN_NOEXCEPT { return OuterStride; }
 148:./Eigen/src/Core/CoreEvaluators.h ****   const Scalar *data;
 149:./Eigen/src/Core/CoreEvaluators.h **** };
 150:./Eigen/src/Core/CoreEvaluators.h **** 
 151:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar> class plainobjectbase_evaluator_data<Scalar,Dynamic> {
 152:./Eigen/src/Core/CoreEvaluators.h **** public:
 153:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 154:./Eigen/src/Core/CoreEvaluators.h ****   plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr), m_outerStride(o
 155:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 156:./Eigen/src/Core/CoreEvaluators.h ****   Index outerStride() const { return m_outerStride; }
 157:./Eigen/src/Core/CoreEvaluators.h ****   const Scalar *data;
 158:./Eigen/src/Core/CoreEvaluators.h **** protected:
 159:./Eigen/src/Core/CoreEvaluators.h ****   Index m_outerStride;
 160:./Eigen/src/Core/CoreEvaluators.h **** };
 161:./Eigen/src/Core/CoreEvaluators.h **** 
 162:./Eigen/src/Core/CoreEvaluators.h **** template<typename Derived>
 163:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator<PlainObjectBase<Derived> >
 164:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator_base<Derived>
 165:./Eigen/src/Core/CoreEvaluators.h **** {
 166:./Eigen/src/Core/CoreEvaluators.h ****   typedef PlainObjectBase<Derived> PlainObjectType;
 167:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename PlainObjectType::Scalar Scalar;
 168:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;
 169:./Eigen/src/Core/CoreEvaluators.h **** 
 170:./Eigen/src/Core/CoreEvaluators.h ****   enum {
 171:./Eigen/src/Core/CoreEvaluators.h ****     IsRowMajor = PlainObjectType::IsRowMajor,
 172:./Eigen/src/Core/CoreEvaluators.h ****     IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime,
 173:./Eigen/src/Core/CoreEvaluators.h ****     RowsAtCompileTime = PlainObjectType::RowsAtCompileTime,
 174:./Eigen/src/Core/CoreEvaluators.h ****     ColsAtCompileTime = PlainObjectType::ColsAtCompileTime,
 175:./Eigen/src/Core/CoreEvaluators.h **** 
 176:./Eigen/src/Core/CoreEvaluators.h ****     CoeffReadCost = NumTraits<Scalar>::ReadCost,
 177:./Eigen/src/Core/CoreEvaluators.h ****     Flags = traits<Derived>::EvaluatorFlags,
 178:./Eigen/src/Core/CoreEvaluators.h ****     Alignment = traits<Derived>::Alignment
 179:./Eigen/src/Core/CoreEvaluators.h ****   };
 180:./Eigen/src/Core/CoreEvaluators.h ****   enum {
 181:./Eigen/src/Core/CoreEvaluators.h ****     // We do not need to know the outer stride for vectors
 182:./Eigen/src/Core/CoreEvaluators.h ****     OuterStrideAtCompileTime = IsVectorAtCompileTime  ? 0
 183:./Eigen/src/Core/CoreEvaluators.h ****                                                       : int(IsRowMajor) ? ColsAtCompileTime
 184:./Eigen/src/Core/CoreEvaluators.h ****                                                                         : RowsAtCompileTime
 185:./Eigen/src/Core/CoreEvaluators.h ****   };
 186:./Eigen/src/Core/CoreEvaluators.h **** 
 187:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 188:./Eigen/src/Core/CoreEvaluators.h ****   evaluator()
 189:./Eigen/src/Core/CoreEvaluators.h ****     : m_d(0,OuterStrideAtCompileTime)
 190:./Eigen/src/Core/CoreEvaluators.h ****   {
 191:./Eigen/src/Core/CoreEvaluators.h ****     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
 192:./Eigen/src/Core/CoreEvaluators.h ****   }
 193:./Eigen/src/Core/CoreEvaluators.h **** 
 194:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 195:./Eigen/src/Core/CoreEvaluators.h ****   explicit evaluator(const PlainObjectType& m)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 69


 196:./Eigen/src/Core/CoreEvaluators.h ****     : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())
 197:./Eigen/src/Core/CoreEvaluators.h ****   {
 198:./Eigen/src/Core/CoreEvaluators.h ****     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
 199:./Eigen/src/Core/CoreEvaluators.h ****   }
 200:./Eigen/src/Core/CoreEvaluators.h **** 
 201:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 202:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(Index row, Index col) const
 203:./Eigen/src/Core/CoreEvaluators.h ****   {
 204:./Eigen/src/Core/CoreEvaluators.h ****     if (IsRowMajor)
 205:./Eigen/src/Core/CoreEvaluators.h ****       return m_d.data[row * m_d.outerStride() + col];
 206:./Eigen/src/Core/CoreEvaluators.h ****     else
 207:./Eigen/src/Core/CoreEvaluators.h ****       return m_d.data[row + col * m_d.outerStride()];
 208:./Eigen/src/Core/CoreEvaluators.h ****   }
 209:./Eigen/src/Core/CoreEvaluators.h **** 
 210:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 211:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(Index index) const
 212:./Eigen/src/Core/CoreEvaluators.h ****   {
 213:./Eigen/src/Core/CoreEvaluators.h ****     return m_d.data[index];
 214:./Eigen/src/Core/CoreEvaluators.h ****   }
 215:./Eigen/src/Core/CoreEvaluators.h **** 
 216:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 217:./Eigen/src/Core/CoreEvaluators.h ****   Scalar& coeffRef(Index row, Index col)
 218:./Eigen/src/Core/CoreEvaluators.h ****   {
 219:./Eigen/src/Core/CoreEvaluators.h ****     if (IsRowMajor)
 220:./Eigen/src/Core/CoreEvaluators.h ****       return const_cast<Scalar*>(m_d.data)[row * m_d.outerStride() + col];
 221:./Eigen/src/Core/CoreEvaluators.h ****     else
 222:./Eigen/src/Core/CoreEvaluators.h ****       return const_cast<Scalar*>(m_d.data)[row + col * m_d.outerStride()];
 223:./Eigen/src/Core/CoreEvaluators.h ****   }
 224:./Eigen/src/Core/CoreEvaluators.h **** 
 225:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 226:./Eigen/src/Core/CoreEvaluators.h ****   Scalar& coeffRef(Index index)
 433              		.loc 10 226 11 is_stmt 1 view .LVU51
 434              	.LBB347:
 227:./Eigen/src/Core/CoreEvaluators.h ****   {
 228:./Eigen/src/Core/CoreEvaluators.h ****     return const_cast<Scalar*>(m_d.data)[index];
 435              		.loc 10 228 36 is_stmt 0 view .LVU52
 436 0004 1C68     		ldr	r4, [r3]
 437              		.loc 10 228 47 view .LVU53
 438 0006 04EBC104 		add	r4, r4, r1, lsl #3
 439              	.LVL26:
 440              		.loc 10 228 47 view .LVU54
 441              	.LBE347:
 442              	.LBE346:
 443              	.LBB348:
 444              	.LBI348:
 229:./Eigen/src/Core/CoreEvaluators.h ****   }
 230:./Eigen/src/Core/CoreEvaluators.h **** 
 231:./Eigen/src/Core/CoreEvaluators.h ****   template<int LoadMode, typename PacketType>
 232:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 233:./Eigen/src/Core/CoreEvaluators.h ****   PacketType packet(Index row, Index col) const
 234:./Eigen/src/Core/CoreEvaluators.h ****   {
 235:./Eigen/src/Core/CoreEvaluators.h ****     if (IsRowMajor)
 236:./Eigen/src/Core/CoreEvaluators.h ****       return ploadt<PacketType, LoadMode>(m_d.data + row * m_d.outerStride() + col);
 237:./Eigen/src/Core/CoreEvaluators.h ****     else
 238:./Eigen/src/Core/CoreEvaluators.h ****       return ploadt<PacketType, LoadMode>(m_d.data + row + col * m_d.outerStride());
 239:./Eigen/src/Core/CoreEvaluators.h ****   }
 240:./Eigen/src/Core/CoreEvaluators.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 70


 241:./Eigen/src/Core/CoreEvaluators.h ****   template<int LoadMode, typename PacketType>
 242:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 243:./Eigen/src/Core/CoreEvaluators.h ****   PacketType packet(Index index) const
 244:./Eigen/src/Core/CoreEvaluators.h ****   {
 245:./Eigen/src/Core/CoreEvaluators.h ****     return ploadt<PacketType, LoadMode>(m_d.data + index);
 246:./Eigen/src/Core/CoreEvaluators.h ****   }
 247:./Eigen/src/Core/CoreEvaluators.h **** 
 248:./Eigen/src/Core/CoreEvaluators.h ****   template<int StoreMode,typename PacketType>
 249:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 250:./Eigen/src/Core/CoreEvaluators.h ****   void writePacket(Index row, Index col, const PacketType& x)
 251:./Eigen/src/Core/CoreEvaluators.h ****   {
 252:./Eigen/src/Core/CoreEvaluators.h ****     if (IsRowMajor)
 253:./Eigen/src/Core/CoreEvaluators.h ****       return pstoret<Scalar, PacketType, StoreMode>
 254:./Eigen/src/Core/CoreEvaluators.h **** 	            (const_cast<Scalar*>(m_d.data) + row * m_d.outerStride() + col, x);
 255:./Eigen/src/Core/CoreEvaluators.h ****     else
 256:./Eigen/src/Core/CoreEvaluators.h ****       return pstoret<Scalar, PacketType, StoreMode>
 257:./Eigen/src/Core/CoreEvaluators.h ****                     (const_cast<Scalar*>(m_d.data) + row + col * m_d.outerStride(), x);
 258:./Eigen/src/Core/CoreEvaluators.h ****   }
 259:./Eigen/src/Core/CoreEvaluators.h **** 
 260:./Eigen/src/Core/CoreEvaluators.h ****   template<int StoreMode, typename PacketType>
 261:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 262:./Eigen/src/Core/CoreEvaluators.h ****   void writePacket(Index index, const PacketType& x)
 263:./Eigen/src/Core/CoreEvaluators.h ****   {
 264:./Eigen/src/Core/CoreEvaluators.h ****     return pstoret<Scalar, PacketType, StoreMode>(const_cast<Scalar*>(m_d.data) + index, x);
 265:./Eigen/src/Core/CoreEvaluators.h ****   }
 266:./Eigen/src/Core/CoreEvaluators.h **** 
 267:./Eigen/src/Core/CoreEvaluators.h **** protected:
 268:./Eigen/src/Core/CoreEvaluators.h **** 
 269:./Eigen/src/Core/CoreEvaluators.h ****   plainobjectbase_evaluator_data<Scalar,OuterStrideAtCompileTime> m_d;
 270:./Eigen/src/Core/CoreEvaluators.h **** };
 271:./Eigen/src/Core/CoreEvaluators.h **** 
 272:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 273:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
 274:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
 275:./Eigen/src/Core/CoreEvaluators.h **** {
 276:./Eigen/src/Core/CoreEvaluators.h ****   typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
 277:./Eigen/src/Core/CoreEvaluators.h **** 
 278:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 279:./Eigen/src/Core/CoreEvaluators.h ****   evaluator() {}
 280:./Eigen/src/Core/CoreEvaluators.h **** 
 281:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 282:./Eigen/src/Core/CoreEvaluators.h ****   explicit evaluator(const XprType& m)
 283:./Eigen/src/Core/CoreEvaluators.h ****     : evaluator<PlainObjectBase<XprType> >(m)
 284:./Eigen/src/Core/CoreEvaluators.h ****   { }
 285:./Eigen/src/Core/CoreEvaluators.h **** };
 286:./Eigen/src/Core/CoreEvaluators.h **** 
 287:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 288:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
 289:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator<PlainObjectBase<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
 290:./Eigen/src/Core/CoreEvaluators.h **** {
 291:./Eigen/src/Core/CoreEvaluators.h ****   typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
 292:./Eigen/src/Core/CoreEvaluators.h **** 
 293:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 294:./Eigen/src/Core/CoreEvaluators.h ****   evaluator() {}
 295:./Eigen/src/Core/CoreEvaluators.h **** 
 296:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 297:./Eigen/src/Core/CoreEvaluators.h ****   explicit evaluator(const XprType& m)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 71


 298:./Eigen/src/Core/CoreEvaluators.h ****     : evaluator<PlainObjectBase<XprType> >(m)
 299:./Eigen/src/Core/CoreEvaluators.h ****   { }
 300:./Eigen/src/Core/CoreEvaluators.h **** };
 301:./Eigen/src/Core/CoreEvaluators.h **** 
 302:./Eigen/src/Core/CoreEvaluators.h **** // -------------------- Transpose --------------------
 303:./Eigen/src/Core/CoreEvaluators.h **** 
 304:./Eigen/src/Core/CoreEvaluators.h **** template<typename ArgType>
 305:./Eigen/src/Core/CoreEvaluators.h **** struct unary_evaluator<Transpose<ArgType>, IndexBased>
 306:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator_base<Transpose<ArgType> >
 307:./Eigen/src/Core/CoreEvaluators.h **** {
 308:./Eigen/src/Core/CoreEvaluators.h ****   typedef Transpose<ArgType> XprType;
 309:./Eigen/src/Core/CoreEvaluators.h **** 
 310:./Eigen/src/Core/CoreEvaluators.h ****   enum {
 311:./Eigen/src/Core/CoreEvaluators.h ****     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
 312:./Eigen/src/Core/CoreEvaluators.h ****     Flags = evaluator<ArgType>::Flags ^ RowMajorBit,
 313:./Eigen/src/Core/CoreEvaluators.h ****     Alignment = evaluator<ArgType>::Alignment
 314:./Eigen/src/Core/CoreEvaluators.h ****   };
 315:./Eigen/src/Core/CoreEvaluators.h **** 
 316:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 317:./Eigen/src/Core/CoreEvaluators.h ****   explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}
 318:./Eigen/src/Core/CoreEvaluators.h **** 
 319:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename XprType::Scalar Scalar;
 320:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename XprType::CoeffReturnType CoeffReturnType;
 321:./Eigen/src/Core/CoreEvaluators.h **** 
 322:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 323:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(Index row, Index col) const
 324:./Eigen/src/Core/CoreEvaluators.h ****   {
 325:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.coeff(col, row);
 326:./Eigen/src/Core/CoreEvaluators.h ****   }
 327:./Eigen/src/Core/CoreEvaluators.h **** 
 328:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 329:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(Index index) const
 330:./Eigen/src/Core/CoreEvaluators.h ****   {
 331:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.coeff(index);
 332:./Eigen/src/Core/CoreEvaluators.h ****   }
 333:./Eigen/src/Core/CoreEvaluators.h **** 
 334:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 335:./Eigen/src/Core/CoreEvaluators.h ****   Scalar& coeffRef(Index row, Index col)
 336:./Eigen/src/Core/CoreEvaluators.h ****   {
 337:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.coeffRef(col, row);
 338:./Eigen/src/Core/CoreEvaluators.h ****   }
 339:./Eigen/src/Core/CoreEvaluators.h **** 
 340:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 341:./Eigen/src/Core/CoreEvaluators.h ****   typename XprType::Scalar& coeffRef(Index index)
 342:./Eigen/src/Core/CoreEvaluators.h ****   {
 343:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.coeffRef(index);
 344:./Eigen/src/Core/CoreEvaluators.h ****   }
 345:./Eigen/src/Core/CoreEvaluators.h **** 
 346:./Eigen/src/Core/CoreEvaluators.h ****   template<int LoadMode, typename PacketType>
 347:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 348:./Eigen/src/Core/CoreEvaluators.h ****   PacketType packet(Index row, Index col) const
 349:./Eigen/src/Core/CoreEvaluators.h ****   {
 350:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.template packet<LoadMode,PacketType>(col, row);
 351:./Eigen/src/Core/CoreEvaluators.h ****   }
 352:./Eigen/src/Core/CoreEvaluators.h **** 
 353:./Eigen/src/Core/CoreEvaluators.h ****   template<int LoadMode, typename PacketType>
 354:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 72


 355:./Eigen/src/Core/CoreEvaluators.h ****   PacketType packet(Index index) const
 356:./Eigen/src/Core/CoreEvaluators.h ****   {
 357:./Eigen/src/Core/CoreEvaluators.h ****     return m_argImpl.template packet<LoadMode,PacketType>(index);
 358:./Eigen/src/Core/CoreEvaluators.h ****   }
 359:./Eigen/src/Core/CoreEvaluators.h **** 
 360:./Eigen/src/Core/CoreEvaluators.h ****   template<int StoreMode, typename PacketType>
 361:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 362:./Eigen/src/Core/CoreEvaluators.h ****   void writePacket(Index row, Index col, const PacketType& x)
 363:./Eigen/src/Core/CoreEvaluators.h ****   {
 364:./Eigen/src/Core/CoreEvaluators.h ****     m_argImpl.template writePacket<StoreMode,PacketType>(col, row, x);
 365:./Eigen/src/Core/CoreEvaluators.h ****   }
 366:./Eigen/src/Core/CoreEvaluators.h **** 
 367:./Eigen/src/Core/CoreEvaluators.h ****   template<int StoreMode, typename PacketType>
 368:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_STRONG_INLINE
 369:./Eigen/src/Core/CoreEvaluators.h ****   void writePacket(Index index, const PacketType& x)
 370:./Eigen/src/Core/CoreEvaluators.h ****   {
 371:./Eigen/src/Core/CoreEvaluators.h ****     m_argImpl.template writePacket<StoreMode,PacketType>(index, x);
 372:./Eigen/src/Core/CoreEvaluators.h ****   }
 373:./Eigen/src/Core/CoreEvaluators.h **** 
 374:./Eigen/src/Core/CoreEvaluators.h **** protected:
 375:./Eigen/src/Core/CoreEvaluators.h ****   evaluator<ArgType> m_argImpl;
 376:./Eigen/src/Core/CoreEvaluators.h **** };
 377:./Eigen/src/Core/CoreEvaluators.h **** 
 378:./Eigen/src/Core/CoreEvaluators.h **** // -------------------- CwiseNullaryOp --------------------
 379:./Eigen/src/Core/CoreEvaluators.h **** // Like Matrix and Array, this is not really a unary expression, so we directly specialize evaluato
 380:./Eigen/src/Core/CoreEvaluators.h **** // Likewise, there is not need to more sophisticated dispatching here.
 381:./Eigen/src/Core/CoreEvaluators.h **** 
 382:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp,
 383:./Eigen/src/Core/CoreEvaluators.h ****          bool has_nullary = has_nullary_operator<NullaryOp>::value,
 384:./Eigen/src/Core/CoreEvaluators.h ****          bool has_unary   = has_unary_operator<NullaryOp>::value,
 385:./Eigen/src/Core/CoreEvaluators.h ****          bool has_binary  = has_binary_operator<NullaryOp>::value>
 386:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper
 387:./Eigen/src/Core/CoreEvaluators.h **** {
 388:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 389:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexTy
 390:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 391:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i) const {
 392:./Eigen/src/Core/CoreEvaluators.h **** 
 393:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 394:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 395:./Eigen/src/Core/CoreEvaluators.h **** };
 396:./Eigen/src/Core/CoreEvaluators.h **** 
 397:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp>
 398:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper<Scalar,NullaryOp,true,false,false>
 399:./Eigen/src/Core/CoreEvaluators.h **** {
 400:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 401:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType=0, IndexTy
 402:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 403:./Eigen/src/Core/CoreEvaluators.h **** };
 404:./Eigen/src/Core/CoreEvaluators.h **** 
 405:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp>
 406:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper<Scalar,NullaryOp,false,false,true>
 407:./Eigen/src/Core/CoreEvaluators.h **** {
 408:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 409:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexTy
 410:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 411:./Eigen/src/Core/CoreEvaluators.h **** };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 73


 412:./Eigen/src/Core/CoreEvaluators.h **** 
 413:./Eigen/src/Core/CoreEvaluators.h **** // We need the following specialization for vector-only functors assigned to a runtime vector,
 414:./Eigen/src/Core/CoreEvaluators.h **** // for instance, using linspace and assigning a RowVectorXd to a MatrixXd or even a row of a Matrix
 415:./Eigen/src/Core/CoreEvaluators.h **** // In this case, i==0 and j is used for the actual iteration.
 416:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp>
 417:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper<Scalar,NullaryOp,false,true,false>
 418:./Eigen/src/Core/CoreEvaluators.h **** {
 419:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 420:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexTy
 421:./Eigen/src/Core/CoreEvaluators.h ****     eigen_assert(i==0 || j==0);
 422:./Eigen/src/Core/CoreEvaluators.h ****     return op(i+j);
 423:./Eigen/src/Core/CoreEvaluators.h ****   }
 424:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 425:./Eigen/src/Core/CoreEvaluators.h ****     eigen_assert(i==0 || j==0);
 426:./Eigen/src/Core/CoreEvaluators.h ****     return op.template packetOp<T>(i+j);
 427:./Eigen/src/Core/CoreEvaluators.h ****   }
 428:./Eigen/src/Core/CoreEvaluators.h **** 
 429:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 430:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i) const {
 431:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType>
 432:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return
 433:./Eigen/src/Core/CoreEvaluators.h **** };
 434:./Eigen/src/Core/CoreEvaluators.h **** 
 435:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp>
 436:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper<Scalar,NullaryOp,false,false,false> {};
 437:./Eigen/src/Core/CoreEvaluators.h **** 
 438:./Eigen/src/Core/CoreEvaluators.h **** #if 0 && EIGEN_COMP_MSVC>0
 439:./Eigen/src/Core/CoreEvaluators.h **** // Disable this ugly workaround. This is now handled in traits<Ref>::match,
 440:./Eigen/src/Core/CoreEvaluators.h **** // but this piece of code might still become handly if some other weird compilation
 441:./Eigen/src/Core/CoreEvaluators.h **** // erros pop up again.
 442:./Eigen/src/Core/CoreEvaluators.h **** 
 443:./Eigen/src/Core/CoreEvaluators.h **** // MSVC exhibits a weird compilation error when
 444:./Eigen/src/Core/CoreEvaluators.h **** // compiling:
 445:./Eigen/src/Core/CoreEvaluators.h **** //    Eigen::MatrixXf A = MatrixXf::Random(3,3);
 446:./Eigen/src/Core/CoreEvaluators.h **** //    Ref<const MatrixXf> R = 2.f*A;
 447:./Eigen/src/Core/CoreEvaluators.h **** // and that has_*ary_operator<scalar_constant_op<float>> have not been instantiated yet.
 448:./Eigen/src/Core/CoreEvaluators.h **** // The "problem" is that evaluator<2.f*A> is instantiated by traits<Ref>::match<2.f*A>
 449:./Eigen/src/Core/CoreEvaluators.h **** // and at that time has_*ary_operator<T> returns true regardless of T.
 450:./Eigen/src/Core/CoreEvaluators.h **** // Then nullary_wrapper is badly instantiated as nullary_wrapper<.,.,true,true,true>.
 451:./Eigen/src/Core/CoreEvaluators.h **** // The trick is thus to defer the proper instantiation of nullary_wrapper when coeff(),
 452:./Eigen/src/Core/CoreEvaluators.h **** // and packet() are really instantiated as implemented below:
 453:./Eigen/src/Core/CoreEvaluators.h **** 
 454:./Eigen/src/Core/CoreEvaluators.h **** // This is a simple wrapper around Index to enforce the re-instantiation of
 455:./Eigen/src/Core/CoreEvaluators.h **** // has_*ary_operator when needed.
 456:./Eigen/src/Core/CoreEvaluators.h **** template<typename T> struct nullary_wrapper_workaround_msvc {
 457:./Eigen/src/Core/CoreEvaluators.h ****   nullary_wrapper_workaround_msvc(const T&);
 458:./Eigen/src/Core/CoreEvaluators.h ****   operator T()const;
 459:./Eigen/src/Core/CoreEvaluators.h **** };
 460:./Eigen/src/Core/CoreEvaluators.h **** 
 461:./Eigen/src/Core/CoreEvaluators.h **** template<typename Scalar,typename NullaryOp>
 462:./Eigen/src/Core/CoreEvaluators.h **** struct nullary_wrapper<Scalar,NullaryOp,true,true,true>
 463:./Eigen/src/Core/CoreEvaluators.h **** {
 464:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 465:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexTy
 466:./Eigen/src/Core/CoreEvaluators.h ****     return nullary_wrapper<Scalar,NullaryOp,
 467:./Eigen/src/Core/CoreEvaluators.h ****     has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 468:./Eigen/src/Core/CoreEvaluators.h ****     has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 74


 469:./Eigen/src/Core/CoreEvaluators.h ****     has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().operator()
 470:./Eigen/src/Core/CoreEvaluators.h ****   }
 471:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 472:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i) const {
 473:./Eigen/src/Core/CoreEvaluators.h ****     return nullary_wrapper<Scalar,NullaryOp,
 474:./Eigen/src/Core/CoreEvaluators.h ****     has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 475:./Eigen/src/Core/CoreEvaluators.h ****     has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 476:./Eigen/src/Core/CoreEvaluators.h ****     has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().operator()
 477:./Eigen/src/Core/CoreEvaluators.h ****   }
 478:./Eigen/src/Core/CoreEvaluators.h **** 
 479:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType>
 480:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) c
 481:./Eigen/src/Core/CoreEvaluators.h ****     return nullary_wrapper<Scalar,NullaryOp,
 482:./Eigen/src/Core/CoreEvaluators.h ****     has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 483:./Eigen/src/Core/CoreEvaluators.h ****     has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 484:./Eigen/src/Core/CoreEvaluators.h ****     has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().template p
 485:./Eigen/src/Core/CoreEvaluators.h ****   }
 486:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType>
 487:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const {
 488:./Eigen/src/Core/CoreEvaluators.h ****     return nullary_wrapper<Scalar,NullaryOp,
 489:./Eigen/src/Core/CoreEvaluators.h ****     has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 490:./Eigen/src/Core/CoreEvaluators.h ****     has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
 491:./Eigen/src/Core/CoreEvaluators.h ****     has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().template p
 492:./Eigen/src/Core/CoreEvaluators.h ****   }
 493:./Eigen/src/Core/CoreEvaluators.h **** };
 494:./Eigen/src/Core/CoreEvaluators.h **** #endif // MSVC workaround
 495:./Eigen/src/Core/CoreEvaluators.h **** 
 496:./Eigen/src/Core/CoreEvaluators.h **** template<typename NullaryOp, typename PlainObjectType>
 497:./Eigen/src/Core/CoreEvaluators.h **** struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >
 498:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
 499:./Eigen/src/Core/CoreEvaluators.h **** {
 500:./Eigen/src/Core/CoreEvaluators.h ****   typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;
 501:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;
 502:./Eigen/src/Core/CoreEvaluators.h **** 
 503:./Eigen/src/Core/CoreEvaluators.h ****   enum {
 504:./Eigen/src/Core/CoreEvaluators.h ****     CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,
 505:./Eigen/src/Core/CoreEvaluators.h **** 
 506:./Eigen/src/Core/CoreEvaluators.h ****     Flags = (evaluator<PlainObjectTypeCleaned>::Flags
 507:./Eigen/src/Core/CoreEvaluators.h ****           &  (  HereditaryBits
 508:./Eigen/src/Core/CoreEvaluators.h ****               | (functor_has_linear_access<NullaryOp>::ret  ? LinearAccessBit : 0)
 509:./Eigen/src/Core/CoreEvaluators.h ****               | (functor_traits<NullaryOp>::PacketAccess    ? PacketAccessBit : 0)))
 510:./Eigen/src/Core/CoreEvaluators.h ****           | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit),
 511:./Eigen/src/Core/CoreEvaluators.h ****     Alignment = AlignedMax
 512:./Eigen/src/Core/CoreEvaluators.h ****   };
 513:./Eigen/src/Core/CoreEvaluators.h **** 
 514:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC explicit evaluator(const XprType& n)
 515:./Eigen/src/Core/CoreEvaluators.h ****     : m_functor(n.functor()), m_wrapper()
 516:./Eigen/src/Core/CoreEvaluators.h ****   {
 517:./Eigen/src/Core/CoreEvaluators.h ****     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
 518:./Eigen/src/Core/CoreEvaluators.h ****   }
 519:./Eigen/src/Core/CoreEvaluators.h **** 
 520:./Eigen/src/Core/CoreEvaluators.h ****   typedef typename XprType::CoeffReturnType CoeffReturnType;
 521:./Eigen/src/Core/CoreEvaluators.h **** 
 522:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 523:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 524:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(IndexType row, IndexType col) const
 525:./Eigen/src/Core/CoreEvaluators.h ****   {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 75


 526:./Eigen/src/Core/CoreEvaluators.h ****     return m_wrapper(m_functor, row, col);
 527:./Eigen/src/Core/CoreEvaluators.h ****   }
 528:./Eigen/src/Core/CoreEvaluators.h **** 
 529:./Eigen/src/Core/CoreEvaluators.h ****   template <typename IndexType>
 530:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 531:./Eigen/src/Core/CoreEvaluators.h ****   CoeffReturnType coeff(IndexType index) const
 445              		.loc 10 531 19 is_stmt 1 view .LVU55
 446              	.LBB349:
 447              	.LBI349:
 401:./Eigen/src/Core/CoreEvaluators.h ****   template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const 
 448              		.loc 10 401 48 view .LVU56
 449              	.LBB350:
 450              	.LBI350:
  19:./Eigen/src/Core/Random.h ****   inline const Scalar operator() () const { return random<Scalar>(); }
 451              		.loc 6 19 23 view .LVU57
 452              	.LBB351:
 453              	.LBI351:
 835:./Eigen/src/Core/MathFunctions.h **** };
 836:./Eigen/src/Core/MathFunctions.h **** 
 837:./Eigen/src/Core/MathFunctions.h **** enum {
 838:./Eigen/src/Core/MathFunctions.h ****   meta_floor_log2_terminate,
 839:./Eigen/src/Core/MathFunctions.h ****   meta_floor_log2_move_up,
 840:./Eigen/src/Core/MathFunctions.h ****   meta_floor_log2_move_down,
 841:./Eigen/src/Core/MathFunctions.h ****   meta_floor_log2_bogus
 842:./Eigen/src/Core/MathFunctions.h **** };
 843:./Eigen/src/Core/MathFunctions.h **** 
 844:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n, int lower, int upper> struct meta_floor_log2_selector
 845:./Eigen/src/Core/MathFunctions.h **** {
 846:./Eigen/src/Core/MathFunctions.h ****   enum { middle = (lower + upper) / 2,
 847:./Eigen/src/Core/MathFunctions.h ****          value = (upper <= lower + 1) ? int(meta_floor_log2_terminate)
 848:./Eigen/src/Core/MathFunctions.h ****                : (n < (1 << middle)) ? int(meta_floor_log2_move_down)
 849:./Eigen/src/Core/MathFunctions.h ****                : (n==0) ? int(meta_floor_log2_bogus)
 850:./Eigen/src/Core/MathFunctions.h ****                : int(meta_floor_log2_move_up)
 851:./Eigen/src/Core/MathFunctions.h ****   };
 852:./Eigen/src/Core/MathFunctions.h **** };
 853:./Eigen/src/Core/MathFunctions.h **** 
 854:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n,
 855:./Eigen/src/Core/MathFunctions.h ****          int lower = 0,
 856:./Eigen/src/Core/MathFunctions.h ****          int upper = sizeof(unsigned int) * CHAR_BIT - 1,
 857:./Eigen/src/Core/MathFunctions.h ****          int selector = meta_floor_log2_selector<n, lower, upper>::value>
 858:./Eigen/src/Core/MathFunctions.h **** struct meta_floor_log2 {};
 859:./Eigen/src/Core/MathFunctions.h **** 
 860:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n, int lower, int upper>
 861:./Eigen/src/Core/MathFunctions.h **** struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_down>
 862:./Eigen/src/Core/MathFunctions.h **** {
 863:./Eigen/src/Core/MathFunctions.h ****   enum { value = meta_floor_log2<n, lower, meta_floor_log2_selector<n, lower, upper>::middle>::valu
 864:./Eigen/src/Core/MathFunctions.h **** };
 865:./Eigen/src/Core/MathFunctions.h **** 
 866:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n, int lower, int upper>
 867:./Eigen/src/Core/MathFunctions.h **** struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_up>
 868:./Eigen/src/Core/MathFunctions.h **** {
 869:./Eigen/src/Core/MathFunctions.h ****   enum { value = meta_floor_log2<n, meta_floor_log2_selector<n, lower, upper>::middle, upper>::valu
 870:./Eigen/src/Core/MathFunctions.h **** };
 871:./Eigen/src/Core/MathFunctions.h **** 
 872:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n, int lower, int upper>
 873:./Eigen/src/Core/MathFunctions.h **** struct meta_floor_log2<n, lower, upper, meta_floor_log2_terminate>
 874:./Eigen/src/Core/MathFunctions.h **** {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 76


 875:./Eigen/src/Core/MathFunctions.h ****   enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };
 876:./Eigen/src/Core/MathFunctions.h **** };
 877:./Eigen/src/Core/MathFunctions.h **** 
 878:./Eigen/src/Core/MathFunctions.h **** template<unsigned int n, int lower, int upper>
 879:./Eigen/src/Core/MathFunctions.h **** struct meta_floor_log2<n, lower, upper, meta_floor_log2_bogus>
 880:./Eigen/src/Core/MathFunctions.h **** {
 881:./Eigen/src/Core/MathFunctions.h ****   // no value, error at compile time
 882:./Eigen/src/Core/MathFunctions.h **** };
 883:./Eigen/src/Core/MathFunctions.h **** 
 884:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 885:./Eigen/src/Core/MathFunctions.h **** struct random_default_impl<Scalar, false, true>
 886:./Eigen/src/Core/MathFunctions.h **** {
 887:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x, const Scalar& y)
 888:./Eigen/src/Core/MathFunctions.h ****   {
 889:./Eigen/src/Core/MathFunctions.h ****     if (y <= x)
 890:./Eigen/src/Core/MathFunctions.h ****       return x;
 891:./Eigen/src/Core/MathFunctions.h ****     // ScalarU is the unsigned counterpart of Scalar, possibly Scalar itself.
 892:./Eigen/src/Core/MathFunctions.h ****     typedef typename make_unsigned<Scalar>::type ScalarU;
 893:./Eigen/src/Core/MathFunctions.h ****     // ScalarX is the widest of ScalarU and unsigned int.
 894:./Eigen/src/Core/MathFunctions.h ****     // We'll deal only with ScalarX and unsigned int below thus avoiding signed
 895:./Eigen/src/Core/MathFunctions.h ****     // types and arithmetic and signed overflows (which are undefined behavior).
 896:./Eigen/src/Core/MathFunctions.h ****     typedef typename conditional<(ScalarU(-1) > unsigned(-1)), ScalarU, unsigned>::type ScalarX;
 897:./Eigen/src/Core/MathFunctions.h ****     // The following difference doesn't overflow, provided our integer types are two's
 898:./Eigen/src/Core/MathFunctions.h ****     // complement and have the same number of padding bits in signed and unsigned variants.
 899:./Eigen/src/Core/MathFunctions.h ****     // This is the case in most modern implementations of C++.
 900:./Eigen/src/Core/MathFunctions.h ****     ScalarX range = ScalarX(y) - ScalarX(x);
 901:./Eigen/src/Core/MathFunctions.h ****     ScalarX offset = 0;
 902:./Eigen/src/Core/MathFunctions.h ****     ScalarX divisor = 1;
 903:./Eigen/src/Core/MathFunctions.h ****     ScalarX multiplier = 1;
 904:./Eigen/src/Core/MathFunctions.h ****     const unsigned rand_max = RAND_MAX;
 905:./Eigen/src/Core/MathFunctions.h ****     if (range <= rand_max) divisor = (rand_max + 1) / (range + 1);
 906:./Eigen/src/Core/MathFunctions.h ****     else                   multiplier = 1 + range / (rand_max + 1);
 907:./Eigen/src/Core/MathFunctions.h ****     // Rejection sampling.
 908:./Eigen/src/Core/MathFunctions.h ****     do {
 909:./Eigen/src/Core/MathFunctions.h ****       offset = (unsigned(std::rand()) * multiplier) / divisor;
 910:./Eigen/src/Core/MathFunctions.h ****     } while (offset > range);
 911:./Eigen/src/Core/MathFunctions.h ****     return Scalar(ScalarX(x) + offset);
 912:./Eigen/src/Core/MathFunctions.h ****   }
 913:./Eigen/src/Core/MathFunctions.h **** 
 914:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run()
 915:./Eigen/src/Core/MathFunctions.h ****   {
 916:./Eigen/src/Core/MathFunctions.h **** #ifdef EIGEN_MAKING_DOCS
 917:./Eigen/src/Core/MathFunctions.h ****     return run(Scalar(NumTraits<Scalar>::IsSigned ? -10 : 0), Scalar(10));
 918:./Eigen/src/Core/MathFunctions.h **** #else
 919:./Eigen/src/Core/MathFunctions.h ****     enum { rand_bits = meta_floor_log2<(unsigned int)(RAND_MAX)+1>::value,
 920:./Eigen/src/Core/MathFunctions.h ****            scalar_bits = sizeof(Scalar) * CHAR_BIT,
 921:./Eigen/src/Core/MathFunctions.h ****            shift = EIGEN_PLAIN_ENUM_MAX(0, int(rand_bits) - int(scalar_bits)),
 922:./Eigen/src/Core/MathFunctions.h ****            offset = NumTraits<Scalar>::IsSigned ? (1 << (EIGEN_PLAIN_ENUM_MIN(rand_bits,scalar_bits
 923:./Eigen/src/Core/MathFunctions.h ****     };
 924:./Eigen/src/Core/MathFunctions.h ****     return Scalar((std::rand() >> shift) - offset);
 925:./Eigen/src/Core/MathFunctions.h **** #endif
 926:./Eigen/src/Core/MathFunctions.h ****   }
 927:./Eigen/src/Core/MathFunctions.h **** };
 928:./Eigen/src/Core/MathFunctions.h **** 
 929:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 930:./Eigen/src/Core/MathFunctions.h **** struct random_default_impl<Scalar, true, false>
 931:./Eigen/src/Core/MathFunctions.h **** {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 77


 932:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run(const Scalar& x, const Scalar& y)
 933:./Eigen/src/Core/MathFunctions.h ****   {
 934:./Eigen/src/Core/MathFunctions.h ****     return Scalar(random(x.real(), y.real()),
 935:./Eigen/src/Core/MathFunctions.h ****                   random(x.imag(), y.imag()));
 936:./Eigen/src/Core/MathFunctions.h ****   }
 937:./Eigen/src/Core/MathFunctions.h ****   static inline Scalar run()
 938:./Eigen/src/Core/MathFunctions.h ****   {
 939:./Eigen/src/Core/MathFunctions.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 940:./Eigen/src/Core/MathFunctions.h ****     return Scalar(random<RealScalar>(), random<RealScalar>());
 941:./Eigen/src/Core/MathFunctions.h ****   }
 942:./Eigen/src/Core/MathFunctions.h **** };
 943:./Eigen/src/Core/MathFunctions.h **** 
 944:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 945:./Eigen/src/Core/MathFunctions.h **** inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)
 946:./Eigen/src/Core/MathFunctions.h **** {
 947:./Eigen/src/Core/MathFunctions.h ****   return EIGEN_MATHFUNC_IMPL(random, Scalar)::run(x, y);
 948:./Eigen/src/Core/MathFunctions.h **** }
 949:./Eigen/src/Core/MathFunctions.h **** 
 950:./Eigen/src/Core/MathFunctions.h **** template<typename Scalar>
 951:./Eigen/src/Core/MathFunctions.h **** inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()
 454              		.loc 8 951 46 view .LVU58
 455              	.LBB352:
 952:./Eigen/src/Core/MathFunctions.h **** {
 953:./Eigen/src/Core/MathFunctions.h ****   return EIGEN_MATHFUNC_IMPL(random, Scalar)::run();
 456              		.loc 8 953 50 is_stmt 0 view .LVU59
 457 000a FFF7FEFF 		bl	_ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv
 458              	.LVL27:
 459              		.loc 8 953 50 view .LVU60
 460              	.LBE352:
 461              	.LBE351:
 462              	.LBE350:
 463              	.LBE349:
 464              	.LBE348:
 465              	.LBB353:
 466              	.LBI353:
 467              		.file 11 "./Eigen/src/Core/functors/AssignmentFunctors.h"
   1:./Eigen/src/Core/functors/AssignmentFunctors.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/functors/AssignmentFunctors.h **** // for linear algebra.
   3:./Eigen/src/Core/functors/AssignmentFunctors.h **** //
   4:./Eigen/src/Core/functors/AssignmentFunctors.h **** // Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/functors/AssignmentFunctors.h **** //
   6:./Eigen/src/Core/functors/AssignmentFunctors.h **** // This Source Code Form is subject to the terms of the Mozilla
   7:./Eigen/src/Core/functors/AssignmentFunctors.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   8:./Eigen/src/Core/functors/AssignmentFunctors.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
   9:./Eigen/src/Core/functors/AssignmentFunctors.h **** 
  10:./Eigen/src/Core/functors/AssignmentFunctors.h **** #ifndef EIGEN_ASSIGNMENT_FUNCTORS_H
  11:./Eigen/src/Core/functors/AssignmentFunctors.h **** #define EIGEN_ASSIGNMENT_FUNCTORS_H
  12:./Eigen/src/Core/functors/AssignmentFunctors.h **** 
  13:./Eigen/src/Core/functors/AssignmentFunctors.h **** namespace Eigen {
  14:./Eigen/src/Core/functors/AssignmentFunctors.h **** 
  15:./Eigen/src/Core/functors/AssignmentFunctors.h **** namespace internal {
  16:./Eigen/src/Core/functors/AssignmentFunctors.h ****   
  17:./Eigen/src/Core/functors/AssignmentFunctors.h **** /** \internal
  18:./Eigen/src/Core/functors/AssignmentFunctors.h ****   * \brief Template functor for scalar/packet assignment
  19:./Eigen/src/Core/functors/AssignmentFunctors.h ****   *
  20:./Eigen/src/Core/functors/AssignmentFunctors.h ****   */
  21:./Eigen/src/Core/functors/AssignmentFunctors.h **** template<typename DstScalar,typename SrcScalar> struct assign_op {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 78


  22:./Eigen/src/Core/functors/AssignmentFunctors.h **** 
  23:./Eigen/src/Core/functors/AssignmentFunctors.h ****   EIGEN_EMPTY_STRUCT_CTOR(assign_op)
  24:./Eigen/src/Core/functors/AssignmentFunctors.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { 
 468              		.loc 11 24 46 is_stmt 1 view .LVU61
 469              	.LBB354:
 470              		.loc 11 24 102 is_stmt 0 view .LVU62
 471 000e 84ED000B 		vstr.64	d0, [r4]
 472              	.LVL28:
 473              		.loc 11 24 102 view .LVU63
 474              	.LBE354:
 475              	.LBE353:
 661:./Eigen/src/Core/AssignEvaluator.h ****   }
 476              		.loc 9 661 3 view .LVU64
 477 0012 10BD     		pop	{r4, pc}
 478              		.cfi_endproc
 479              	.LFE9519:
 480              		.cantunwind
 481              		.fnend
 483              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 484              		.align	1
 485              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 486              		.syntax unified
 487              		.thumb
 488              		.thumb_func
 490              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 491              		.fnstart
 492              	.LVL29:
 493              	.LFB9541:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 494              		.loc 9 245 53 is_stmt 1 view -0
 495              		.cfi_startproc
 496              		@ args = 0, pretend = 0, frame = 0
 497              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 498              		.loc 9 245 53 is_stmt 0 view .LVU66
 499 0000 10B5     		push	{r4, lr}
 500              	.LCFI8:
 501              		.cfi_def_cfa_offset 8
 502              		.cfi_offset 4, -8
 503              		.cfi_offset 14, -4
 504 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 505              		.loc 9 247 23 view .LVU67
 506 0004 0721     		movs	r1, #7
 507 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 508              	.LVL30:
 509              	.LBB355:
 510              	.LBI355:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 511              		.loc 9 245 53 is_stmt 1 view .LVU68
 512              	.LBB356:
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 513              		.loc 9 247 23 is_stmt 0 view .LVU69
 514 000a 0821     		movs	r1, #8
 515 000c 2046     		mov	r0, r4
 516 000e FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 517              	.LVL31:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 79


 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 518              		.loc 9 247 23 view .LVU70
 519              	.LBE356:
 520              	.LBE355:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 521              		.loc 9 249 3 view .LVU71
 522 0012 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 523              		.loc 9 249 3 view .LVU72
 524              		.cfi_endproc
 525              	.LFE9541:
 526              		.cantunwind
 527              		.fnend
 529              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 530              		.align	1
 531              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 532              		.syntax unified
 533              		.thumb
 534              		.thumb_func
 536              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 537              		.fnstart
 538              	.LVL32:
 539              	.LFB9539:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 540              		.loc 9 245 53 is_stmt 1 view -0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 0
 543              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 544              		.loc 9 245 53 is_stmt 0 view .LVU74
 545 0000 10B5     		push	{r4, lr}
 546              	.LCFI9:
 547              		.cfi_def_cfa_offset 8
 548              		.cfi_offset 4, -8
 549              		.cfi_offset 14, -4
 550 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 551              		.loc 9 247 23 view .LVU75
 552 0004 0621     		movs	r1, #6
 553 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 554              	.LVL33:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 555              		.loc 9 248 87 view .LVU76
 556 000a 2046     		mov	r0, r4
 557 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 558              	.LVL34:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 559              		.loc 9 249 3 view .LVU77
 560 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 561              		.loc 9 249 3 view .LVU78
 562              		.cfi_endproc
 563              	.LFE9539:
 564              		.cantunwind
 565              		.fnend
 567              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 568              		.align	1
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 80


 569              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 570              		.syntax unified
 571              		.thumb
 572              		.thumb_func
 574              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 575              		.fnstart
 576              	.LVL35:
 577              	.LFB9537:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 578              		.loc 9 245 53 is_stmt 1 view -0
 579              		.cfi_startproc
 580              		@ args = 0, pretend = 0, frame = 0
 581              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 582              		.loc 9 245 53 is_stmt 0 view .LVU80
 583 0000 10B5     		push	{r4, lr}
 584              	.LCFI10:
 585              		.cfi_def_cfa_offset 8
 586              		.cfi_offset 4, -8
 587              		.cfi_offset 14, -4
 588 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 589              		.loc 9 247 23 view .LVU81
 590 0004 0521     		movs	r1, #5
 591 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 592              	.LVL36:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 593              		.loc 9 248 87 view .LVU82
 594 000a 2046     		mov	r0, r4
 595 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 596              	.LVL37:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 597              		.loc 9 249 3 view .LVU83
 598 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 599              		.loc 9 249 3 view .LVU84
 600              		.cfi_endproc
 601              	.LFE9537:
 602              		.cantunwind
 603              		.fnend
 605              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 606              		.align	1
 607              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 608              		.syntax unified
 609              		.thumb
 610              		.thumb_func
 612              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 613              		.fnstart
 614              	.LVL38:
 615              	.LFB9535:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 616              		.loc 9 245 53 is_stmt 1 view -0
 617              		.cfi_startproc
 618              		@ args = 0, pretend = 0, frame = 0
 619              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 620              		.loc 9 245 53 is_stmt 0 view .LVU86
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 81


 621 0000 10B5     		push	{r4, lr}
 622              	.LCFI11:
 623              		.cfi_def_cfa_offset 8
 624              		.cfi_offset 4, -8
 625              		.cfi_offset 14, -4
 626 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 627              		.loc 9 247 23 view .LVU87
 628 0004 0421     		movs	r1, #4
 629 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 630              	.LVL39:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 631              		.loc 9 248 87 view .LVU88
 632 000a 2046     		mov	r0, r4
 633 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 634              	.LVL40:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 635              		.loc 9 249 3 view .LVU89
 636 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 637              		.loc 9 249 3 view .LVU90
 638              		.cfi_endproc
 639              	.LFE9535:
 640              		.cantunwind
 641              		.fnend
 643              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 644              		.align	1
 645              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 646              		.syntax unified
 647              		.thumb
 648              		.thumb_func
 650              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 651              		.fnstart
 652              	.LVL41:
 653              	.LFB9530:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 654              		.loc 9 245 53 is_stmt 1 view -0
 655              		.cfi_startproc
 656              		@ args = 0, pretend = 0, frame = 0
 657              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 658              		.loc 9 245 53 is_stmt 0 view .LVU92
 659 0000 10B5     		push	{r4, lr}
 660              	.LCFI12:
 661              		.cfi_def_cfa_offset 8
 662              		.cfi_offset 4, -8
 663              		.cfi_offset 14, -4
 664 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 665              		.loc 9 247 23 view .LVU93
 666 0004 0321     		movs	r1, #3
 667 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 668              	.LVL42:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 669              		.loc 9 248 87 view .LVU94
 670 000a 2046     		mov	r0, r4
 671 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 82


 672              	.LVL43:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 673              		.loc 9 249 3 view .LVU95
 674 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 675              		.loc 9 249 3 view .LVU96
 676              		.cfi_endproc
 677              	.LFE9530:
 678              		.cantunwind
 679              		.fnend
 681              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 682              		.align	1
 683              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 684              		.syntax unified
 685              		.thumb
 686              		.thumb_func
 688              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 689              		.fnstart
 690              	.LVL44:
 691              	.LFB9527:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 692              		.loc 9 245 53 is_stmt 1 view -0
 693              		.cfi_startproc
 694              		@ args = 0, pretend = 0, frame = 0
 695              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 696              		.loc 9 245 53 is_stmt 0 view .LVU98
 697 0000 10B5     		push	{r4, lr}
 698              	.LCFI13:
 699              		.cfi_def_cfa_offset 8
 700              		.cfi_offset 4, -8
 701              		.cfi_offset 14, -4
 702 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 703              		.loc 9 247 23 view .LVU99
 704 0004 0221     		movs	r1, #2
 705 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 706              	.LVL45:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 707              		.loc 9 248 87 view .LVU100
 708 000a 2046     		mov	r0, r4
 709 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 710              	.LVL46:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 711              		.loc 9 249 3 view .LVU101
 712 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 713              		.loc 9 249 3 view .LVU102
 714              		.cfi_endproc
 715              	.LFE9527:
 716              		.cantunwind
 717              		.fnend
 719              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 720              		.align	1
 721              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 722              		.syntax unified
 723              		.thumb
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 83


 724              		.thumb_func
 726              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 727              		.fnstart
 728              	.LVL47:
 729              	.LFB9520:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 730              		.loc 9 245 53 is_stmt 1 view -0
 731              		.cfi_startproc
 732              		@ args = 0, pretend = 0, frame = 0
 733              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 734              		.loc 9 245 53 is_stmt 0 view .LVU104
 735 0000 10B5     		push	{r4, lr}
 736              	.LCFI14:
 737              		.cfi_def_cfa_offset 8
 738              		.cfi_offset 4, -8
 739              		.cfi_offset 14, -4
 740 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 741              		.loc 9 247 23 view .LVU105
 742 0004 0121     		movs	r1, #1
 743 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 744              	.LVL48:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 745              		.loc 9 248 87 view .LVU106
 746 000a 2046     		mov	r0, r4
 747 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 748              	.LVL49:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 749              		.loc 9 249 3 view .LVU107
 750 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 751              		.loc 9 249 3 view .LVU108
 752              		.cfi_endproc
 753              	.LFE9520:
 754              		.cantunwind
 755              		.fnend
 757              		.section	.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31ge
 758              		.align	1
 759              		.weak	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_den
 760              		.syntax unified
 761              		.thumb
 762              		.thumb_func
 764              	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assi
 765              		.fnstart
 766              	.LVL50:
 767              	.LFB9510:
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 768              		.loc 9 245 53 is_stmt 1 view -0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 245:./Eigen/src/Core/AssignEvaluator.h ****   {
 772              		.loc 9 245 53 is_stmt 0 view .LVU110
 773 0000 10B5     		push	{r4, lr}
 774              	.LCFI15:
 775              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 84


 776              		.cfi_offset 4, -8
 777              		.cfi_offset 14, -4
 778 0002 0446     		mov	r4, r0
 247:./Eigen/src/Core/AssignEvaluator.h ****     copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);
 779              		.loc 9 247 23 view .LVU111
 780 0004 0021     		movs	r1, #0
 781 0006 FFF7FEFF 		bl	_ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3E
 782              	.LVL51:
 248:./Eigen/src/Core/AssignEvaluator.h ****   }
 783              		.loc 9 248 87 view .LVU112
 784 000a 2046     		mov	r0, r4
 785 000c FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 786              	.LVL52:
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 787              		.loc 9 249 3 view .LVU113
 788 0010 10BD     		pop	{r4, pc}
 249:./Eigen/src/Core/AssignEvaluator.h **** };
 789              		.loc 9 249 3 view .LVU114
 790              		.cfi_endproc
 791              	.LFE9510:
 792              		.cantunwind
 793              		.fnend
 795              		.section	.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14C
 796              		.align	1
 797              		.weak	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNulla
 798              		.syntax unified
 799              		.thumb
 800              		.thumb_func
 802              	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryOpINS
 803              		.fnstart
 804              	.LVL53:
 805              	.LFB9342:
 274:./Eigen/src/Core/PlainObjectBase.h ****                    && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime)
 275:./Eigen/src/Core/PlainObjectBase.h ****                    && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,row
 276:./Eigen/src/Core/PlainObjectBase.h ****                    && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,col
 277:./Eigen/src/Core/PlainObjectBase.h ****                    && rows>=0 && cols>=0 && "Invalid sizes when resizing a matrix or array.");
 278:./Eigen/src/Core/PlainObjectBase.h ****       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(rows, cols);
 279:./Eigen/src/Core/PlainObjectBase.h ****       #ifdef EIGEN_INITIALIZE_COEFFS
 280:./Eigen/src/Core/PlainObjectBase.h ****         Index size = rows*cols;
 281:./Eigen/src/Core/PlainObjectBase.h ****         bool size_changed = size != this->size();
 282:./Eigen/src/Core/PlainObjectBase.h ****         m_storage.resize(size, rows, cols);
 283:./Eigen/src/Core/PlainObjectBase.h ****         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 284:./Eigen/src/Core/PlainObjectBase.h ****       #else
 285:./Eigen/src/Core/PlainObjectBase.h ****         m_storage.resize(rows*cols, rows, cols);
 286:./Eigen/src/Core/PlainObjectBase.h ****       #endif
 287:./Eigen/src/Core/PlainObjectBase.h ****     }
 288:./Eigen/src/Core/PlainObjectBase.h **** 
 289:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes \c *this to a vector of length \a size
 290:./Eigen/src/Core/PlainObjectBase.h ****       *
 291:./Eigen/src/Core/PlainObjectBase.h ****       * \only_for_vectors. This method does not work for
 292:./Eigen/src/Core/PlainObjectBase.h ****       * partially dynamic matrices when the static dimension is anything other
 293:./Eigen/src/Core/PlainObjectBase.h ****       * than 1. For example it will not work with Matrix<double, 2, Dynamic>.
 294:./Eigen/src/Core/PlainObjectBase.h ****       *
 295:./Eigen/src/Core/PlainObjectBase.h ****       * Example: \include Matrix_resize_int.cpp
 296:./Eigen/src/Core/PlainObjectBase.h ****       * Output: \verbinclude Matrix_resize_int.out
 297:./Eigen/src/Core/PlainObjectBase.h ****       *
 298:./Eigen/src/Core/PlainObjectBase.h ****       * \sa resize(Index,Index), resize(NoChange_t, Index), resize(Index, NoChange_t)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 85


 299:./Eigen/src/Core/PlainObjectBase.h ****       */
 300:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 301:./Eigen/src/Core/PlainObjectBase.h ****     inline void resize(Index size)
 302:./Eigen/src/Core/PlainObjectBase.h ****     {
 303:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
 304:./Eigen/src/Core/PlainObjectBase.h ****       eigen_assert(((SizeAtCompileTime == Dynamic && (MaxSizeAtCompileTime==Dynamic || size<=MaxSiz
 305:./Eigen/src/Core/PlainObjectBase.h ****       #ifdef EIGEN_INITIALIZE_COEFFS
 306:./Eigen/src/Core/PlainObjectBase.h ****         bool size_changed = size != this->size();
 307:./Eigen/src/Core/PlainObjectBase.h ****       #endif
 308:./Eigen/src/Core/PlainObjectBase.h ****       if(RowsAtCompileTime == 1)
 309:./Eigen/src/Core/PlainObjectBase.h ****         m_storage.resize(size, 1, size);
 310:./Eigen/src/Core/PlainObjectBase.h ****       else
 311:./Eigen/src/Core/PlainObjectBase.h ****         m_storage.resize(size, size, 1);
 312:./Eigen/src/Core/PlainObjectBase.h ****       #ifdef EIGEN_INITIALIZE_COEFFS
 313:./Eigen/src/Core/PlainObjectBase.h ****         if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 314:./Eigen/src/Core/PlainObjectBase.h ****       #endif
 315:./Eigen/src/Core/PlainObjectBase.h ****     }
 316:./Eigen/src/Core/PlainObjectBase.h **** 
 317:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix, changing only the number of columns. For the parameter of type NoChange
 318:./Eigen/src/Core/PlainObjectBase.h ****       * as in the example below.
 319:./Eigen/src/Core/PlainObjectBase.h ****       *
 320:./Eigen/src/Core/PlainObjectBase.h ****       * Example: \include Matrix_resize_NoChange_int.cpp
 321:./Eigen/src/Core/PlainObjectBase.h ****       * Output: \verbinclude Matrix_resize_NoChange_int.out
 322:./Eigen/src/Core/PlainObjectBase.h ****       *
 323:./Eigen/src/Core/PlainObjectBase.h ****       * \sa resize(Index,Index)
 324:./Eigen/src/Core/PlainObjectBase.h ****       */
 325:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 326:./Eigen/src/Core/PlainObjectBase.h ****     inline void resize(NoChange_t, Index cols)
 327:./Eigen/src/Core/PlainObjectBase.h ****     {
 328:./Eigen/src/Core/PlainObjectBase.h ****       resize(rows(), cols);
 329:./Eigen/src/Core/PlainObjectBase.h ****     }
 330:./Eigen/src/Core/PlainObjectBase.h **** 
 331:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix, changing only the number of rows. For the parameter of type NoChange_t,
 332:./Eigen/src/Core/PlainObjectBase.h ****       * as in the example below.
 333:./Eigen/src/Core/PlainObjectBase.h ****       *
 334:./Eigen/src/Core/PlainObjectBase.h ****       * Example: \include Matrix_resize_int_NoChange.cpp
 335:./Eigen/src/Core/PlainObjectBase.h ****       * Output: \verbinclude Matrix_resize_int_NoChange.out
 336:./Eigen/src/Core/PlainObjectBase.h ****       *
 337:./Eigen/src/Core/PlainObjectBase.h ****       * \sa resize(Index,Index)
 338:./Eigen/src/Core/PlainObjectBase.h ****       */
 339:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 340:./Eigen/src/Core/PlainObjectBase.h ****     inline void resize(Index rows, NoChange_t)
 341:./Eigen/src/Core/PlainObjectBase.h ****     {
 342:./Eigen/src/Core/PlainObjectBase.h ****       resize(rows, cols());
 343:./Eigen/src/Core/PlainObjectBase.h ****     }
 344:./Eigen/src/Core/PlainObjectBase.h **** 
 345:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes \c *this to have the same dimensions as \a other.
 346:./Eigen/src/Core/PlainObjectBase.h ****       * Takes care of doing all the checking that's needed.
 347:./Eigen/src/Core/PlainObjectBase.h ****       *
 348:./Eigen/src/Core/PlainObjectBase.h ****       * Note that copying a row-vector into a vector (and conversely) is allowed.
 349:./Eigen/src/Core/PlainObjectBase.h ****       * The resizing, if any, is then done in the appropriate way so that row-vectors
 350:./Eigen/src/Core/PlainObjectBase.h ****       * remain row-vectors and vectors remain vectors.
 351:./Eigen/src/Core/PlainObjectBase.h ****       */
 352:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 353:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 354:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)
 355:./Eigen/src/Core/PlainObjectBase.h ****     {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 86


 356:./Eigen/src/Core/PlainObjectBase.h ****       const OtherDerived& other = _other.derived();
 357:./Eigen/src/Core/PlainObjectBase.h ****       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols())
 358:./Eigen/src/Core/PlainObjectBase.h ****       const Index othersize = other.rows()*other.cols();
 359:./Eigen/src/Core/PlainObjectBase.h ****       if(RowsAtCompileTime == 1)
 360:./Eigen/src/Core/PlainObjectBase.h ****       {
 361:./Eigen/src/Core/PlainObjectBase.h ****         eigen_assert(other.rows() == 1 || other.cols() == 1);
 362:./Eigen/src/Core/PlainObjectBase.h ****         resize(1, othersize);
 363:./Eigen/src/Core/PlainObjectBase.h ****       }
 364:./Eigen/src/Core/PlainObjectBase.h ****       else if(ColsAtCompileTime == 1)
 365:./Eigen/src/Core/PlainObjectBase.h ****       {
 366:./Eigen/src/Core/PlainObjectBase.h ****         eigen_assert(other.rows() == 1 || other.cols() == 1);
 367:./Eigen/src/Core/PlainObjectBase.h ****         resize(othersize, 1);
 368:./Eigen/src/Core/PlainObjectBase.h ****       }
 369:./Eigen/src/Core/PlainObjectBase.h ****       else resize(other.rows(), other.cols());
 370:./Eigen/src/Core/PlainObjectBase.h ****     }
 371:./Eigen/src/Core/PlainObjectBase.h **** 
 372:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
 373:./Eigen/src/Core/PlainObjectBase.h ****       *
 374:./Eigen/src/Core/PlainObjectBase.h ****       * The method is intended for matrices of dynamic size. If you only want to change the number
 375:./Eigen/src/Core/PlainObjectBase.h ****       * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
 376:./Eigen/src/Core/PlainObjectBase.h ****       * conservativeResize(Index, NoChange_t).
 377:./Eigen/src/Core/PlainObjectBase.h ****       *
 378:./Eigen/src/Core/PlainObjectBase.h ****       * Matrices are resized relative to the top-left element. In case values need to be
 379:./Eigen/src/Core/PlainObjectBase.h ****       * appended to the matrix they will be uninitialized.
 380:./Eigen/src/Core/PlainObjectBase.h ****       */
 381:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 382:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)
 383:./Eigen/src/Core/PlainObjectBase.h ****     {
 384:./Eigen/src/Core/PlainObjectBase.h ****       internal::conservative_resize_like_impl<Derived>::run(*this, rows, cols);
 385:./Eigen/src/Core/PlainObjectBase.h ****     }
 386:./Eigen/src/Core/PlainObjectBase.h **** 
 387:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
 388:./Eigen/src/Core/PlainObjectBase.h ****       *
 389:./Eigen/src/Core/PlainObjectBase.h ****       * As opposed to conservativeResize(Index rows, Index cols), this version leaves
 390:./Eigen/src/Core/PlainObjectBase.h ****       * the number of columns unchanged.
 391:./Eigen/src/Core/PlainObjectBase.h ****       *
 392:./Eigen/src/Core/PlainObjectBase.h ****       * In case the matrix is growing, new rows will be uninitialized.
 393:./Eigen/src/Core/PlainObjectBase.h ****       */
 394:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 395:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)
 396:./Eigen/src/Core/PlainObjectBase.h ****     {
 397:./Eigen/src/Core/PlainObjectBase.h ****       // Note: see the comment in conservativeResize(Index,Index)
 398:./Eigen/src/Core/PlainObjectBase.h ****       conservativeResize(rows, cols());
 399:./Eigen/src/Core/PlainObjectBase.h ****     }
 400:./Eigen/src/Core/PlainObjectBase.h **** 
 401:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
 402:./Eigen/src/Core/PlainObjectBase.h ****       *
 403:./Eigen/src/Core/PlainObjectBase.h ****       * As opposed to conservativeResize(Index rows, Index cols), this version leaves
 404:./Eigen/src/Core/PlainObjectBase.h ****       * the number of rows unchanged.
 405:./Eigen/src/Core/PlainObjectBase.h ****       *
 406:./Eigen/src/Core/PlainObjectBase.h ****       * In case the matrix is growing, new columns will be uninitialized.
 407:./Eigen/src/Core/PlainObjectBase.h ****       */
 408:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 409:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)
 410:./Eigen/src/Core/PlainObjectBase.h ****     {
 411:./Eigen/src/Core/PlainObjectBase.h ****       // Note: see the comment in conservativeResize(Index,Index)
 412:./Eigen/src/Core/PlainObjectBase.h ****       conservativeResize(rows(), cols);
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 87


 413:./Eigen/src/Core/PlainObjectBase.h ****     }
 414:./Eigen/src/Core/PlainObjectBase.h **** 
 415:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the vector to \a size while retaining old values.
 416:./Eigen/src/Core/PlainObjectBase.h ****       *
 417:./Eigen/src/Core/PlainObjectBase.h ****       * \only_for_vectors. This method does not work for
 418:./Eigen/src/Core/PlainObjectBase.h ****       * partially dynamic matrices when the static dimension is anything other
 419:./Eigen/src/Core/PlainObjectBase.h ****       * than 1. For example it will not work with Matrix<double, 2, Dynamic>.
 420:./Eigen/src/Core/PlainObjectBase.h ****       *
 421:./Eigen/src/Core/PlainObjectBase.h ****       * When values are appended, they will be uninitialized.
 422:./Eigen/src/Core/PlainObjectBase.h ****       */
 423:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 424:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void conservativeResize(Index size)
 425:./Eigen/src/Core/PlainObjectBase.h ****     {
 426:./Eigen/src/Core/PlainObjectBase.h ****       internal::conservative_resize_like_impl<Derived>::run(*this, size);
 427:./Eigen/src/Core/PlainObjectBase.h ****     }
 428:./Eigen/src/Core/PlainObjectBase.h **** 
 429:./Eigen/src/Core/PlainObjectBase.h ****     /** Resizes the matrix to \a rows x \a cols of \c other, while leaving old values untouched.
 430:./Eigen/src/Core/PlainObjectBase.h ****       *
 431:./Eigen/src/Core/PlainObjectBase.h ****       * The method is intended for matrices of dynamic size. If you only want to change the number
 432:./Eigen/src/Core/PlainObjectBase.h ****       * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
 433:./Eigen/src/Core/PlainObjectBase.h ****       * conservativeResize(Index, NoChange_t).
 434:./Eigen/src/Core/PlainObjectBase.h ****       *
 435:./Eigen/src/Core/PlainObjectBase.h ****       * Matrices are resized relative to the top-left element. In case values need to be
 436:./Eigen/src/Core/PlainObjectBase.h ****       * appended to the matrix they will copied from \c other.
 437:./Eigen/src/Core/PlainObjectBase.h ****       */
 438:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 439:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 440:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)
 441:./Eigen/src/Core/PlainObjectBase.h ****     {
 442:./Eigen/src/Core/PlainObjectBase.h ****       internal::conservative_resize_like_impl<Derived,OtherDerived>::run(*this, other);
 443:./Eigen/src/Core/PlainObjectBase.h ****     }
 444:./Eigen/src/Core/PlainObjectBase.h **** 
 445:./Eigen/src/Core/PlainObjectBase.h ****     /** This is a special case of the templated operator=. Its purpose is to
 446:./Eigen/src/Core/PlainObjectBase.h ****       * prevent a default operator= from hiding the templated operator=.
 447:./Eigen/src/Core/PlainObjectBase.h ****       */
 448:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 449:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)
 450:./Eigen/src/Core/PlainObjectBase.h ****     {
 451:./Eigen/src/Core/PlainObjectBase.h ****       return _set(other);
 452:./Eigen/src/Core/PlainObjectBase.h ****     }
 453:./Eigen/src/Core/PlainObjectBase.h **** 
 454:./Eigen/src/Core/PlainObjectBase.h ****     /** \sa MatrixBase::lazyAssign() */
 455:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 456:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 457:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)
 458:./Eigen/src/Core/PlainObjectBase.h ****     {
 459:./Eigen/src/Core/PlainObjectBase.h ****       _resize_to_match(other);
 460:./Eigen/src/Core/PlainObjectBase.h ****       return Base::lazyAssign(other.derived());
 461:./Eigen/src/Core/PlainObjectBase.h ****     }
 462:./Eigen/src/Core/PlainObjectBase.h **** 
 463:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 464:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 465:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)
 466:./Eigen/src/Core/PlainObjectBase.h ****     {
 467:./Eigen/src/Core/PlainObjectBase.h ****       resize(func.rows(), func.cols());
 468:./Eigen/src/Core/PlainObjectBase.h ****       return Base::operator=(func);
 469:./Eigen/src/Core/PlainObjectBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 88


 470:./Eigen/src/Core/PlainObjectBase.h **** 
 471:./Eigen/src/Core/PlainObjectBase.h ****     // Prevent user from trying to instantiate PlainObjectBase objects
 472:./Eigen/src/Core/PlainObjectBase.h ****     // by making all its constructor protected. See bug 1074.
 473:./Eigen/src/Core/PlainObjectBase.h ****   protected:
 474:./Eigen/src/Core/PlainObjectBase.h **** 
 475:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 476:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()
 477:./Eigen/src/Core/PlainObjectBase.h ****     {
 478:./Eigen/src/Core/PlainObjectBase.h **** //       _check_template_params();
 479:./Eigen/src/Core/PlainObjectBase.h **** //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 480:./Eigen/src/Core/PlainObjectBase.h ****     }
 481:./Eigen/src/Core/PlainObjectBase.h **** 
 482:./Eigen/src/Core/PlainObjectBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 483:./Eigen/src/Core/PlainObjectBase.h ****     // FIXME is it still needed ?
 484:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal */
 485:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 486:./Eigen/src/Core/PlainObjectBase.h ****     explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)
 487:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage(internal::constructor_without_unaligned_array_assert())
 488:./Eigen/src/Core/PlainObjectBase.h ****     {
 489:./Eigen/src/Core/PlainObjectBase.h **** //       _check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 490:./Eigen/src/Core/PlainObjectBase.h ****     }
 491:./Eigen/src/Core/PlainObjectBase.h **** #endif
 492:./Eigen/src/Core/PlainObjectBase.h **** 
 493:./Eigen/src/Core/PlainObjectBase.h **** #if EIGEN_HAS_RVALUE_REFERENCES
 494:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 495:./Eigen/src/Core/PlainObjectBase.h ****     PlainObjectBase(PlainObjectBase&& other) EIGEN_NOEXCEPT
 496:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage( std::move(other.m_storage) )
 497:./Eigen/src/Core/PlainObjectBase.h ****     {
 498:./Eigen/src/Core/PlainObjectBase.h ****     }
 499:./Eigen/src/Core/PlainObjectBase.h **** 
 500:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 501:./Eigen/src/Core/PlainObjectBase.h ****     PlainObjectBase& operator=(PlainObjectBase&& other) EIGEN_NOEXCEPT
 502:./Eigen/src/Core/PlainObjectBase.h ****     {
 503:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 504:./Eigen/src/Core/PlainObjectBase.h ****       m_storage = std::move(other.m_storage);
 505:./Eigen/src/Core/PlainObjectBase.h ****       return *this;
 506:./Eigen/src/Core/PlainObjectBase.h ****     }
 507:./Eigen/src/Core/PlainObjectBase.h **** #endif
 508:./Eigen/src/Core/PlainObjectBase.h **** 
 509:./Eigen/src/Core/PlainObjectBase.h ****     /** Copy constructor */
 510:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 511:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)
 512:./Eigen/src/Core/PlainObjectBase.h ****       : Base(), m_storage(other.m_storage) { }
 513:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 514:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)
 515:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage(size, rows, cols)
 516:./Eigen/src/Core/PlainObjectBase.h ****     {
 517:./Eigen/src/Core/PlainObjectBase.h **** //       _check_template_params();
 518:./Eigen/src/Core/PlainObjectBase.h **** //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 519:./Eigen/src/Core/PlainObjectBase.h ****     }
 520:./Eigen/src/Core/PlainObjectBase.h **** 
 521:./Eigen/src/Core/PlainObjectBase.h ****     #if EIGEN_HAS_CXX11
 522:./Eigen/src/Core/PlainObjectBase.h ****     /** \brief Construct a row of column vector with fixed size from an arbitrary number of coeffic
 523:./Eigen/src/Core/PlainObjectBase.h ****       *
 524:./Eigen/src/Core/PlainObjectBase.h ****       * \only_for_vectors
 525:./Eigen/src/Core/PlainObjectBase.h ****       *
 526:./Eigen/src/Core/PlainObjectBase.h ****       * This constructor is for 1D array or vectors with more than 4 coefficients.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 89


 527:./Eigen/src/Core/PlainObjectBase.h ****       * There exists C++98 analogue constructors for fixed-size array/vector having 1, 2, 3, or 4 c
 528:./Eigen/src/Core/PlainObjectBase.h ****       *
 529:./Eigen/src/Core/PlainObjectBase.h ****       * \warning To construct a column (resp. row) vector of fixed length, the number of values pas
 530:./Eigen/src/Core/PlainObjectBase.h ****       * constructor must match the the fixed number of rows (resp. columns) of \c *this.
 531:./Eigen/src/Core/PlainObjectBase.h ****       */
 532:./Eigen/src/Core/PlainObjectBase.h ****     template <typename... ArgTypes>
 533:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 534:./Eigen/src/Core/PlainObjectBase.h ****     PlainObjectBase(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const 
 535:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 536:./Eigen/src/Core/PlainObjectBase.h ****     {
 537:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 538:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, sizeof...(args) + 4);
 539:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[0] = a0;
 540:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[1] = a1;
 541:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[2] = a2;
 542:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[3] = a3;
 543:./Eigen/src/Core/PlainObjectBase.h ****       Index i = 4;
 544:./Eigen/src/Core/PlainObjectBase.h ****       auto x = {(m_storage.data()[i++] = args, 0)...};
 545:./Eigen/src/Core/PlainObjectBase.h ****       static_cast<void>(x);
 546:./Eigen/src/Core/PlainObjectBase.h ****     }
 547:./Eigen/src/Core/PlainObjectBase.h **** 
 548:./Eigen/src/Core/PlainObjectBase.h ****     /** \brief Constructs a Matrix or Array and initializes it by elements given by an initializer 
 549:./Eigen/src/Core/PlainObjectBase.h ****       * lists \cpp11
 550:./Eigen/src/Core/PlainObjectBase.h ****       */
 551:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 552:./Eigen/src/Core/PlainObjectBase.h ****     explicit EIGEN_STRONG_INLINE PlainObjectBase(const std::initializer_list<std::initializer_list<
 553:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 554:./Eigen/src/Core/PlainObjectBase.h ****     {
 555:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 556:./Eigen/src/Core/PlainObjectBase.h **** 
 557:./Eigen/src/Core/PlainObjectBase.h ****       size_t list_size = 0;
 558:./Eigen/src/Core/PlainObjectBase.h ****       if (list.begin() != list.end()) {
 559:./Eigen/src/Core/PlainObjectBase.h ****         list_size = list.begin()->size();
 560:./Eigen/src/Core/PlainObjectBase.h ****       }
 561:./Eigen/src/Core/PlainObjectBase.h **** 
 562:./Eigen/src/Core/PlainObjectBase.h ****       // This is to allow syntax like VectorXi {{1, 2, 3, 4}}
 563:./Eigen/src/Core/PlainObjectBase.h ****       if (ColsAtCompileTime == 1 && list.size() == 1) {
 564:./Eigen/src/Core/PlainObjectBase.h ****         eigen_assert(list_size == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dy
 565:./Eigen/src/Core/PlainObjectBase.h ****         resize(list_size, ColsAtCompileTime);
 566:./Eigen/src/Core/PlainObjectBase.h ****         std::copy(list.begin()->begin(), list.begin()->end(), m_storage.data());
 567:./Eigen/src/Core/PlainObjectBase.h ****       } else {
 568:./Eigen/src/Core/PlainObjectBase.h ****         eigen_assert(list.size() == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == 
 569:./Eigen/src/Core/PlainObjectBase.h ****         eigen_assert(list_size == static_cast<size_t>(ColsAtCompileTime) || ColsAtCompileTime == Dy
 570:./Eigen/src/Core/PlainObjectBase.h ****         resize(list.size(), list_size);
 571:./Eigen/src/Core/PlainObjectBase.h **** 
 572:./Eigen/src/Core/PlainObjectBase.h ****         Index row_index = 0;
 573:./Eigen/src/Core/PlainObjectBase.h ****         for (const std::initializer_list<Scalar>& row : list) {
 574:./Eigen/src/Core/PlainObjectBase.h ****           eigen_assert(list_size == row.size());
 575:./Eigen/src/Core/PlainObjectBase.h ****           Index col_index = 0;
 576:./Eigen/src/Core/PlainObjectBase.h ****           for (const Scalar& e : row) {
 577:./Eigen/src/Core/PlainObjectBase.h ****             coeffRef(row_index, col_index) = e;
 578:./Eigen/src/Core/PlainObjectBase.h ****             ++col_index;
 579:./Eigen/src/Core/PlainObjectBase.h ****           }
 580:./Eigen/src/Core/PlainObjectBase.h ****           ++row_index;
 581:./Eigen/src/Core/PlainObjectBase.h ****         }
 582:./Eigen/src/Core/PlainObjectBase.h ****       }
 583:./Eigen/src/Core/PlainObjectBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 90


 584:./Eigen/src/Core/PlainObjectBase.h ****     #endif  // end EIGEN_HAS_CXX11
 585:./Eigen/src/Core/PlainObjectBase.h **** 
 586:./Eigen/src/Core/PlainObjectBase.h ****     /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
 587:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 588:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 589:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)
 590:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 591:./Eigen/src/Core/PlainObjectBase.h ****     {
 592:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 593:./Eigen/src/Core/PlainObjectBase.h ****       resizeLike(other);
 594:./Eigen/src/Core/PlainObjectBase.h ****       _set_noalias(other);
 595:./Eigen/src/Core/PlainObjectBase.h ****     }
 596:./Eigen/src/Core/PlainObjectBase.h **** 
 597:./Eigen/src/Core/PlainObjectBase.h ****     /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
 598:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 599:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 600:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)
 601:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 602:./Eigen/src/Core/PlainObjectBase.h ****     {
 603:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 604:./Eigen/src/Core/PlainObjectBase.h ****       resizeLike(other);
 605:./Eigen/src/Core/PlainObjectBase.h ****       *this = other.derived();
 606:./Eigen/src/Core/PlainObjectBase.h ****     }
 607:./Eigen/src/Core/PlainObjectBase.h ****     /** \brief Copy constructor with in-place evaluation */
 608:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 609:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 610:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE PlainObjectBase(const ReturnByValue<OtherDerived>& other)
 611:./Eigen/src/Core/PlainObjectBase.h ****     {
 612:./Eigen/src/Core/PlainObjectBase.h ****       _check_template_params();
 613:./Eigen/src/Core/PlainObjectBase.h ****       // FIXME this does not automatically transpose vectors if necessary
 614:./Eigen/src/Core/PlainObjectBase.h ****       resize(other.rows(), other.cols());
 615:./Eigen/src/Core/PlainObjectBase.h ****       other.evalTo(this->derived());
 616:./Eigen/src/Core/PlainObjectBase.h ****     }
 617:./Eigen/src/Core/PlainObjectBase.h **** 
 618:./Eigen/src/Core/PlainObjectBase.h ****   public:
 619:./Eigen/src/Core/PlainObjectBase.h **** 
 620:./Eigen/src/Core/PlainObjectBase.h ****     /** \brief Copies the generic expression \a other into *this.
 621:./Eigen/src/Core/PlainObjectBase.h ****       * \copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)
 622:./Eigen/src/Core/PlainObjectBase.h ****       */
 623:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 624:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 625:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)
 626:./Eigen/src/Core/PlainObjectBase.h ****     {
 627:./Eigen/src/Core/PlainObjectBase.h ****       _resize_to_match(other);
 628:./Eigen/src/Core/PlainObjectBase.h ****       Base::operator=(other.derived());
 629:./Eigen/src/Core/PlainObjectBase.h ****       return this->derived();
 630:./Eigen/src/Core/PlainObjectBase.h ****     }
 631:./Eigen/src/Core/PlainObjectBase.h **** 
 632:./Eigen/src/Core/PlainObjectBase.h ****     /** \name Map
 633:./Eigen/src/Core/PlainObjectBase.h ****       * These are convenience functions returning Map objects. The Map() static functions return un
 634:./Eigen/src/Core/PlainObjectBase.h ****       * while the AlignedMap() functions return aligned Map objects and thus should be called only 
 635:./Eigen/src/Core/PlainObjectBase.h ****       * \a data pointers.
 636:./Eigen/src/Core/PlainObjectBase.h ****       *
 637:./Eigen/src/Core/PlainObjectBase.h ****       * Here is an example using strides:
 638:./Eigen/src/Core/PlainObjectBase.h ****       * \include Matrix_Map_stride.cpp
 639:./Eigen/src/Core/PlainObjectBase.h ****       * Output: \verbinclude Matrix_Map_stride.out
 640:./Eigen/src/Core/PlainObjectBase.h ****       *
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 91


 641:./Eigen/src/Core/PlainObjectBase.h ****       * \see class Map
 642:./Eigen/src/Core/PlainObjectBase.h ****       */
 643:./Eigen/src/Core/PlainObjectBase.h ****     //@{
 644:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstMapType Map(const Scalar* data)
 645:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstMapType(data); }
 646:./Eigen/src/Core/PlainObjectBase.h ****     static inline MapType Map(Scalar* data)
 647:./Eigen/src/Core/PlainObjectBase.h ****     { return MapType(data); }
 648:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstMapType Map(const Scalar* data, Index size)
 649:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstMapType(data, size); }
 650:./Eigen/src/Core/PlainObjectBase.h ****     static inline MapType Map(Scalar* data, Index size)
 651:./Eigen/src/Core/PlainObjectBase.h ****     { return MapType(data, size); }
 652:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)
 653:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstMapType(data, rows, cols); }
 654:./Eigen/src/Core/PlainObjectBase.h ****     static inline MapType Map(Scalar* data, Index rows, Index cols)
 655:./Eigen/src/Core/PlainObjectBase.h ****     { return MapType(data, rows, cols); }
 656:./Eigen/src/Core/PlainObjectBase.h **** 
 657:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstAlignedMapType MapAligned(const Scalar* data)
 658:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstAlignedMapType(data); }
 659:./Eigen/src/Core/PlainObjectBase.h ****     static inline AlignedMapType MapAligned(Scalar* data)
 660:./Eigen/src/Core/PlainObjectBase.h ****     { return AlignedMapType(data); }
 661:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)
 662:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstAlignedMapType(data, size); }
 663:./Eigen/src/Core/PlainObjectBase.h ****     static inline AlignedMapType MapAligned(Scalar* data, Index size)
 664:./Eigen/src/Core/PlainObjectBase.h ****     { return AlignedMapType(data, size); }
 665:./Eigen/src/Core/PlainObjectBase.h ****     static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)
 666:./Eigen/src/Core/PlainObjectBase.h ****     { return ConstAlignedMapType(data, rows, cols); }
 667:./Eigen/src/Core/PlainObjectBase.h ****     static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)
 668:./Eigen/src/Core/PlainObjectBase.h ****     { return AlignedMapType(data, rows, cols); }
 669:./Eigen/src/Core/PlainObjectBase.h **** 
 670:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 671:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data,
 672:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, stride); }
 673:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 674:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stri
 675:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedMapType<Stride<Outer, Inner> >::type(data, stride); }
 676:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 677:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data,
 678:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, size, stride); }
 679:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 680:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size
 681:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedMapType<Stride<Outer, Inner> >::type(data, size, stride); }
 682:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 683:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data,
 684:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }
 685:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 686:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows
 687:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }
 688:./Eigen/src/Core/PlainObjectBase.h **** 
 689:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 690:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const
 691:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }
 692:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 693:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* da
 694:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }
 695:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 696:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const
 697:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 92


 698:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 699:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* da
 700:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); }
 701:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 702:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const
 703:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, str
 704:./Eigen/src/Core/PlainObjectBase.h ****     template<int Outer, int Inner>
 705:./Eigen/src/Core/PlainObjectBase.h ****     static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* da
 706:./Eigen/src/Core/PlainObjectBase.h ****     { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride);
 707:./Eigen/src/Core/PlainObjectBase.h ****     //@}
 708:./Eigen/src/Core/PlainObjectBase.h **** 
 709:./Eigen/src/Core/PlainObjectBase.h ****     using Base::setConstant;
 710:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setConstant(Index size, const Scalar& val);
 711:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, Index cols, const Scalar& val);
 712:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setConstant(NoChange_t, Index cols, const Scalar& val);
 713:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, NoChange_t, const Scalar& val);
 714:./Eigen/src/Core/PlainObjectBase.h **** 
 715:./Eigen/src/Core/PlainObjectBase.h ****     using Base::setZero;
 716:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setZero(Index size);
 717:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setZero(Index rows, Index cols);
 718:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setZero(NoChange_t, Index cols);
 719:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setZero(Index rows, NoChange_t);
 720:./Eigen/src/Core/PlainObjectBase.h **** 
 721:./Eigen/src/Core/PlainObjectBase.h ****     using Base::setOnes;
 722:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setOnes(Index size);
 723:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, Index cols);
 724:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setOnes(NoChange_t, Index cols);
 725:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, NoChange_t);
 726:./Eigen/src/Core/PlainObjectBase.h **** 
 727:./Eigen/src/Core/PlainObjectBase.h ****     using Base::setRandom;
 728:./Eigen/src/Core/PlainObjectBase.h ****     Derived& setRandom(Index size);
 729:./Eigen/src/Core/PlainObjectBase.h ****     Derived& setRandom(Index rows, Index cols);
 730:./Eigen/src/Core/PlainObjectBase.h ****     Derived& setRandom(NoChange_t, Index cols);
 731:./Eigen/src/Core/PlainObjectBase.h ****     Derived& setRandom(Index rows, NoChange_t);
 732:./Eigen/src/Core/PlainObjectBase.h **** 
 733:./Eigen/src/Core/PlainObjectBase.h ****     #ifdef EIGEN_PLAINOBJECTBASE_PLUGIN
 734:./Eigen/src/Core/PlainObjectBase.h ****     #include EIGEN_PLAINOBJECTBASE_PLUGIN
 735:./Eigen/src/Core/PlainObjectBase.h ****     #endif
 736:./Eigen/src/Core/PlainObjectBase.h **** 
 737:./Eigen/src/Core/PlainObjectBase.h ****   protected:
 738:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal Resizes *this in preparation for assigning \a other to it.
 739:./Eigen/src/Core/PlainObjectBase.h ****       * Takes care of doing all the checking that's needed.
 740:./Eigen/src/Core/PlainObjectBase.h ****       *
 741:./Eigen/src/Core/PlainObjectBase.h ****       * Note that copying a row-vector into a vector (and conversely) is allowed.
 742:./Eigen/src/Core/PlainObjectBase.h ****       * The resizing, if any, is then done in the appropriate way so that row-vectors
 743:./Eigen/src/Core/PlainObjectBase.h ****       * remain row-vectors and vectors remain vectors.
 744:./Eigen/src/Core/PlainObjectBase.h ****       */
 745:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 746:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 747:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)
 748:./Eigen/src/Core/PlainObjectBase.h ****     {
 749:./Eigen/src/Core/PlainObjectBase.h ****       #ifdef EIGEN_NO_AUTOMATIC_RESIZING
 750:./Eigen/src/Core/PlainObjectBase.h ****       eigen_assert((this->size()==0 || (IsVectorAtCompileTime ? (this->size() == other.size())
 751:./Eigen/src/Core/PlainObjectBase.h ****                  : (rows() == other.rows() && cols() == other.cols())))
 752:./Eigen/src/Core/PlainObjectBase.h ****         && "Size mismatch. Automatic resizing is disabled because EIGEN_NO_AUTOMATIC_RESIZING is de
 753:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_ONLY_USED_FOR_DEBUG(other);
 754:./Eigen/src/Core/PlainObjectBase.h ****       #else
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 93


 755:./Eigen/src/Core/PlainObjectBase.h ****       resizeLike(other);
 756:./Eigen/src/Core/PlainObjectBase.h ****       #endif
 757:./Eigen/src/Core/PlainObjectBase.h ****     }
 758:./Eigen/src/Core/PlainObjectBase.h **** 
 759:./Eigen/src/Core/PlainObjectBase.h ****     /**
 760:./Eigen/src/Core/PlainObjectBase.h ****       * \brief Copies the value of the expression \a other into \c *this with automatic resizing.
 761:./Eigen/src/Core/PlainObjectBase.h ****       *
 762:./Eigen/src/Core/PlainObjectBase.h ****       * *this might be resized to match the dimensions of \a other. If *this was a null matrix (not
 763:./Eigen/src/Core/PlainObjectBase.h ****       * it will be initialized.
 764:./Eigen/src/Core/PlainObjectBase.h ****       *
 765:./Eigen/src/Core/PlainObjectBase.h ****       * Note that copying a row-vector into a vector (and conversely) is allowed.
 766:./Eigen/src/Core/PlainObjectBase.h ****       * The resizing, if any, is then done in the appropriate way so that row-vectors
 767:./Eigen/src/Core/PlainObjectBase.h ****       * remain row-vectors and vectors remain vectors.
 768:./Eigen/src/Core/PlainObjectBase.h ****       *
 769:./Eigen/src/Core/PlainObjectBase.h ****       * \sa operator=(const MatrixBase<OtherDerived>&), _set_noalias()
 770:./Eigen/src/Core/PlainObjectBase.h ****       *
 771:./Eigen/src/Core/PlainObjectBase.h ****       * \internal
 772:./Eigen/src/Core/PlainObjectBase.h ****       */
 773:./Eigen/src/Core/PlainObjectBase.h ****     // aliasing is dealt once in internal::call_assignment
 774:./Eigen/src/Core/PlainObjectBase.h ****     // so at this stage we have to assume aliasing... and resising has to be done later.
 775:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 776:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 777:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)
 778:./Eigen/src/Core/PlainObjectBase.h ****     {
 779:./Eigen/src/Core/PlainObjectBase.h ****       internal::call_assignment(this->derived(), other.derived());
 780:./Eigen/src/Core/PlainObjectBase.h ****       return this->derived();
 781:./Eigen/src/Core/PlainObjectBase.h ****     }
 782:./Eigen/src/Core/PlainObjectBase.h **** 
 783:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal Like _set() but additionally makes the assumption that no aliasing effect can hap
 784:./Eigen/src/Core/PlainObjectBase.h ****       * is the case when creating a new matrix) so one can enforce lazy evaluation.
 785:./Eigen/src/Core/PlainObjectBase.h ****       *
 786:./Eigen/src/Core/PlainObjectBase.h ****       * \sa operator=(const MatrixBase<OtherDerived>&), _set()
 787:./Eigen/src/Core/PlainObjectBase.h ****       */
 788:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 789:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 790:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)
 806              		.loc 7 790 34 is_stmt 1 view -0
 807              		.cfi_startproc
 808              		@ args = 0, pretend = 0, frame = 32
 809              		@ frame_needed = 0, uses_anonymous_args = 0
 810              		.loc 7 790 34 is_stmt 0 view .LVU116
 811 0000 10B5     		push	{r4, lr}
 812              	.LCFI16:
 813              		.cfi_def_cfa_offset 8
 814              		.cfi_offset 4, -8
 815              		.cfi_offset 14, -4
 816 0002 88B0     		sub	sp, sp, #32
 817              	.LCFI17:
 818              		.cfi_def_cfa_offset 40
 819 0004 0446     		mov	r4, r0
 820              	.LVL54:
 821              	.LBB357:
 822              	.LBI357:
  23:./Eigen/src/Core/functors/AssignmentFunctors.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { 
 823              		.loc 11 23 3 is_stmt 1 view .LVU117
  23:./Eigen/src/Core/functors/AssignmentFunctors.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { 
 824              		.loc 11 23 3 is_stmt 0 view .LVU118
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 94


 825              	.LBE357:
 826              	.LBB358:
 827              	.LBI358:
 662:./Eigen/src/Core/AssignEvaluator.h **** 
 663:./Eigen/src/Core/AssignEvaluator.h ****   /// \sa assignCoeff(Index,Index)
 664:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)
 665:./Eigen/src/Core/AssignEvaluator.h ****   {
 666:./Eigen/src/Core/AssignEvaluator.h ****     Index row = rowIndexByOuterInner(outer, inner);
 667:./Eigen/src/Core/AssignEvaluator.h ****     Index col = colIndexByOuterInner(outer, inner);
 668:./Eigen/src/Core/AssignEvaluator.h ****     assignCoeff(row, col);
 669:./Eigen/src/Core/AssignEvaluator.h ****   }
 670:./Eigen/src/Core/AssignEvaluator.h **** 
 671:./Eigen/src/Core/AssignEvaluator.h **** 
 672:./Eigen/src/Core/AssignEvaluator.h ****   template<int StoreMode, int LoadMode, typename PacketType>
 673:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)
 674:./Eigen/src/Core/AssignEvaluator.h ****   {
 675:./Eigen/src/Core/AssignEvaluator.h ****     m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(row,col), m_src.template packet<Load
 676:./Eigen/src/Core/AssignEvaluator.h ****   }
 677:./Eigen/src/Core/AssignEvaluator.h **** 
 678:./Eigen/src/Core/AssignEvaluator.h ****   template<int StoreMode, int LoadMode, typename PacketType>
 679:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)
 680:./Eigen/src/Core/AssignEvaluator.h ****   {
 681:./Eigen/src/Core/AssignEvaluator.h ****     m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(index), m_src.template packet<LoadMo
 682:./Eigen/src/Core/AssignEvaluator.h ****   }
 683:./Eigen/src/Core/AssignEvaluator.h **** 
 684:./Eigen/src/Core/AssignEvaluator.h ****   template<int StoreMode, int LoadMode, typename PacketType>
 685:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)
 686:./Eigen/src/Core/AssignEvaluator.h ****   {
 687:./Eigen/src/Core/AssignEvaluator.h ****     Index row = rowIndexByOuterInner(outer, inner);
 688:./Eigen/src/Core/AssignEvaluator.h ****     Index col = colIndexByOuterInner(outer, inner);
 689:./Eigen/src/Core/AssignEvaluator.h ****     assignPacket<StoreMode,LoadMode,PacketType>(row, col);
 690:./Eigen/src/Core/AssignEvaluator.h ****   }
 691:./Eigen/src/Core/AssignEvaluator.h **** 
 692:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner)
 693:./Eigen/src/Core/AssignEvaluator.h ****   {
 694:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename DstEvaluatorType::ExpressionTraits Traits;
 695:./Eigen/src/Core/AssignEvaluator.h ****     return int(Traits::RowsAtCompileTime) == 1 ? 0
 696:./Eigen/src/Core/AssignEvaluator.h ****       : int(Traits::ColsAtCompileTime) == 1 ? inner
 697:./Eigen/src/Core/AssignEvaluator.h ****       : int(DstEvaluatorType::Flags)&RowMajorBit ? outer
 698:./Eigen/src/Core/AssignEvaluator.h ****       : inner;
 699:./Eigen/src/Core/AssignEvaluator.h ****   }
 700:./Eigen/src/Core/AssignEvaluator.h **** 
 701:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner)
 702:./Eigen/src/Core/AssignEvaluator.h ****   {
 703:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename DstEvaluatorType::ExpressionTraits Traits;
 704:./Eigen/src/Core/AssignEvaluator.h ****     return int(Traits::ColsAtCompileTime) == 1 ? 0
 705:./Eigen/src/Core/AssignEvaluator.h ****       : int(Traits::RowsAtCompileTime) == 1 ? inner
 706:./Eigen/src/Core/AssignEvaluator.h ****       : int(DstEvaluatorType::Flags)&RowMajorBit ? inner
 707:./Eigen/src/Core/AssignEvaluator.h ****       : outer;
 708:./Eigen/src/Core/AssignEvaluator.h ****   }
 709:./Eigen/src/Core/AssignEvaluator.h **** 
 710:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC const Scalar* dstDataPtr() const
 711:./Eigen/src/Core/AssignEvaluator.h ****   {
 712:./Eigen/src/Core/AssignEvaluator.h ****     return m_dstExpr.data();
 713:./Eigen/src/Core/AssignEvaluator.h ****   }
 714:./Eigen/src/Core/AssignEvaluator.h **** 
 715:./Eigen/src/Core/AssignEvaluator.h **** protected:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 95


 716:./Eigen/src/Core/AssignEvaluator.h ****   DstEvaluatorType& m_dst;
 717:./Eigen/src/Core/AssignEvaluator.h ****   const SrcEvaluatorType& m_src;
 718:./Eigen/src/Core/AssignEvaluator.h ****   const Functor &m_functor;
 719:./Eigen/src/Core/AssignEvaluator.h ****   // TODO find a way to avoid the needs of the original expression
 720:./Eigen/src/Core/AssignEvaluator.h ****   DstXprType& m_dstExpr;
 721:./Eigen/src/Core/AssignEvaluator.h **** };
 722:./Eigen/src/Core/AssignEvaluator.h **** 
 723:./Eigen/src/Core/AssignEvaluator.h **** // Special kernel used when computing small products whose operands have dynamic dimensions.  It en
 724:./Eigen/src/Core/AssignEvaluator.h **** // PacketSize used is no larger than 4, thereby increasing the chance that vectorized instructions 
 725:./Eigen/src/Core/AssignEvaluator.h **** // when computing the product.
 726:./Eigen/src/Core/AssignEvaluator.h **** 
 727:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor>
 728:./Eigen/src/Core/AssignEvaluator.h **** class restricted_packet_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluat
 729:./Eigen/src/Core/AssignEvaluator.h **** {
 730:./Eigen/src/Core/AssignEvaluator.h **** protected:
 731:./Eigen/src/Core/AssignEvaluator.h ****   typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, BuiltIn> B
 732:./Eigen/src/Core/AssignEvaluator.h ****  public:
 733:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Base::Scalar Scalar;
 734:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename Base::DstXprType DstXprType;
 735:./Eigen/src/Core/AssignEvaluator.h ****     typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, 4> Assignmen
 736:./Eigen/src/Core/AssignEvaluator.h ****     typedef typename AssignmentTraits::PacketType PacketType;
 737:./Eigen/src/Core/AssignEvaluator.h **** 
 738:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_DEVICE_FUNC restricted_packet_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEv
 739:./Eigen/src/Core/AssignEvaluator.h ****     : Base(dst, src, func, dstExpr)
 740:./Eigen/src/Core/AssignEvaluator.h ****   {
 741:./Eigen/src/Core/AssignEvaluator.h ****   }
 742:./Eigen/src/Core/AssignEvaluator.h ****  };
 743:./Eigen/src/Core/AssignEvaluator.h **** 
 744:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
 745:./Eigen/src/Core/AssignEvaluator.h **** * Part 5 : Entry point for dense rectangular assignment
 746:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
 747:./Eigen/src/Core/AssignEvaluator.h **** 
 748:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstXprType,typename SrcXprType, typename Functor>
 749:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 750:./Eigen/src/Core/AssignEvaluator.h **** void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &/*func*/)
 751:./Eigen/src/Core/AssignEvaluator.h **** {
 752:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_ONLY_USED_FOR_DEBUG(dst);
 753:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_ONLY_USED_FOR_DEBUG(src);
 754:./Eigen/src/Core/AssignEvaluator.h ****   eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
 755:./Eigen/src/Core/AssignEvaluator.h **** }
 756:./Eigen/src/Core/AssignEvaluator.h **** 
 757:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstXprType,typename SrcXprType, typename T1, typename T2>
 758:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 759:./Eigen/src/Core/AssignEvaluator.h **** void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const internal::assign_op<T1,T2> &/*
 760:./Eigen/src/Core/AssignEvaluator.h **** {
 761:./Eigen/src/Core/AssignEvaluator.h ****   Index dstRows = src.rows();
 762:./Eigen/src/Core/AssignEvaluator.h ****   Index dstCols = src.cols();
 763:./Eigen/src/Core/AssignEvaluator.h ****   if(((dst.rows()!=dstRows) || (dst.cols()!=dstCols)))
 764:./Eigen/src/Core/AssignEvaluator.h ****     dst.resize(dstRows, dstCols);
 765:./Eigen/src/Core/AssignEvaluator.h ****   eigen_assert(dst.rows() == dstRows && dst.cols() == dstCols);
 766:./Eigen/src/Core/AssignEvaluator.h **** }
 767:./Eigen/src/Core/AssignEvaluator.h **** 
 768:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstXprType, typename SrcXprType, typename Functor>
 769:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXpr
 770:./Eigen/src/Core/AssignEvaluator.h **** {
 771:./Eigen/src/Core/AssignEvaluator.h ****   typedef evaluator<DstXprType> DstEvaluatorType;
 772:./Eigen/src/Core/AssignEvaluator.h ****   typedef evaluator<SrcXprType> SrcEvaluatorType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 96


 773:./Eigen/src/Core/AssignEvaluator.h **** 
 774:./Eigen/src/Core/AssignEvaluator.h ****   SrcEvaluatorType srcEvaluator(src);
 775:./Eigen/src/Core/AssignEvaluator.h **** 
 776:./Eigen/src/Core/AssignEvaluator.h ****   // NOTE To properly handle A = (A*A.transpose())/s with A rectangular,
 777:./Eigen/src/Core/AssignEvaluator.h ****   // we need to resize the destination after the source evaluator has been created.
 778:./Eigen/src/Core/AssignEvaluator.h ****   resize_if_allowed(dst, src, func);
 779:./Eigen/src/Core/AssignEvaluator.h **** 
 780:./Eigen/src/Core/AssignEvaluator.h ****   DstEvaluatorType dstEvaluator(dst);
 781:./Eigen/src/Core/AssignEvaluator.h **** 
 782:./Eigen/src/Core/AssignEvaluator.h ****   typedef generic_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;
 783:./Eigen/src/Core/AssignEvaluator.h ****   Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
 784:./Eigen/src/Core/AssignEvaluator.h **** 
 785:./Eigen/src/Core/AssignEvaluator.h ****   dense_assignment_loop<Kernel>::run(kernel);
 786:./Eigen/src/Core/AssignEvaluator.h **** }
 787:./Eigen/src/Core/AssignEvaluator.h **** 
 788:./Eigen/src/Core/AssignEvaluator.h **** // Specialization for filling the destination with a constant value.
 789:./Eigen/src/Core/AssignEvaluator.h **** #ifndef EIGEN_GPU_COMPILE_PHASE
 790:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstXprType>
 791:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const Eigen:
 792:./Eigen/src/Core/AssignEvaluator.h **** {
 793:./Eigen/src/Core/AssignEvaluator.h ****   resize_if_allowed(dst, src, func);
 794:./Eigen/src/Core/AssignEvaluator.h ****   std::fill_n(dst.data(), dst.size(), src.functor()());
 795:./Eigen/src/Core/AssignEvaluator.h **** }
 796:./Eigen/src/Core/AssignEvaluator.h **** #endif
 797:./Eigen/src/Core/AssignEvaluator.h **** 
 798:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstXprType, typename SrcXprType>
 799:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXpr
 800:./Eigen/src/Core/AssignEvaluator.h **** {
 801:./Eigen/src/Core/AssignEvaluator.h ****   call_dense_assignment_loop(dst, src, internal::assign_op<typename DstXprType::Scalar,typename Src
 802:./Eigen/src/Core/AssignEvaluator.h **** }
 803:./Eigen/src/Core/AssignEvaluator.h **** 
 804:./Eigen/src/Core/AssignEvaluator.h **** /***************************************************************************
 805:./Eigen/src/Core/AssignEvaluator.h **** * Part 6 : Generic assignment
 806:./Eigen/src/Core/AssignEvaluator.h **** ***************************************************************************/
 807:./Eigen/src/Core/AssignEvaluator.h **** 
 808:./Eigen/src/Core/AssignEvaluator.h **** // Based on the respective shapes of the destination and source,
 809:./Eigen/src/Core/AssignEvaluator.h **** // the class AssignmentKind determine the kind of assignment mechanism.
 810:./Eigen/src/Core/AssignEvaluator.h **** // AssignmentKind must define a Kind typedef.
 811:./Eigen/src/Core/AssignEvaluator.h **** template<typename DstShape, typename SrcShape> struct AssignmentKind;
 812:./Eigen/src/Core/AssignEvaluator.h **** 
 813:./Eigen/src/Core/AssignEvaluator.h **** // Assignment kind defined in this file:
 814:./Eigen/src/Core/AssignEvaluator.h **** struct Dense2Dense {};
 815:./Eigen/src/Core/AssignEvaluator.h **** struct EigenBase2EigenBase {};
 816:./Eigen/src/Core/AssignEvaluator.h **** 
 817:./Eigen/src/Core/AssignEvaluator.h **** template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };
 818:./Eigen/src/Core/AssignEvaluator.h **** template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };
 819:./Eigen/src/Core/AssignEvaluator.h **** 
 820:./Eigen/src/Core/AssignEvaluator.h **** // This is the main assignment class
 821:./Eigen/src/Core/AssignEvaluator.h **** template< typename DstXprType, typename SrcXprType, typename Functor,
 822:./Eigen/src/Core/AssignEvaluator.h ****           typename Kind = typename AssignmentKind< typename evaluator_traits<DstXprType>::Shape , t
 823:./Eigen/src/Core/AssignEvaluator.h ****           typename EnableIf = void>
 824:./Eigen/src/Core/AssignEvaluator.h **** struct Assignment;
 825:./Eigen/src/Core/AssignEvaluator.h **** 
 826:./Eigen/src/Core/AssignEvaluator.h **** 
 827:./Eigen/src/Core/AssignEvaluator.h **** // The only purpose of this call_assignment() function is to deal with noalias() / "assume-aliasing
 828:./Eigen/src/Core/AssignEvaluator.h **** // Indeed, I (Gael) think that this concept of "assume-aliasing" was a mistake, and it makes thing 
 829:./Eigen/src/Core/AssignEvaluator.h **** // So this intermediate function removes everything related to "assume-aliasing" such that Assignme
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 97


 830:./Eigen/src/Core/AssignEvaluator.h **** // does not has to bother about these annoying details.
 831:./Eigen/src/Core/AssignEvaluator.h **** 
 832:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src>
 833:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 834:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment(Dst& dst, const Src& src)
 835:./Eigen/src/Core/AssignEvaluator.h **** {
 836:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());
 837:./Eigen/src/Core/AssignEvaluator.h **** }
 838:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src>
 839:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 840:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment(const Dst& dst, const Src& src)
 841:./Eigen/src/Core/AssignEvaluator.h **** {
 842:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());
 843:./Eigen/src/Core/AssignEvaluator.h **** }
 844:./Eigen/src/Core/AssignEvaluator.h **** 
 845:./Eigen/src/Core/AssignEvaluator.h **** // Deal with "assume-aliasing"
 846:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src, typename Func>
 847:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 848:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if< evaluator_assu
 849:./Eigen/src/Core/AssignEvaluator.h **** {
 850:./Eigen/src/Core/AssignEvaluator.h ****   typename plain_matrix_type<Src>::type tmp(src);
 851:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment_no_alias(dst, tmp, func);
 852:./Eigen/src/Core/AssignEvaluator.h **** }
 853:./Eigen/src/Core/AssignEvaluator.h **** 
 854:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src, typename Func>
 855:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 856:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if<!evaluator_assu
 857:./Eigen/src/Core/AssignEvaluator.h **** {
 858:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment_no_alias(dst, src, func);
 859:./Eigen/src/Core/AssignEvaluator.h **** }
 860:./Eigen/src/Core/AssignEvaluator.h **** 
 861:./Eigen/src/Core/AssignEvaluator.h **** // by-pass "assume-aliasing"
 862:./Eigen/src/Core/AssignEvaluator.h **** // When there is no aliasing, we require that 'dst' has been properly resized
 863:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, template <typename> class StorageBase, typename Src, typename Func>
 864:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 865:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment(NoAlias<Dst,StorageBase>& dst, const Src& src, const Func& func)
 866:./Eigen/src/Core/AssignEvaluator.h **** {
 867:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment_no_alias(dst.expression(), src, func);
 868:./Eigen/src/Core/AssignEvaluator.h **** }
 869:./Eigen/src/Core/AssignEvaluator.h **** 
 870:./Eigen/src/Core/AssignEvaluator.h **** 
 871:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src, typename Func>
 872:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 873:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment_no_alias(Dst& dst, const Src& src, const Func& func)
 828              		.loc 9 873 6 is_stmt 1 view .LVU119
 829              	.LBB359:
 830              	.LBB360:
 831              	.LBI360:
 874:./Eigen/src/Core/AssignEvaluator.h **** {
 875:./Eigen/src/Core/AssignEvaluator.h ****   enum {
 876:./Eigen/src/Core/AssignEvaluator.h ****     NeedToTranspose = (    (int(Dst::RowsAtCompileTime) == 1 && int(Src::ColsAtCompileTime) == 1)
 877:./Eigen/src/Core/AssignEvaluator.h ****                         || (int(Dst::ColsAtCompileTime) == 1 && int(Src::RowsAtCompileTime) == 1)
 878:./Eigen/src/Core/AssignEvaluator.h ****                       ) && int(Dst::SizeAtCompileTime) != 1
 879:./Eigen/src/Core/AssignEvaluator.h ****   };
 880:./Eigen/src/Core/AssignEvaluator.h **** 
 881:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst>::type ActualDstTypeC
 882:./Eigen/src/Core/AssignEvaluator.h ****   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 98


 883:./Eigen/src/Core/AssignEvaluator.h ****   ActualDstType actualDst(dst);
 884:./Eigen/src/Core/AssignEvaluator.h **** 
 885:./Eigen/src/Core/AssignEvaluator.h ****   // TODO check whether this is the right place to perform these checks:
 886:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_STATIC_ASSERT_LVALUE(Dst)
 887:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(ActualDstTypeCleaned,Src)
 888:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename ActualDstTypeCleaned::Scalar,typename Src::Scalar);
 889:./Eigen/src/Core/AssignEvaluator.h **** 
 890:./Eigen/src/Core/AssignEvaluator.h ****   Assignment<ActualDstTypeCleaned,Src,Func>::run(actualDst, src, func);
 891:./Eigen/src/Core/AssignEvaluator.h **** }
 892:./Eigen/src/Core/AssignEvaluator.h **** 
 893:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src, typename Func>
 894:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 895:./Eigen/src/Core/AssignEvaluator.h **** void call_restricted_packet_assignment_no_alias(Dst& dst, const Src& src, const Func& func)
 896:./Eigen/src/Core/AssignEvaluator.h **** {
 897:./Eigen/src/Core/AssignEvaluator.h ****     typedef evaluator<Dst> DstEvaluatorType;
 898:./Eigen/src/Core/AssignEvaluator.h ****     typedef evaluator<Src> SrcEvaluatorType;
 899:./Eigen/src/Core/AssignEvaluator.h ****     typedef restricted_packet_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Func> Kerne
 900:./Eigen/src/Core/AssignEvaluator.h **** 
 901:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_STATIC_ASSERT_LVALUE(Dst)
 902:./Eigen/src/Core/AssignEvaluator.h ****     EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename Dst::Scalar,typename Src::Scalar);
 903:./Eigen/src/Core/AssignEvaluator.h **** 
 904:./Eigen/src/Core/AssignEvaluator.h ****     SrcEvaluatorType srcEvaluator(src);
 905:./Eigen/src/Core/AssignEvaluator.h ****     resize_if_allowed(dst, src, func);
 906:./Eigen/src/Core/AssignEvaluator.h **** 
 907:./Eigen/src/Core/AssignEvaluator.h ****     DstEvaluatorType dstEvaluator(dst);
 908:./Eigen/src/Core/AssignEvaluator.h ****     Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
 909:./Eigen/src/Core/AssignEvaluator.h **** 
 910:./Eigen/src/Core/AssignEvaluator.h ****     dense_assignment_loop<Kernel>::run(kernel);
 911:./Eigen/src/Core/AssignEvaluator.h **** }
 912:./Eigen/src/Core/AssignEvaluator.h **** 
 913:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src>
 914:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 915:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment_no_alias(Dst& dst, const Src& src)
 916:./Eigen/src/Core/AssignEvaluator.h **** {
 917:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment_no_alias(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>
 918:./Eigen/src/Core/AssignEvaluator.h **** }
 919:./Eigen/src/Core/AssignEvaluator.h **** 
 920:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src, typename Func>
 921:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 922:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src, const Func& func)
 923:./Eigen/src/Core/AssignEvaluator.h **** {
 924:./Eigen/src/Core/AssignEvaluator.h ****   // TODO check whether this is the right place to perform these checks:
 925:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_STATIC_ASSERT_LVALUE(Dst)
 926:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Dst,Src)
 927:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename Dst::Scalar,typename Src::Scalar);
 928:./Eigen/src/Core/AssignEvaluator.h **** 
 929:./Eigen/src/Core/AssignEvaluator.h ****   Assignment<Dst,Src,Func>::run(dst, src, func);
 930:./Eigen/src/Core/AssignEvaluator.h **** }
 931:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src>
 932:./Eigen/src/Core/AssignEvaluator.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 933:./Eigen/src/Core/AssignEvaluator.h **** void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src)
 934:./Eigen/src/Core/AssignEvaluator.h **** {
 935:./Eigen/src/Core/AssignEvaluator.h ****   call_assignment_no_alias_no_transpose(dst, src, internal::assign_op<typename Dst::Scalar,typename
 936:./Eigen/src/Core/AssignEvaluator.h **** }
 937:./Eigen/src/Core/AssignEvaluator.h **** 
 938:./Eigen/src/Core/AssignEvaluator.h **** // forward declaration
 939:./Eigen/src/Core/AssignEvaluator.h **** template<typename Dst, typename Src> void check_for_aliasing(const Dst &dst, const Src &src);
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 99


 940:./Eigen/src/Core/AssignEvaluator.h **** 
 941:./Eigen/src/Core/AssignEvaluator.h **** // Generic Dense to Dense assignment
 942:./Eigen/src/Core/AssignEvaluator.h **** // Note that the last template argument "Weak" is needed to make it possible to perform
 943:./Eigen/src/Core/AssignEvaluator.h **** // both partial specialization+SFINAE without ambiguous specialization
 944:./Eigen/src/Core/AssignEvaluator.h **** template< typename DstXprType, typename SrcXprType, typename Functor, typename Weak>
 945:./Eigen/src/Core/AssignEvaluator.h **** struct Assignment<DstXprType, SrcXprType, Functor, Dense2Dense, Weak>
 946:./Eigen/src/Core/AssignEvaluator.h **** {
 947:./Eigen/src/Core/AssignEvaluator.h ****   EIGEN_DEVICE_FUNC
 948:./Eigen/src/Core/AssignEvaluator.h ****   static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
 832              		.loc 9 948 35 view .LVU120
 833              	.LBB361:
 834              	.LBI361:
 769:./Eigen/src/Core/AssignEvaluator.h **** {
 835              		.loc 9 769 44 view .LVU121
 836              	.LBB362:
 837              	.LBB363:
 838              	.LBI363:
 514:./Eigen/src/Core/CoreEvaluators.h ****     : m_functor(n.functor()), m_wrapper()
 839              		.loc 10 514 30 view .LVU122
 840              	.LBB364:
 841              	.LBB365:
 842              	.LBI365:
 121:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
 843              		.loc 10 121 41 view .LVU123
 121:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
 844              		.loc 10 121 41 is_stmt 0 view .LVU124
 845              	.LBE365:
 846              	.LBB366:
 847              	.LBI366:
  76:./Eigen/src/Core/CwiseNullaryOp.h **** 
  77:./Eigen/src/Core/CwiseNullaryOp.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
  78:./Eigen/src/Core/CwiseNullaryOp.h ****     Index rows() const { return m_rows.value(); }
  79:./Eigen/src/Core/CwiseNullaryOp.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
  80:./Eigen/src/Core/CwiseNullaryOp.h ****     Index cols() const { return m_cols.value(); }
  81:./Eigen/src/Core/CwiseNullaryOp.h **** 
  82:./Eigen/src/Core/CwiseNullaryOp.h ****     /** \returns the functor representing the nullary operation */
  83:./Eigen/src/Core/CwiseNullaryOp.h ****     EIGEN_DEVICE_FUNC
  84:./Eigen/src/Core/CwiseNullaryOp.h ****     const NullaryOp& functor() const { return m_functor; }
 848              		.loc 3 84 22 is_stmt 1 view .LVU125
 849              		.loc 3 84 22 is_stmt 0 view .LVU126
 850              	.LBE366:
 851              	.LBB367:
 852              	.LBI367:
  18:./Eigen/src/Core/Random.h ****   inline const Scalar operator() () const { return random<Scalar>(); }
 853              		.loc 6 18 3 is_stmt 1 view .LVU127
  18:./Eigen/src/Core/Random.h ****   inline const Scalar operator() () const { return random<Scalar>(); }
 854              		.loc 6 18 3 is_stmt 0 view .LVU128
 855              	.LBE367:
 856              	.LBE364:
 857              	.LBE363:
 858              	.LBB368:
 859              	.LBI368:
 282:./Eigen/src/Core/CoreEvaluators.h ****     : evaluator<PlainObjectBase<XprType> >(m)
 860              		.loc 10 282 12 is_stmt 1 view .LVU129
 861              	.LBB369:
 862              	.LBB370:
 863              	.LBI370:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 100


 195:./Eigen/src/Core/CoreEvaluators.h ****     : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())
 864              		.loc 10 195 12 view .LVU130
 865              	.LBB371:
 866              	.LBB372:
 867              	.LBI372:
 121:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
 868              		.loc 10 121 41 view .LVU131
 121:./Eigen/src/Core/CoreEvaluators.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
 869              		.loc 10 121 41 is_stmt 0 view .LVU132
 870              	.LBE372:
 871              	.LBB373:
 872              	.LBI373:
 247:./Eigen/src/Core/PlainObjectBase.h ****     { return m_storage.data(); }
 873              		.loc 7 247 57 is_stmt 1 view .LVU133
 874              	.LBB374:
 875              	.LBI374:
 876              		.file 12 "./Eigen/src/Core/DenseStorage.h"
   1:./Eigen/src/Core/DenseStorage.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/DenseStorage.h **** // for linear algebra.
   3:./Eigen/src/Core/DenseStorage.h **** //
   4:./Eigen/src/Core/DenseStorage.h **** // Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/DenseStorage.h **** // Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>
   6:./Eigen/src/Core/DenseStorage.h **** // Copyright (C) 2010-2013 Hauke Heibel <hauke.heibel@gmail.com>
   7:./Eigen/src/Core/DenseStorage.h **** //
   8:./Eigen/src/Core/DenseStorage.h **** // This Source Code Form is subject to the terms of the Mozilla
   9:./Eigen/src/Core/DenseStorage.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
  10:./Eigen/src/Core/DenseStorage.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  11:./Eigen/src/Core/DenseStorage.h **** 
  12:./Eigen/src/Core/DenseStorage.h **** #ifndef EIGEN_MATRIXSTORAGE_H
  13:./Eigen/src/Core/DenseStorage.h **** #define EIGEN_MATRIXSTORAGE_H
  14:./Eigen/src/Core/DenseStorage.h **** 
  15:./Eigen/src/Core/DenseStorage.h **** #ifdef EIGEN_DENSE_STORAGE_CTOR_PLUGIN
  16:./Eigen/src/Core/DenseStorage.h ****   #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(X) X; EIGEN_DENSE_STORAGE_CTOR_PLUGIN;
  17:./Eigen/src/Core/DenseStorage.h **** #else
  18:./Eigen/src/Core/DenseStorage.h ****   #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(X)
  19:./Eigen/src/Core/DenseStorage.h **** #endif
  20:./Eigen/src/Core/DenseStorage.h **** 
  21:./Eigen/src/Core/DenseStorage.h **** namespace Eigen {
  22:./Eigen/src/Core/DenseStorage.h **** 
  23:./Eigen/src/Core/DenseStorage.h **** namespace internal {
  24:./Eigen/src/Core/DenseStorage.h **** 
  25:./Eigen/src/Core/DenseStorage.h **** struct constructor_without_unaligned_array_assert {};
  26:./Eigen/src/Core/DenseStorage.h **** 
  27:./Eigen/src/Core/DenseStorage.h **** template<typename T, int Size>
  28:./Eigen/src/Core/DenseStorage.h **** EIGEN_DEVICE_FUNC
  29:./Eigen/src/Core/DenseStorage.h **** void check_static_allocation_size()
  30:./Eigen/src/Core/DenseStorage.h **** {
  31:./Eigen/src/Core/DenseStorage.h ****   // if EIGEN_STACK_ALLOCATION_LIMIT is defined to 0, then no limit
  32:./Eigen/src/Core/DenseStorage.h ****   #if EIGEN_STACK_ALLOCATION_LIMIT
  33:./Eigen/src/Core/DenseStorage.h ****   EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_I
  34:./Eigen/src/Core/DenseStorage.h ****   #endif
  35:./Eigen/src/Core/DenseStorage.h **** }
  36:./Eigen/src/Core/DenseStorage.h **** 
  37:./Eigen/src/Core/DenseStorage.h **** /** \internal
  38:./Eigen/src/Core/DenseStorage.h ****   * Static array. If the MatrixOrArrayOptions require auto-alignment, the array will be automatical
  39:./Eigen/src/Core/DenseStorage.h ****   * to 16 bytes boundary if the total size is a multiple of 16 bytes.
  40:./Eigen/src/Core/DenseStorage.h ****   */
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 101


  41:./Eigen/src/Core/DenseStorage.h **** template <typename T, int Size, int MatrixOrArrayOptions,
  42:./Eigen/src/Core/DenseStorage.h ****           int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0
  43:./Eigen/src/Core/DenseStorage.h ****                         : compute_default_alignment<T,Size>::value >
  44:./Eigen/src/Core/DenseStorage.h **** struct plain_array
  45:./Eigen/src/Core/DenseStorage.h **** {
  46:./Eigen/src/Core/DenseStorage.h ****   T array[Size];
  47:./Eigen/src/Core/DenseStorage.h **** 
  48:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
  49:./Eigen/src/Core/DenseStorage.h ****   plain_array()
  50:./Eigen/src/Core/DenseStorage.h ****   {
  51:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
  52:./Eigen/src/Core/DenseStorage.h ****   }
  53:./Eigen/src/Core/DenseStorage.h **** 
  54:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
  55:./Eigen/src/Core/DenseStorage.h ****   plain_array(constructor_without_unaligned_array_assert)
  56:./Eigen/src/Core/DenseStorage.h ****   {
  57:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
  58:./Eigen/src/Core/DenseStorage.h ****   }
  59:./Eigen/src/Core/DenseStorage.h **** };
  60:./Eigen/src/Core/DenseStorage.h **** 
  61:./Eigen/src/Core/DenseStorage.h **** #if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)
  62:./Eigen/src/Core/DenseStorage.h ****   #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)
  63:./Eigen/src/Core/DenseStorage.h **** #elif EIGEN_GNUC_AT_LEAST(4,7)
  64:./Eigen/src/Core/DenseStorage.h ****   // GCC 4.7 is too aggressive in its optimizations and remove the alignment test based on the fact
  65:./Eigen/src/Core/DenseStorage.h ****   // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900
  66:./Eigen/src/Core/DenseStorage.h ****   // Hiding the origin of the array pointer behind a function argument seems to do the trick even i
  67:./Eigen/src/Core/DenseStorage.h ****   template<typename PtrType>
  68:./Eigen/src/Core/DenseStorage.h ****   EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return
  69:./Eigen/src/Core/DenseStorage.h ****   #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
  70:./Eigen/src/Core/DenseStorage.h ****     eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizema
  71:./Eigen/src/Core/DenseStorage.h ****               && "this assertion is explained here: " \
  72:./Eigen/src/Core/DenseStorage.h ****               "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
  73:./Eigen/src/Core/DenseStorage.h ****               " **** READ THIS WEB PAGE !!! ****");
  74:./Eigen/src/Core/DenseStorage.h **** #else
  75:./Eigen/src/Core/DenseStorage.h ****   #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
  76:./Eigen/src/Core/DenseStorage.h ****     eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \
  77:./Eigen/src/Core/DenseStorage.h ****               && "this assertion is explained here: " \
  78:./Eigen/src/Core/DenseStorage.h ****               "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
  79:./Eigen/src/Core/DenseStorage.h ****               " **** READ THIS WEB PAGE !!! ****");
  80:./Eigen/src/Core/DenseStorage.h **** #endif
  81:./Eigen/src/Core/DenseStorage.h **** 
  82:./Eigen/src/Core/DenseStorage.h **** template <typename T, int Size, int MatrixOrArrayOptions>
  83:./Eigen/src/Core/DenseStorage.h **** struct plain_array<T, Size, MatrixOrArrayOptions, 8>
  84:./Eigen/src/Core/DenseStorage.h **** {
  85:./Eigen/src/Core/DenseStorage.h ****   EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];
  86:./Eigen/src/Core/DenseStorage.h **** 
  87:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
  88:./Eigen/src/Core/DenseStorage.h ****   plain_array()
  89:./Eigen/src/Core/DenseStorage.h ****   {
  90:./Eigen/src/Core/DenseStorage.h ****     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(7);
  91:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
  92:./Eigen/src/Core/DenseStorage.h ****   }
  93:./Eigen/src/Core/DenseStorage.h **** 
  94:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
  95:./Eigen/src/Core/DenseStorage.h ****   plain_array(constructor_without_unaligned_array_assert)
  96:./Eigen/src/Core/DenseStorage.h ****   {
  97:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 102


  98:./Eigen/src/Core/DenseStorage.h ****   }
  99:./Eigen/src/Core/DenseStorage.h **** };
 100:./Eigen/src/Core/DenseStorage.h **** 
 101:./Eigen/src/Core/DenseStorage.h **** template <typename T, int Size, int MatrixOrArrayOptions>
 102:./Eigen/src/Core/DenseStorage.h **** struct plain_array<T, Size, MatrixOrArrayOptions, 16>
 103:./Eigen/src/Core/DenseStorage.h **** {
 104:./Eigen/src/Core/DenseStorage.h ****   EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];
 105:./Eigen/src/Core/DenseStorage.h **** 
 106:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 107:./Eigen/src/Core/DenseStorage.h ****   plain_array()
 108:./Eigen/src/Core/DenseStorage.h ****   {
 109:./Eigen/src/Core/DenseStorage.h ****     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);
 110:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
 111:./Eigen/src/Core/DenseStorage.h ****   }
 112:./Eigen/src/Core/DenseStorage.h **** 
 113:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 114:./Eigen/src/Core/DenseStorage.h ****   plain_array(constructor_without_unaligned_array_assert)
 115:./Eigen/src/Core/DenseStorage.h ****   {
 116:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
 117:./Eigen/src/Core/DenseStorage.h ****   }
 118:./Eigen/src/Core/DenseStorage.h **** };
 119:./Eigen/src/Core/DenseStorage.h **** 
 120:./Eigen/src/Core/DenseStorage.h **** template <typename T, int Size, int MatrixOrArrayOptions>
 121:./Eigen/src/Core/DenseStorage.h **** struct plain_array<T, Size, MatrixOrArrayOptions, 32>
 122:./Eigen/src/Core/DenseStorage.h **** {
 123:./Eigen/src/Core/DenseStorage.h ****   EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];
 124:./Eigen/src/Core/DenseStorage.h **** 
 125:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 126:./Eigen/src/Core/DenseStorage.h ****   plain_array()
 127:./Eigen/src/Core/DenseStorage.h ****   {
 128:./Eigen/src/Core/DenseStorage.h ****     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(31);
 129:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
 130:./Eigen/src/Core/DenseStorage.h ****   }
 131:./Eigen/src/Core/DenseStorage.h **** 
 132:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 133:./Eigen/src/Core/DenseStorage.h ****   plain_array(constructor_without_unaligned_array_assert)
 134:./Eigen/src/Core/DenseStorage.h ****   {
 135:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
 136:./Eigen/src/Core/DenseStorage.h ****   }
 137:./Eigen/src/Core/DenseStorage.h **** };
 138:./Eigen/src/Core/DenseStorage.h **** 
 139:./Eigen/src/Core/DenseStorage.h **** template <typename T, int Size, int MatrixOrArrayOptions>
 140:./Eigen/src/Core/DenseStorage.h **** struct plain_array<T, Size, MatrixOrArrayOptions, 64>
 141:./Eigen/src/Core/DenseStorage.h **** {
 142:./Eigen/src/Core/DenseStorage.h ****   EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];
 143:./Eigen/src/Core/DenseStorage.h **** 
 144:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 145:./Eigen/src/Core/DenseStorage.h ****   plain_array()
 146:./Eigen/src/Core/DenseStorage.h ****   {
 147:./Eigen/src/Core/DenseStorage.h ****     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(63);
 148:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
 149:./Eigen/src/Core/DenseStorage.h ****   }
 150:./Eigen/src/Core/DenseStorage.h **** 
 151:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC
 152:./Eigen/src/Core/DenseStorage.h ****   plain_array(constructor_without_unaligned_array_assert)
 153:./Eigen/src/Core/DenseStorage.h ****   {
 154:./Eigen/src/Core/DenseStorage.h ****     check_static_allocation_size<T,Size>();
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 103


 155:./Eigen/src/Core/DenseStorage.h ****   }
 156:./Eigen/src/Core/DenseStorage.h **** };
 157:./Eigen/src/Core/DenseStorage.h **** 
 158:./Eigen/src/Core/DenseStorage.h **** template <typename T, int MatrixOrArrayOptions, int Alignment>
 159:./Eigen/src/Core/DenseStorage.h **** struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>
 160:./Eigen/src/Core/DenseStorage.h **** {
 161:./Eigen/src/Core/DenseStorage.h ****   T array[1];
 162:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC plain_array() {}
 163:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}
 164:./Eigen/src/Core/DenseStorage.h **** };
 165:./Eigen/src/Core/DenseStorage.h **** 
 166:./Eigen/src/Core/DenseStorage.h **** struct plain_array_helper {
 167:./Eigen/src/Core/DenseStorage.h ****   template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>
 168:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 169:./Eigen/src/Core/DenseStorage.h ****   static void copy(const plain_array<T, Size, MatrixOrArrayOptions, Alignment>& src, const Eigen::I
 170:./Eigen/src/Core/DenseStorage.h ****                          plain_array<T, Size, MatrixOrArrayOptions, Alignment>& dst) {
 171:./Eigen/src/Core/DenseStorage.h ****     smart_copy(src.array, src.array + size, dst.array);
 172:./Eigen/src/Core/DenseStorage.h ****   }
 173:./Eigen/src/Core/DenseStorage.h ****   
 174:./Eigen/src/Core/DenseStorage.h ****   template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>
 175:./Eigen/src/Core/DenseStorage.h ****   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 176:./Eigen/src/Core/DenseStorage.h ****   static void swap(plain_array<T, Size, MatrixOrArrayOptions, Alignment>& a, const Eigen::Index a_s
 177:./Eigen/src/Core/DenseStorage.h ****                    plain_array<T, Size, MatrixOrArrayOptions, Alignment>& b, const Eigen::Index b_s
 178:./Eigen/src/Core/DenseStorage.h ****     if (a_size < b_size) {
 179:./Eigen/src/Core/DenseStorage.h ****       std::swap_ranges(b.array, b.array + a_size, a.array);
 180:./Eigen/src/Core/DenseStorage.h ****       smart_move(b.array + a_size, b.array + b_size, a.array + a_size);
 181:./Eigen/src/Core/DenseStorage.h ****     } else if (a_size > b_size) {
 182:./Eigen/src/Core/DenseStorage.h ****       std::swap_ranges(a.array, a.array + b_size, b.array);
 183:./Eigen/src/Core/DenseStorage.h ****       smart_move(a.array + b_size, a.array + a_size, b.array + b_size);
 184:./Eigen/src/Core/DenseStorage.h ****     } else {
 185:./Eigen/src/Core/DenseStorage.h ****       std::swap_ranges(a.array, a.array + a_size, b.array);
 186:./Eigen/src/Core/DenseStorage.h ****     }
 187:./Eigen/src/Core/DenseStorage.h ****   }
 188:./Eigen/src/Core/DenseStorage.h **** };
 189:./Eigen/src/Core/DenseStorage.h **** 
 190:./Eigen/src/Core/DenseStorage.h **** } // end namespace internal
 191:./Eigen/src/Core/DenseStorage.h **** 
 192:./Eigen/src/Core/DenseStorage.h **** /** \internal
 193:./Eigen/src/Core/DenseStorage.h ****   *
 194:./Eigen/src/Core/DenseStorage.h ****   * \class DenseStorage
 195:./Eigen/src/Core/DenseStorage.h ****   * \ingroup Core_Module
 196:./Eigen/src/Core/DenseStorage.h ****   *
 197:./Eigen/src/Core/DenseStorage.h ****   * \brief Stores the data of a matrix
 198:./Eigen/src/Core/DenseStorage.h ****   *
 199:./Eigen/src/Core/DenseStorage.h ****   * This class stores the data of fixed-size, dynamic-size or mixed matrices
 200:./Eigen/src/Core/DenseStorage.h ****   * in a way as compact as possible.
 201:./Eigen/src/Core/DenseStorage.h ****   *
 202:./Eigen/src/Core/DenseStorage.h ****   * \sa Matrix
 203:./Eigen/src/Core/DenseStorage.h ****   */
 204:./Eigen/src/Core/DenseStorage.h **** template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage;
 205:./Eigen/src/Core/DenseStorage.h **** 
 206:./Eigen/src/Core/DenseStorage.h **** // purely fixed-size matrix
 207:./Eigen/src/Core/DenseStorage.h **** template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage
 208:./Eigen/src/Core/DenseStorage.h **** {
 209:./Eigen/src/Core/DenseStorage.h ****     internal::plain_array<T,Size,_Options> m_data;
 210:./Eigen/src/Core/DenseStorage.h ****   public:
 211:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage() {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 104


 212:./Eigen/src/Core/DenseStorage.h ****       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
 213:./Eigen/src/Core/DenseStorage.h ****     }
 214:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC
 215:./Eigen/src/Core/DenseStorage.h ****     explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
 216:./Eigen/src/Core/DenseStorage.h ****       : m_data(internal::constructor_without_unaligned_array_assert()) {}
 217:./Eigen/src/Core/DenseStorage.h **** #if !EIGEN_HAS_CXX11 || defined(EIGEN_DENSE_STORAGE_CTOR_PLUGIN)
 218:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC
 219:./Eigen/src/Core/DenseStorage.h ****     DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
 220:./Eigen/src/Core/DenseStorage.h ****       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
 221:./Eigen/src/Core/DenseStorage.h ****     }
 222:./Eigen/src/Core/DenseStorage.h **** #else
 223:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) = default;
 224:./Eigen/src/Core/DenseStorage.h **** #endif
 225:./Eigen/src/Core/DenseStorage.h **** #if !EIGEN_HAS_CXX11
 226:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC
 227:./Eigen/src/Core/DenseStorage.h ****     DenseStorage& operator=(const DenseStorage& other)
 228:./Eigen/src/Core/DenseStorage.h ****     {
 229:./Eigen/src/Core/DenseStorage.h ****       if (this != &other) m_data = other.m_data;
 230:./Eigen/src/Core/DenseStorage.h ****       return *this;
 231:./Eigen/src/Core/DenseStorage.h ****     }
 232:./Eigen/src/Core/DenseStorage.h **** #else
 233:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) = default;
 234:./Eigen/src/Core/DenseStorage.h **** #endif
 235:./Eigen/src/Core/DenseStorage.h **** #if EIGEN_HAS_RVALUE_REFERENCES
 236:./Eigen/src/Core/DenseStorage.h **** #if !EIGEN_HAS_CXX11
 237:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
 238:./Eigen/src/Core/DenseStorage.h ****       : m_data(std::move(other.m_data))
 239:./Eigen/src/Core/DenseStorage.h ****     {
 240:./Eigen/src/Core/DenseStorage.h ****     }
 241:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
 242:./Eigen/src/Core/DenseStorage.h ****     {
 243:./Eigen/src/Core/DenseStorage.h ****       if (this != &other)
 244:./Eigen/src/Core/DenseStorage.h ****         m_data = std::move(other.m_data);
 245:./Eigen/src/Core/DenseStorage.h ****       return *this;
 246:./Eigen/src/Core/DenseStorage.h ****     }
 247:./Eigen/src/Core/DenseStorage.h **** #else
 248:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&&) = default;
 249:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&&) = default;
 250:./Eigen/src/Core/DenseStorage.h **** #endif
 251:./Eigen/src/Core/DenseStorage.h **** #endif
 252:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {
 253:./Eigen/src/Core/DenseStorage.h ****       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
 254:./Eigen/src/Core/DenseStorage.h ****       eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols);
 255:./Eigen/src/Core/DenseStorage.h ****       EIGEN_UNUSED_VARIABLE(size);
 256:./Eigen/src/Core/DenseStorage.h ****       EIGEN_UNUSED_VARIABLE(rows);
 257:./Eigen/src/Core/DenseStorage.h ****       EIGEN_UNUSED_VARIABLE(cols);
 258:./Eigen/src/Core/DenseStorage.h ****     }
 259:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {
 260:./Eigen/src/Core/DenseStorage.h ****       numext::swap(m_data, other.m_data);
 261:./Eigen/src/Core/DenseStorage.h ****     }
 262:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}
 263:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return _Cols;}
 264:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
 265:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
 266:./Eigen/src/Core/DenseStorage.h ****     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
 877              		.loc 12 266 32 view .LVU134
 878              		.loc 12 266 32 is_stmt 0 view .LVU135
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 105


 879              	.LBE374:
 880              	.LBE373:
 881              	.LBB375:
 882              	.LBI375:
 883              		.file 13 "./Eigen/src/Core/DenseCoeffsBase.h"
   1:./Eigen/src/Core/DenseCoeffsBase.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/DenseCoeffsBase.h **** // for linear algebra.
   3:./Eigen/src/Core/DenseCoeffsBase.h **** //
   4:./Eigen/src/Core/DenseCoeffsBase.h **** // Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/DenseCoeffsBase.h **** //
   6:./Eigen/src/Core/DenseCoeffsBase.h **** // This Source Code Form is subject to the terms of the Mozilla
   7:./Eigen/src/Core/DenseCoeffsBase.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   8:./Eigen/src/Core/DenseCoeffsBase.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
   9:./Eigen/src/Core/DenseCoeffsBase.h **** 
  10:./Eigen/src/Core/DenseCoeffsBase.h **** #ifndef EIGEN_DENSECOEFFSBASE_H
  11:./Eigen/src/Core/DenseCoeffsBase.h **** #define EIGEN_DENSECOEFFSBASE_H
  12:./Eigen/src/Core/DenseCoeffsBase.h **** 
  13:./Eigen/src/Core/DenseCoeffsBase.h **** namespace Eigen {
  14:./Eigen/src/Core/DenseCoeffsBase.h **** 
  15:./Eigen/src/Core/DenseCoeffsBase.h **** namespace internal {
  16:./Eigen/src/Core/DenseCoeffsBase.h **** template<typename T> struct add_const_on_value_type_if_arithmetic
  17:./Eigen/src/Core/DenseCoeffsBase.h **** {
  18:./Eigen/src/Core/DenseCoeffsBase.h ****   typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::typ
  19:./Eigen/src/Core/DenseCoeffsBase.h **** };
  20:./Eigen/src/Core/DenseCoeffsBase.h **** }
  21:./Eigen/src/Core/DenseCoeffsBase.h **** 
  22:./Eigen/src/Core/DenseCoeffsBase.h **** /** \brief Base class providing read-only coefficient access to matrices and arrays.
  23:./Eigen/src/Core/DenseCoeffsBase.h ****   * \ingroup Core_Module
  24:./Eigen/src/Core/DenseCoeffsBase.h ****   * \tparam Derived Type of the derived class
  25:./Eigen/src/Core/DenseCoeffsBase.h ****   *
  26:./Eigen/src/Core/DenseCoeffsBase.h ****   * \note #ReadOnlyAccessors Constant indicating read-only access
  27:./Eigen/src/Core/DenseCoeffsBase.h ****   *
  28:./Eigen/src/Core/DenseCoeffsBase.h ****   * This class defines the \c operator() \c const function and friends, which can be used to read s
  29:./Eigen/src/Core/DenseCoeffsBase.h ****   * entries of a matrix or array.
  30:./Eigen/src/Core/DenseCoeffsBase.h ****   *
  31:./Eigen/src/Core/DenseCoeffsBase.h ****   * \sa DenseCoeffsBase<Derived, WriteAccessors>, DenseCoeffsBase<Derived, DirectAccessors>,
  32:./Eigen/src/Core/DenseCoeffsBase.h ****   *     \ref TopicClassHierarchy
  33:./Eigen/src/Core/DenseCoeffsBase.h ****   */
  34:./Eigen/src/Core/DenseCoeffsBase.h **** template<typename Derived>
  35:./Eigen/src/Core/DenseCoeffsBase.h **** class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>
  36:./Eigen/src/Core/DenseCoeffsBase.h **** {
  37:./Eigen/src/Core/DenseCoeffsBase.h ****   public:
  38:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::StorageKind StorageKind;
  39:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
  40:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
  41:./Eigen/src/Core/DenseCoeffsBase.h **** 
  42:./Eigen/src/Core/DenseCoeffsBase.h ****     // Explanation for this CoeffReturnType typedef.
  43:./Eigen/src/Core/DenseCoeffsBase.h ****     // - This is the return type of the coeff() method.
  44:./Eigen/src/Core/DenseCoeffsBase.h ****     // - The LvalueBit means exactly that we can offer a coeffRef() method, which means exactly tha
  45:./Eigen/src/Core/DenseCoeffsBase.h ****     // to coeffs, which means exactly that we can have coeff() return a const reference (as opposed
  46:./Eigen/src/Core/DenseCoeffsBase.h ****     // - The is_artihmetic check is required since "const int", "const double", etc. will cause war
  47:./Eigen/src/Core/DenseCoeffsBase.h ****     // while the declaration of "const T", where T is a non arithmetic type does not. Always return
  48:./Eigen/src/Core/DenseCoeffsBase.h ****     // not possible, since the underlying expressions might not offer a valid address the reference
  49:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::conditional<bool(internal::traits<Derived>::Flags&LvalueBit),
  50:./Eigen/src/Core/DenseCoeffsBase.h ****                          const Scalar&,
  51:./Eigen/src/Core/DenseCoeffsBase.h ****                          typename internal::conditional<internal::is_arithmetic<Scalar>::value, Sca
  52:./Eigen/src/Core/DenseCoeffsBase.h ****                      >::type CoeffReturnType;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 106


  53:./Eigen/src/Core/DenseCoeffsBase.h **** 
  54:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::add_const_on_value_type_if_arithmetic<
  55:./Eigen/src/Core/DenseCoeffsBase.h ****                          typename internal::packet_traits<Scalar>::type
  56:./Eigen/src/Core/DenseCoeffsBase.h ****                      >::type PacketReturnType;
  57:./Eigen/src/Core/DenseCoeffsBase.h **** 
  58:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef EigenBase<Derived> Base;
  59:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::rows;
  60:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::cols;
  61:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::size;
  62:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::derived;
  63:./Eigen/src/Core/DenseCoeffsBase.h **** 
  64:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
  65:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const
  66:./Eigen/src/Core/DenseCoeffsBase.h ****     {
  67:./Eigen/src/Core/DenseCoeffsBase.h ****       return int(Derived::RowsAtCompileTime) == 1 ? 0
  68:./Eigen/src/Core/DenseCoeffsBase.h ****           : int(Derived::ColsAtCompileTime) == 1 ? inner
  69:./Eigen/src/Core/DenseCoeffsBase.h ****           : int(Derived::Flags)&RowMajorBit ? outer
  70:./Eigen/src/Core/DenseCoeffsBase.h ****           : inner;
  71:./Eigen/src/Core/DenseCoeffsBase.h ****     }
  72:./Eigen/src/Core/DenseCoeffsBase.h **** 
  73:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
  74:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const
  75:./Eigen/src/Core/DenseCoeffsBase.h ****     {
  76:./Eigen/src/Core/DenseCoeffsBase.h ****       return int(Derived::ColsAtCompileTime) == 1 ? 0
  77:./Eigen/src/Core/DenseCoeffsBase.h ****           : int(Derived::RowsAtCompileTime) == 1 ? inner
  78:./Eigen/src/Core/DenseCoeffsBase.h ****           : int(Derived::Flags)&RowMajorBit ? inner
  79:./Eigen/src/Core/DenseCoeffsBase.h ****           : outer;
  80:./Eigen/src/Core/DenseCoeffsBase.h ****     }
  81:./Eigen/src/Core/DenseCoeffsBase.h **** 
  82:./Eigen/src/Core/DenseCoeffsBase.h ****     /** Short version: don't use this function, use
  83:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator()(Index,Index) const \endlink instead.
  84:./Eigen/src/Core/DenseCoeffsBase.h ****       *
  85:./Eigen/src/Core/DenseCoeffsBase.h ****       * Long version: this function is similar to
  86:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator()(Index,Index) const \endlink, but without the assertion.
  87:./Eigen/src/Core/DenseCoeffsBase.h ****       * Use this for limiting the performance cost of debugging code when doing
  88:./Eigen/src/Core/DenseCoeffsBase.h ****       * repeated coefficient access. Only use this when it is guaranteed that the
  89:./Eigen/src/Core/DenseCoeffsBase.h ****       * parameters \a row and \a col are in range.
  90:./Eigen/src/Core/DenseCoeffsBase.h ****       *
  91:./Eigen/src/Core/DenseCoeffsBase.h ****       * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
  92:./Eigen/src/Core/DenseCoeffsBase.h ****       * function equivalent to \link operator()(Index,Index) const \endlink.
  93:./Eigen/src/Core/DenseCoeffsBase.h ****       *
  94:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator()(Index,Index) const, coeffRef(Index,Index), coeff(Index) const
  95:./Eigen/src/Core/DenseCoeffsBase.h ****       */
  96:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
  97:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const
  98:./Eigen/src/Core/DenseCoeffsBase.h ****     {
  99:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(row >= 0 && row < rows()
 100:./Eigen/src/Core/DenseCoeffsBase.h ****                          && col >= 0 && col < cols());
 101:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).coeff(row,col);
 102:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 103:./Eigen/src/Core/DenseCoeffsBase.h **** 
 104:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 105:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const
 106:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 107:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeff(rowIndexByOuterInner(outer, inner),
 108:./Eigen/src/Core/DenseCoeffsBase.h ****                    colIndexByOuterInner(outer, inner));
 109:./Eigen/src/Core/DenseCoeffsBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 107


 110:./Eigen/src/Core/DenseCoeffsBase.h **** 
 111:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the coefficient at given the given row and column.
 112:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 113:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator()(Index,Index), operator[](Index)
 114:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 115:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 116:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const
 117:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 118:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(row >= 0 && row < rows()
 119:./Eigen/src/Core/DenseCoeffsBase.h ****           && col >= 0 && col < cols());
 120:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeff(row, col);
 121:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 122:./Eigen/src/Core/DenseCoeffsBase.h **** 
 123:./Eigen/src/Core/DenseCoeffsBase.h ****     /** Short version: don't use this function, use
 124:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator[](Index) const \endlink instead.
 125:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 126:./Eigen/src/Core/DenseCoeffsBase.h ****       * Long version: this function is similar to
 127:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator[](Index) const \endlink, but without the assertion.
 128:./Eigen/src/Core/DenseCoeffsBase.h ****       * Use this for limiting the performance cost of debugging code when doing
 129:./Eigen/src/Core/DenseCoeffsBase.h ****       * repeated coefficient access. Only use this when it is guaranteed that the
 130:./Eigen/src/Core/DenseCoeffsBase.h ****       * parameter \a index is in range.
 131:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 132:./Eigen/src/Core/DenseCoeffsBase.h ****       * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
 133:./Eigen/src/Core/DenseCoeffsBase.h ****       * function equivalent to \link operator[](Index) const \endlink.
 134:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 135:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index) const, coeffRef(Index), coeff(Index,Index) const
 136:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 137:./Eigen/src/Core/DenseCoeffsBase.h **** 
 138:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 139:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 140:./Eigen/src/Core/DenseCoeffsBase.h ****     coeff(Index index) const
 141:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 142:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
 143:./Eigen/src/Core/DenseCoeffsBase.h ****                           THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOW
 144:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(index >= 0 && index < size());
 145:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).coeff(index);
 146:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 147:./Eigen/src/Core/DenseCoeffsBase.h **** 
 148:./Eigen/src/Core/DenseCoeffsBase.h **** 
 149:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the coefficient at given index.
 150:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 151:./Eigen/src/Core/DenseCoeffsBase.h ****       * This method is allowed only for vector expressions, and for matrix expressions having the L
 152:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 153:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
 154:./Eigen/src/Core/DenseCoeffsBase.h ****       * z() const, w() const
 155:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 156:./Eigen/src/Core/DenseCoeffsBase.h **** 
 157:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 158:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 159:./Eigen/src/Core/DenseCoeffsBase.h ****     operator[](Index index) const
 160:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 161:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
 162:./Eigen/src/Core/DenseCoeffsBase.h ****                           THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_IN
 163:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(index >= 0 && index < size());
 164:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeff(index);
 165:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 166:./Eigen/src/Core/DenseCoeffsBase.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 108


 167:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the coefficient at given index.
 168:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 169:./Eigen/src/Core/DenseCoeffsBase.h ****       * This is synonymous to operator[](Index) const.
 170:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 171:./Eigen/src/Core/DenseCoeffsBase.h ****       * This method is allowed only for vector expressions, and for matrix expressions having the L
 172:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 173:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
 174:./Eigen/src/Core/DenseCoeffsBase.h ****       * z() const, w() const
 175:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 176:./Eigen/src/Core/DenseCoeffsBase.h **** 
 177:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 178:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 179:./Eigen/src/Core/DenseCoeffsBase.h ****     operator()(Index index) const
 180:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 181:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(index >= 0 && index < size());
 182:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeff(index);
 183:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 184:./Eigen/src/Core/DenseCoeffsBase.h **** 
 185:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](0).  */
 186:./Eigen/src/Core/DenseCoeffsBase.h **** 
 187:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 188:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 189:./Eigen/src/Core/DenseCoeffsBase.h ****     x() const { return (*this)[0]; }
 190:./Eigen/src/Core/DenseCoeffsBase.h **** 
 191:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](1).  */
 192:./Eigen/src/Core/DenseCoeffsBase.h **** 
 193:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 194:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 195:./Eigen/src/Core/DenseCoeffsBase.h ****     y() const
 196:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 197:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=2, OUT_OF_R
 198:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[1];
 199:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 200:./Eigen/src/Core/DenseCoeffsBase.h **** 
 201:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](2).  */
 202:./Eigen/src/Core/DenseCoeffsBase.h **** 
 203:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 204:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 205:./Eigen/src/Core/DenseCoeffsBase.h ****     z() const
 206:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 207:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=3, OUT_OF_R
 208:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[2];
 209:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 210:./Eigen/src/Core/DenseCoeffsBase.h **** 
 211:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](3).  */
 212:./Eigen/src/Core/DenseCoeffsBase.h **** 
 213:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 214:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE CoeffReturnType
 215:./Eigen/src/Core/DenseCoeffsBase.h ****     w() const
 216:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 217:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=4, OUT_OF_R
 218:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[3];
 219:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 220:./Eigen/src/Core/DenseCoeffsBase.h **** 
 221:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \internal
 222:./Eigen/src/Core/DenseCoeffsBase.h ****       * \returns the packet of coefficients starting at the given row and column. It is your respon
 223:./Eigen/src/Core/DenseCoeffsBase.h ****       * to ensure that a packet really starts there. This method is only available on expressions h
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 109


 224:./Eigen/src/Core/DenseCoeffsBase.h ****       * PacketAccessBit.
 225:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 226:./Eigen/src/Core/DenseCoeffsBase.h ****       * The \a LoadMode parameter may have the value \a #Aligned or \a #Unaligned. Its effect is to
 227:./Eigen/src/Core/DenseCoeffsBase.h ****       * the appropriate vectorization instruction. Aligned access is faster, but is only possible f
 228:./Eigen/src/Core/DenseCoeffsBase.h ****       * starting at an address which is a multiple of the packet size.
 229:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 230:./Eigen/src/Core/DenseCoeffsBase.h **** 
 231:./Eigen/src/Core/DenseCoeffsBase.h ****     template<int LoadMode>
 232:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const
 233:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 234:./Eigen/src/Core/DenseCoeffsBase.h ****       typedef typename internal::packet_traits<Scalar>::type DefaultPacketType;
 235:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(row >= 0 && row < rows() && col >= 0 && col < cols());
 236:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).template packet<LoadMode,DefaultPacketType>(ro
 237:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 238:./Eigen/src/Core/DenseCoeffsBase.h **** 
 239:./Eigen/src/Core/DenseCoeffsBase.h **** 
 240:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \internal */
 241:./Eigen/src/Core/DenseCoeffsBase.h ****     template<int LoadMode>
 242:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const
 243:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 244:./Eigen/src/Core/DenseCoeffsBase.h ****       return packet<LoadMode>(rowIndexByOuterInner(outer, inner),
 245:./Eigen/src/Core/DenseCoeffsBase.h ****                               colIndexByOuterInner(outer, inner));
 246:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 247:./Eigen/src/Core/DenseCoeffsBase.h **** 
 248:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \internal
 249:./Eigen/src/Core/DenseCoeffsBase.h ****       * \returns the packet of coefficients starting at the given index. It is your responsibility
 250:./Eigen/src/Core/DenseCoeffsBase.h ****       * to ensure that a packet really starts there. This method is only available on expressions h
 251:./Eigen/src/Core/DenseCoeffsBase.h ****       * PacketAccessBit and the LinearAccessBit.
 252:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 253:./Eigen/src/Core/DenseCoeffsBase.h ****       * The \a LoadMode parameter may have the value \a #Aligned or \a #Unaligned. Its effect is to
 254:./Eigen/src/Core/DenseCoeffsBase.h ****       * the appropriate vectorization instruction. Aligned access is faster, but is only possible f
 255:./Eigen/src/Core/DenseCoeffsBase.h ****       * starting at an address which is a multiple of the packet size.
 256:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 257:./Eigen/src/Core/DenseCoeffsBase.h **** 
 258:./Eigen/src/Core/DenseCoeffsBase.h ****     template<int LoadMode>
 259:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const
 260:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 261:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
 262:./Eigen/src/Core/DenseCoeffsBase.h ****                           THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOW
 263:./Eigen/src/Core/DenseCoeffsBase.h ****       typedef typename internal::packet_traits<Scalar>::type DefaultPacketType;
 264:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(index >= 0 && index < size());
 265:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).template packet<LoadMode,DefaultPacketType>(in
 266:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 267:./Eigen/src/Core/DenseCoeffsBase.h **** 
 268:./Eigen/src/Core/DenseCoeffsBase.h ****   protected:
 269:./Eigen/src/Core/DenseCoeffsBase.h ****     // explanation: DenseBase is doing "using ..." on the methods from DenseCoeffsBase.
 270:./Eigen/src/Core/DenseCoeffsBase.h ****     // But some methods are only available in the DirectAccess case.
 271:./Eigen/src/Core/DenseCoeffsBase.h ****     // So we add dummy methods here with these names, so that "using... " doesn't fail.
 272:./Eigen/src/Core/DenseCoeffsBase.h ****     // It's not private so that the child class DenseBase can access them, and it's not public
 273:./Eigen/src/Core/DenseCoeffsBase.h ****     // either since it's an implementation detail, so has to be protected.
 274:./Eigen/src/Core/DenseCoeffsBase.h ****     void coeffRef();
 275:./Eigen/src/Core/DenseCoeffsBase.h ****     void coeffRefByOuterInner();
 276:./Eigen/src/Core/DenseCoeffsBase.h ****     void writePacket();
 277:./Eigen/src/Core/DenseCoeffsBase.h ****     void writePacketByOuterInner();
 278:./Eigen/src/Core/DenseCoeffsBase.h ****     void copyCoeff();
 279:./Eigen/src/Core/DenseCoeffsBase.h ****     void copyCoeffByOuterInner();
 280:./Eigen/src/Core/DenseCoeffsBase.h ****     void copyPacket();
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 110


 281:./Eigen/src/Core/DenseCoeffsBase.h ****     void copyPacketByOuterInner();
 282:./Eigen/src/Core/DenseCoeffsBase.h ****     void stride();
 283:./Eigen/src/Core/DenseCoeffsBase.h ****     void innerStride();
 284:./Eigen/src/Core/DenseCoeffsBase.h ****     void outerStride();
 285:./Eigen/src/Core/DenseCoeffsBase.h ****     void rowStride();
 286:./Eigen/src/Core/DenseCoeffsBase.h ****     void colStride();
 287:./Eigen/src/Core/DenseCoeffsBase.h **** };
 288:./Eigen/src/Core/DenseCoeffsBase.h **** 
 289:./Eigen/src/Core/DenseCoeffsBase.h **** /** \brief Base class providing read/write coefficient access to matrices and arrays.
 290:./Eigen/src/Core/DenseCoeffsBase.h ****   * \ingroup Core_Module
 291:./Eigen/src/Core/DenseCoeffsBase.h ****   * \tparam Derived Type of the derived class
 292:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 293:./Eigen/src/Core/DenseCoeffsBase.h ****   * \note #WriteAccessors Constant indicating read/write access
 294:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 295:./Eigen/src/Core/DenseCoeffsBase.h ****   * This class defines the non-const \c operator() function and friends, which can be used to write
 296:./Eigen/src/Core/DenseCoeffsBase.h ****   * entries of a matrix or array. This class inherits DenseCoeffsBase<Derived, ReadOnlyAccessors> w
 297:./Eigen/src/Core/DenseCoeffsBase.h ****   * defines the const variant for reading specific entries.
 298:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 299:./Eigen/src/Core/DenseCoeffsBase.h ****   * \sa DenseCoeffsBase<Derived, DirectAccessors>, \ref TopicClassHierarchy
 300:./Eigen/src/Core/DenseCoeffsBase.h ****   */
 301:./Eigen/src/Core/DenseCoeffsBase.h **** template<typename Derived>
 302:./Eigen/src/Core/DenseCoeffsBase.h **** class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>
 303:./Eigen/src/Core/DenseCoeffsBase.h **** {
 304:./Eigen/src/Core/DenseCoeffsBase.h ****   public:
 305:./Eigen/src/Core/DenseCoeffsBase.h **** 
 306:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;
 307:./Eigen/src/Core/DenseCoeffsBase.h **** 
 308:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::StorageKind StorageKind;
 309:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
 310:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
 311:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 312:./Eigen/src/Core/DenseCoeffsBase.h **** 
 313:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::coeff;
 314:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::rows;
 315:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::cols;
 316:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::size;
 317:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::derived;
 318:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::rowIndexByOuterInner;
 319:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::colIndexByOuterInner;
 320:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::operator[];
 321:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::operator();
 322:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::x;
 323:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::y;
 324:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::z;
 325:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::w;
 326:./Eigen/src/Core/DenseCoeffsBase.h **** 
 327:./Eigen/src/Core/DenseCoeffsBase.h ****     /** Short version: don't use this function, use
 328:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator()(Index,Index) \endlink instead.
 329:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 330:./Eigen/src/Core/DenseCoeffsBase.h ****       * Long version: this function is similar to
 331:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator()(Index,Index) \endlink, but without the assertion.
 332:./Eigen/src/Core/DenseCoeffsBase.h ****       * Use this for limiting the performance cost of debugging code when doing
 333:./Eigen/src/Core/DenseCoeffsBase.h ****       * repeated coefficient access. Only use this when it is guaranteed that the
 334:./Eigen/src/Core/DenseCoeffsBase.h ****       * parameters \a row and \a col are in range.
 335:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 336:./Eigen/src/Core/DenseCoeffsBase.h ****       * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
 337:./Eigen/src/Core/DenseCoeffsBase.h ****       * function equivalent to \link operator()(Index,Index) \endlink.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 111


 338:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 339:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator()(Index,Index), coeff(Index, Index) const, coeffRef(Index)
 340:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 341:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 342:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)
 343:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 344:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(row >= 0 && row < rows()
 345:./Eigen/src/Core/DenseCoeffsBase.h ****                          && col >= 0 && col < cols());
 346:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).coeffRef(row,col);
 347:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 348:./Eigen/src/Core/DenseCoeffsBase.h **** 
 349:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 350:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 351:./Eigen/src/Core/DenseCoeffsBase.h ****     coeffRefByOuterInner(Index outer, Index inner)
 352:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 353:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeffRef(rowIndexByOuterInner(outer, inner),
 354:./Eigen/src/Core/DenseCoeffsBase.h ****                       colIndexByOuterInner(outer, inner));
 355:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 356:./Eigen/src/Core/DenseCoeffsBase.h **** 
 357:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns a reference to the coefficient at given the given row and column.
 358:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 359:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index)
 360:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 361:./Eigen/src/Core/DenseCoeffsBase.h **** 
 362:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 363:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 364:./Eigen/src/Core/DenseCoeffsBase.h ****     operator()(Index row, Index col)
 365:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 366:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(row >= 0 && row < rows()
 367:./Eigen/src/Core/DenseCoeffsBase.h ****           && col >= 0 && col < cols());
 368:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeffRef(row, col);
 369:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 370:./Eigen/src/Core/DenseCoeffsBase.h **** 
 371:./Eigen/src/Core/DenseCoeffsBase.h **** 
 372:./Eigen/src/Core/DenseCoeffsBase.h ****     /** Short version: don't use this function, use
 373:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator[](Index) \endlink instead.
 374:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 375:./Eigen/src/Core/DenseCoeffsBase.h ****       * Long version: this function is similar to
 376:./Eigen/src/Core/DenseCoeffsBase.h ****       * \link operator[](Index) \endlink, but without the assertion.
 377:./Eigen/src/Core/DenseCoeffsBase.h ****       * Use this for limiting the performance cost of debugging code when doing
 378:./Eigen/src/Core/DenseCoeffsBase.h ****       * repeated coefficient access. Only use this when it is guaranteed that the
 379:./Eigen/src/Core/DenseCoeffsBase.h ****       * parameters \a row and \a col are in range.
 380:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 381:./Eigen/src/Core/DenseCoeffsBase.h ****       * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
 382:./Eigen/src/Core/DenseCoeffsBase.h ****       * function equivalent to \link operator[](Index) \endlink.
 383:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 384:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index), coeff(Index) const, coeffRef(Index,Index)
 385:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 386:./Eigen/src/Core/DenseCoeffsBase.h **** 
 387:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 388:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 389:./Eigen/src/Core/DenseCoeffsBase.h ****     coeffRef(Index index)
 390:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 391:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
 392:./Eigen/src/Core/DenseCoeffsBase.h ****                           THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOW
 393:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_internal_assert(index >= 0 && index < size());
 394:./Eigen/src/Core/DenseCoeffsBase.h ****       return internal::evaluator<Derived>(derived()).coeffRef(index);
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 112


 395:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 396:./Eigen/src/Core/DenseCoeffsBase.h **** 
 397:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns a reference to the coefficient at given index.
 398:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 399:./Eigen/src/Core/DenseCoeffsBase.h ****       * This method is allowed only for vector expressions, and for matrix expressions having the L
 400:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 401:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
 402:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 403:./Eigen/src/Core/DenseCoeffsBase.h **** 
 404:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 405:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 406:./Eigen/src/Core/DenseCoeffsBase.h ****     operator[](Index index)
 407:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 408:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
 409:./Eigen/src/Core/DenseCoeffsBase.h ****                           THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_IN
 410:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(index >= 0 && index < size());
 411:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeffRef(index);
 412:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 413:./Eigen/src/Core/DenseCoeffsBase.h **** 
 414:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns a reference to the coefficient at given index.
 415:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 416:./Eigen/src/Core/DenseCoeffsBase.h ****       * This is synonymous to operator[](Index).
 417:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 418:./Eigen/src/Core/DenseCoeffsBase.h ****       * This method is allowed only for vector expressions, and for matrix expressions having the L
 419:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 420:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
 421:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 422:./Eigen/src/Core/DenseCoeffsBase.h **** 
 423:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 424:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 425:./Eigen/src/Core/DenseCoeffsBase.h ****     operator()(Index index)
 426:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 427:./Eigen/src/Core/DenseCoeffsBase.h ****       eigen_assert(index >= 0 && index < size());
 428:./Eigen/src/Core/DenseCoeffsBase.h ****       return coeffRef(index);
 429:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 430:./Eigen/src/Core/DenseCoeffsBase.h **** 
 431:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](0).  */
 432:./Eigen/src/Core/DenseCoeffsBase.h **** 
 433:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 434:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 435:./Eigen/src/Core/DenseCoeffsBase.h ****     x() { return (*this)[0]; }
 436:./Eigen/src/Core/DenseCoeffsBase.h **** 
 437:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](1).  */
 438:./Eigen/src/Core/DenseCoeffsBase.h **** 
 439:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 440:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 441:./Eigen/src/Core/DenseCoeffsBase.h ****     y()
 442:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 443:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=2, OUT_OF_R
 444:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[1];
 445:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 446:./Eigen/src/Core/DenseCoeffsBase.h **** 
 447:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](2).  */
 448:./Eigen/src/Core/DenseCoeffsBase.h **** 
 449:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 450:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 451:./Eigen/src/Core/DenseCoeffsBase.h ****     z()
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 113


 452:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 453:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=3, OUT_OF_R
 454:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[2];
 455:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 456:./Eigen/src/Core/DenseCoeffsBase.h **** 
 457:./Eigen/src/Core/DenseCoeffsBase.h ****     /** equivalent to operator[](3).  */
 458:./Eigen/src/Core/DenseCoeffsBase.h **** 
 459:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC
 460:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_STRONG_INLINE Scalar&
 461:./Eigen/src/Core/DenseCoeffsBase.h ****     w()
 462:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 463:./Eigen/src/Core/DenseCoeffsBase.h ****       EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=4, OUT_OF_R
 464:./Eigen/src/Core/DenseCoeffsBase.h ****       return (*this)[3];
 465:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 466:./Eigen/src/Core/DenseCoeffsBase.h **** };
 467:./Eigen/src/Core/DenseCoeffsBase.h **** 
 468:./Eigen/src/Core/DenseCoeffsBase.h **** /** \brief Base class providing direct read-only coefficient access to matrices and arrays.
 469:./Eigen/src/Core/DenseCoeffsBase.h ****   * \ingroup Core_Module
 470:./Eigen/src/Core/DenseCoeffsBase.h ****   * \tparam Derived Type of the derived class
 471:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 472:./Eigen/src/Core/DenseCoeffsBase.h ****   * \note #DirectAccessors Constant indicating direct access
 473:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 474:./Eigen/src/Core/DenseCoeffsBase.h ****   * This class defines functions to work with strides which can be used to access entries directly.
 475:./Eigen/src/Core/DenseCoeffsBase.h ****   * inherits DenseCoeffsBase<Derived, ReadOnlyAccessors> which defines functions to access entries 
 476:./Eigen/src/Core/DenseCoeffsBase.h ****   * \c operator() .
 477:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 478:./Eigen/src/Core/DenseCoeffsBase.h ****   * \sa \blank \ref TopicClassHierarchy
 479:./Eigen/src/Core/DenseCoeffsBase.h ****   */
 480:./Eigen/src/Core/DenseCoeffsBase.h **** template<typename Derived>
 481:./Eigen/src/Core/DenseCoeffsBase.h **** class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors
 482:./Eigen/src/Core/DenseCoeffsBase.h **** {
 483:./Eigen/src/Core/DenseCoeffsBase.h ****   public:
 484:./Eigen/src/Core/DenseCoeffsBase.h **** 
 485:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;
 486:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
 487:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 488:./Eigen/src/Core/DenseCoeffsBase.h **** 
 489:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::rows;
 490:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::cols;
 491:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::size;
 492:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::derived;
 493:./Eigen/src/Core/DenseCoeffsBase.h **** 
 494:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive elements within a slice in the inner
 495:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 496:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa outerStride(), rowStride(), colStride()
 497:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 498:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 499:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index innerStride() const
 500:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 501:./Eigen/src/Core/DenseCoeffsBase.h ****       return derived().innerStride();
 502:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 503:./Eigen/src/Core/DenseCoeffsBase.h **** 
 504:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive inner slices (for example, between t
 505:./Eigen/src/Core/DenseCoeffsBase.h ****       *          in a column-major matrix).
 506:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 507:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa innerStride(), rowStride(), colStride()
 508:./Eigen/src/Core/DenseCoeffsBase.h ****       */
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 114


 509:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 510:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index outerStride() const
 511:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 512:./Eigen/src/Core/DenseCoeffsBase.h ****       return derived().outerStride();
 513:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 514:./Eigen/src/Core/DenseCoeffsBase.h **** 
 515:./Eigen/src/Core/DenseCoeffsBase.h ****     // FIXME shall we remove it ?
 516:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_CONSTEXPR inline Index stride() const
 517:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 518:./Eigen/src/Core/DenseCoeffsBase.h ****       return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
 519:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 520:./Eigen/src/Core/DenseCoeffsBase.h **** 
 521:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive rows.
 522:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 523:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa innerStride(), outerStride(), colStride()
 524:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 525:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 526:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index rowStride() const
 527:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 528:./Eigen/src/Core/DenseCoeffsBase.h ****       return Derived::IsRowMajor ? outerStride() : innerStride();
 529:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 530:./Eigen/src/Core/DenseCoeffsBase.h **** 
 531:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive columns.
 532:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 533:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa innerStride(), outerStride(), rowStride()
 534:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 535:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 536:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index colStride() const
 537:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 538:./Eigen/src/Core/DenseCoeffsBase.h ****       return Derived::IsRowMajor ? innerStride() : outerStride();
 539:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 540:./Eigen/src/Core/DenseCoeffsBase.h **** };
 541:./Eigen/src/Core/DenseCoeffsBase.h **** 
 542:./Eigen/src/Core/DenseCoeffsBase.h **** /** \brief Base class providing direct read/write coefficient access to matrices and arrays.
 543:./Eigen/src/Core/DenseCoeffsBase.h ****   * \ingroup Core_Module
 544:./Eigen/src/Core/DenseCoeffsBase.h ****   * \tparam Derived Type of the derived class
 545:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 546:./Eigen/src/Core/DenseCoeffsBase.h ****   * \note #DirectWriteAccessors Constant indicating direct access
 547:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 548:./Eigen/src/Core/DenseCoeffsBase.h ****   * This class defines functions to work with strides which can be used to access entries directly.
 549:./Eigen/src/Core/DenseCoeffsBase.h ****   * inherits DenseCoeffsBase<Derived, WriteAccessors> which defines functions to access entries rea
 550:./Eigen/src/Core/DenseCoeffsBase.h ****   * \c operator().
 551:./Eigen/src/Core/DenseCoeffsBase.h ****   *
 552:./Eigen/src/Core/DenseCoeffsBase.h ****   * \sa \blank \ref TopicClassHierarchy
 553:./Eigen/src/Core/DenseCoeffsBase.h ****   */
 554:./Eigen/src/Core/DenseCoeffsBase.h **** template<typename Derived>
 555:./Eigen/src/Core/DenseCoeffsBase.h **** class DenseCoeffsBase<Derived, DirectWriteAccessors>
 556:./Eigen/src/Core/DenseCoeffsBase.h ****   : public DenseCoeffsBase<Derived, WriteAccessors>
 557:./Eigen/src/Core/DenseCoeffsBase.h **** {
 558:./Eigen/src/Core/DenseCoeffsBase.h ****   public:
 559:./Eigen/src/Core/DenseCoeffsBase.h **** 
 560:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef DenseCoeffsBase<Derived, WriteAccessors> Base;
 561:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename internal::traits<Derived>::Scalar Scalar;
 562:./Eigen/src/Core/DenseCoeffsBase.h ****     typedef typename NumTraits<Scalar>::Real RealScalar;
 563:./Eigen/src/Core/DenseCoeffsBase.h **** 
 564:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::rows;
 565:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::cols;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 115


 566:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::size;
 567:./Eigen/src/Core/DenseCoeffsBase.h ****     using Base::derived;
 568:./Eigen/src/Core/DenseCoeffsBase.h **** 
 569:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive elements within a slice in the inner
 570:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 571:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa outerStride(), rowStride(), colStride()
 572:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 573:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 574:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index innerStride() const EIGEN_NOEXCEPT
 575:./Eigen/src/Core/DenseCoeffsBase.h ****     {
 576:./Eigen/src/Core/DenseCoeffsBase.h ****       return derived().innerStride();
 577:./Eigen/src/Core/DenseCoeffsBase.h ****     }
 578:./Eigen/src/Core/DenseCoeffsBase.h **** 
 579:./Eigen/src/Core/DenseCoeffsBase.h ****     /** \returns the pointer increment between two consecutive inner slices (for example, between t
 580:./Eigen/src/Core/DenseCoeffsBase.h ****       *          in a column-major matrix).
 581:./Eigen/src/Core/DenseCoeffsBase.h ****       *
 582:./Eigen/src/Core/DenseCoeffsBase.h ****       * \sa innerStride(), rowStride(), colStride()
 583:./Eigen/src/Core/DenseCoeffsBase.h ****       */
 584:./Eigen/src/Core/DenseCoeffsBase.h ****     EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
 585:./Eigen/src/Core/DenseCoeffsBase.h ****     inline Index outerStride() const EIGEN_NOEXCEPT
 884              		.loc 13 585 18 is_stmt 1 view .LVU136
 885              		.loc 13 585 18 is_stmt 0 view .LVU137
 886              	.LBE375:
 887              	.LBB376:
 888              	.LBI376:
 139:./Eigen/src/Core/CoreEvaluators.h ****   {
 889              		.loc 10 139 3 is_stmt 1 view .LVU138
 890              	.LBB377:
 891              	.LBB378:
 139:./Eigen/src/Core/CoreEvaluators.h ****   {
 892              		.loc 10 139 74 is_stmt 0 view .LVU139
 893 0006 0290     		str	r0, [sp, #8]
 894              	.LVL55:
 895              	.LBB379:
 896              	.LBI379:
 897              		.file 14 "./Eigen/src/Core/util/Macros.h"
   1:./Eigen/src/Core/util/Macros.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/util/Macros.h **** // for linear algebra.
   3:./Eigen/src/Core/util/Macros.h **** //
   4:./Eigen/src/Core/util/Macros.h **** // Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>
   5:./Eigen/src/Core/util/Macros.h **** // Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>
   6:./Eigen/src/Core/util/Macros.h **** //
   7:./Eigen/src/Core/util/Macros.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/util/Macros.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/util/Macros.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/util/Macros.h **** 
  11:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_MACROS_H
  12:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MACROS_H
  13:./Eigen/src/Core/util/Macros.h **** 
  14:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
  15:./Eigen/src/Core/util/Macros.h **** // Eigen version and basic defaults
  16:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
  17:./Eigen/src/Core/util/Macros.h **** 
  18:./Eigen/src/Core/util/Macros.h **** #define EIGEN_WORLD_VERSION 3
  19:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MAJOR_VERSION 4
  20:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MINOR_VERSION 0
  21:./Eigen/src/Core/util/Macros.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 116


  22:./Eigen/src/Core/util/Macros.h **** #define EIGEN_VERSION_AT_LEAST(x,y,z) (EIGEN_WORLD_VERSION>x || (EIGEN_WORLD_VERSION>=x && \
  23:./Eigen/src/Core/util/Macros.h ****                                       (EIGEN_MAJOR_VERSION>y || (EIGEN_MAJOR_VERSION>=y && \
  24:./Eigen/src/Core/util/Macros.h ****                                                                  EIGEN_MINOR_VERSION>=z))))
  25:./Eigen/src/Core/util/Macros.h **** 
  26:./Eigen/src/Core/util/Macros.h **** #ifdef EIGEN_DEFAULT_TO_ROW_MAJOR
  27:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION Eigen::RowMajor
  28:./Eigen/src/Core/util/Macros.h **** #else
  29:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION Eigen::ColMajor
  30:./Eigen/src/Core/util/Macros.h **** #endif
  31:./Eigen/src/Core/util/Macros.h **** 
  32:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_DEFAULT_DENSE_INDEX_TYPE
  33:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DEFAULT_DENSE_INDEX_TYPE std::ptrdiff_t
  34:./Eigen/src/Core/util/Macros.h **** #endif
  35:./Eigen/src/Core/util/Macros.h **** 
  36:./Eigen/src/Core/util/Macros.h **** // Upperbound on the C++ version to use.
  37:./Eigen/src/Core/util/Macros.h **** // Expected values are 03, 11, 14, 17, etc.
  38:./Eigen/src/Core/util/Macros.h **** // By default, let's use an arbitrarily large C++ version.
  39:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_MAX_CPP_VER
  40:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MAX_CPP_VER 99
  41:./Eigen/src/Core/util/Macros.h **** #endif
  42:./Eigen/src/Core/util/Macros.h **** 
  43:./Eigen/src/Core/util/Macros.h **** /** Allows to disable some optimizations which might affect the accuracy of the result.
  44:./Eigen/src/Core/util/Macros.h ****   * Such optimization are enabled by default, and set EIGEN_FAST_MATH to 0 to disable them.
  45:./Eigen/src/Core/util/Macros.h ****   * They currently include:
  46:./Eigen/src/Core/util/Macros.h ****   *   - single precision ArrayBase::sin() and ArrayBase::cos() for SSE and AVX vectorization.
  47:./Eigen/src/Core/util/Macros.h ****   */
  48:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_FAST_MATH
  49:./Eigen/src/Core/util/Macros.h **** #define EIGEN_FAST_MATH 1
  50:./Eigen/src/Core/util/Macros.h **** #endif
  51:./Eigen/src/Core/util/Macros.h **** 
  52:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_STACK_ALLOCATION_LIMIT
  53:./Eigen/src/Core/util/Macros.h **** // 131072 == 128 KB
  54:./Eigen/src/Core/util/Macros.h **** #define EIGEN_STACK_ALLOCATION_LIMIT 131072
  55:./Eigen/src/Core/util/Macros.h **** #endif
  56:./Eigen/src/Core/util/Macros.h **** 
  57:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
  58:./Eigen/src/Core/util/Macros.h **** // Compiler identification, EIGEN_COMP_*
  59:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
  60:./Eigen/src/Core/util/Macros.h **** 
  61:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_GNUC set to 1 for all compilers compatible with GCC
  62:./Eigen/src/Core/util/Macros.h **** #ifdef __GNUC__
  63:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_GNUC (__GNUC__*10+__GNUC_MINOR__)
  64:./Eigen/src/Core/util/Macros.h **** #else
  65:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_GNUC 0
  66:./Eigen/src/Core/util/Macros.h **** #endif
  67:./Eigen/src/Core/util/Macros.h **** 
  68:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_CLANG set to major+minor version (e.g., 307 for clang 3.7) if the compiler
  69:./Eigen/src/Core/util/Macros.h **** #if defined(__clang__)
  70:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CLANG (__clang_major__*100+__clang_minor__)
  71:./Eigen/src/Core/util/Macros.h **** #else
  72:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CLANG 0
  73:./Eigen/src/Core/util/Macros.h **** #endif
  74:./Eigen/src/Core/util/Macros.h **** 
  75:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_CASTXML set to 1 if being preprocessed by CastXML
  76:./Eigen/src/Core/util/Macros.h **** #if defined(__castxml__)
  77:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CASTXML 1
  78:./Eigen/src/Core/util/Macros.h **** #else
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 117


  79:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CASTXML 0
  80:./Eigen/src/Core/util/Macros.h **** #endif
  81:./Eigen/src/Core/util/Macros.h **** 
  82:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_LLVM set to 1 if the compiler backend is llvm
  83:./Eigen/src/Core/util/Macros.h **** #if defined(__llvm__)
  84:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_LLVM 1
  85:./Eigen/src/Core/util/Macros.h **** #else
  86:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_LLVM 0
  87:./Eigen/src/Core/util/Macros.h **** #endif
  88:./Eigen/src/Core/util/Macros.h **** 
  89:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_ICC set to __INTEL_COMPILER if the compiler is Intel compiler, 0 otherwise
  90:./Eigen/src/Core/util/Macros.h **** #if defined(__INTEL_COMPILER)
  91:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_ICC __INTEL_COMPILER
  92:./Eigen/src/Core/util/Macros.h **** #else
  93:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_ICC 0
  94:./Eigen/src/Core/util/Macros.h **** #endif
  95:./Eigen/src/Core/util/Macros.h **** 
  96:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_MINGW set to 1 if the compiler is mingw
  97:./Eigen/src/Core/util/Macros.h **** #if defined(__MINGW32__)
  98:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MINGW 1
  99:./Eigen/src/Core/util/Macros.h **** #else
 100:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MINGW 0
 101:./Eigen/src/Core/util/Macros.h **** #endif
 102:./Eigen/src/Core/util/Macros.h **** 
 103:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_SUNCC set to 1 if the compiler is Solaris Studio
 104:./Eigen/src/Core/util/Macros.h **** #if defined(__SUNPRO_CC)
 105:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_SUNCC 1
 106:./Eigen/src/Core/util/Macros.h **** #else
 107:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_SUNCC 0
 108:./Eigen/src/Core/util/Macros.h **** #endif
 109:./Eigen/src/Core/util/Macros.h **** 
 110:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_MSVC set to _MSC_VER if the compiler is Microsoft Visual C++, 0 otherwise.
 111:./Eigen/src/Core/util/Macros.h **** #if defined(_MSC_VER)
 112:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC _MSC_VER
 113:./Eigen/src/Core/util/Macros.h **** #else
 114:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC 0
 115:./Eigen/src/Core/util/Macros.h **** #endif
 116:./Eigen/src/Core/util/Macros.h **** 
 117:./Eigen/src/Core/util/Macros.h **** #if defined(__NVCC__)
 118:./Eigen/src/Core/util/Macros.h **** #if defined(__CUDACC_VER_MAJOR__) && (__CUDACC_VER_MAJOR__ >= 9)
 119:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_NVCC  ((__CUDACC_VER_MAJOR__ * 10000) + (__CUDACC_VER_MINOR__ * 100))
 120:./Eigen/src/Core/util/Macros.h **** #elif defined(__CUDACC_VER__)
 121:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_NVCC __CUDACC_VER__
 122:./Eigen/src/Core/util/Macros.h **** #else
 123:./Eigen/src/Core/util/Macros.h ****   #error "NVCC did not define compiler version."
 124:./Eigen/src/Core/util/Macros.h **** #endif
 125:./Eigen/src/Core/util/Macros.h **** #else
 126:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_NVCC 0
 127:./Eigen/src/Core/util/Macros.h **** #endif
 128:./Eigen/src/Core/util/Macros.h **** 
 129:./Eigen/src/Core/util/Macros.h **** // For the record, here is a table summarizing the possible values for EIGEN_COMP_MSVC:
 130:./Eigen/src/Core/util/Macros.h **** //  name        ver   MSC_VER
 131:./Eigen/src/Core/util/Macros.h **** //  2008         9      1500
 132:./Eigen/src/Core/util/Macros.h **** //  2010        10      1600
 133:./Eigen/src/Core/util/Macros.h **** //  2012        11      1700
 134:./Eigen/src/Core/util/Macros.h **** //  2013        12      1800
 135:./Eigen/src/Core/util/Macros.h **** //  2015        14      1900
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 118


 136:./Eigen/src/Core/util/Macros.h **** //  "15"        15      1900
 137:./Eigen/src/Core/util/Macros.h **** //  2017-14.1   15.0    1910
 138:./Eigen/src/Core/util/Macros.h **** //  2017-14.11  15.3    1911
 139:./Eigen/src/Core/util/Macros.h **** //  2017-14.12  15.5    1912
 140:./Eigen/src/Core/util/Macros.h **** //  2017-14.13  15.6    1913
 141:./Eigen/src/Core/util/Macros.h **** //  2017-14.14  15.7    1914
 142:./Eigen/src/Core/util/Macros.h **** 
 143:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_MSVC_LANG set to _MSVC_LANG if the compiler is Microsoft Visual C++, 0 oth
 144:./Eigen/src/Core/util/Macros.h **** #if defined(_MSVC_LANG)
 145:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC_LANG _MSVC_LANG
 146:./Eigen/src/Core/util/Macros.h **** #else
 147:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC_LANG 0
 148:./Eigen/src/Core/util/Macros.h **** #endif
 149:./Eigen/src/Core/util/Macros.h **** 
 150:./Eigen/src/Core/util/Macros.h **** // For the record, here is a table summarizing the possible values for EIGEN_COMP_MSVC_LANG:
 151:./Eigen/src/Core/util/Macros.h **** // MSVC option                          Standard  MSVC_LANG
 152:./Eigen/src/Core/util/Macros.h **** // /std:c++14 (default as of VS 2019)   C++14     201402L
 153:./Eigen/src/Core/util/Macros.h **** // /std:c++17                           C++17     201703L
 154:./Eigen/src/Core/util/Macros.h **** // /std:c++latest                       >C++17    >201703L
 155:./Eigen/src/Core/util/Macros.h **** 
 156:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_MSVC_STRICT set to 1 if the compiler is really Microsoft Visual C++ and no
 157:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_MSVC && !(EIGEN_COMP_ICC || EIGEN_COMP_LLVM || EIGEN_COMP_CLANG)
 158:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC_STRICT _MSC_VER
 159:./Eigen/src/Core/util/Macros.h **** #else
 160:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_MSVC_STRICT 0
 161:./Eigen/src/Core/util/Macros.h **** #endif
 162:./Eigen/src/Core/util/Macros.h **** 
 163:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_IBM set to xlc version if the compiler is IBM XL C++
 164:./Eigen/src/Core/util/Macros.h **** // XLC   version
 165:./Eigen/src/Core/util/Macros.h **** // 3.1   0x0301
 166:./Eigen/src/Core/util/Macros.h **** // 4.5   0x0405
 167:./Eigen/src/Core/util/Macros.h **** // 5.0   0x0500
 168:./Eigen/src/Core/util/Macros.h **** // 12.1  0x0C01
 169:./Eigen/src/Core/util/Macros.h **** #if defined(__IBMCPP__) || defined(__xlc__) || defined(__ibmxl__)
 170:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_IBM __xlC__
 171:./Eigen/src/Core/util/Macros.h **** #else
 172:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_IBM 0
 173:./Eigen/src/Core/util/Macros.h **** #endif
 174:./Eigen/src/Core/util/Macros.h **** 
 175:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_PGI set to PGI version if the compiler is Portland Group Compiler
 176:./Eigen/src/Core/util/Macros.h **** #if defined(__PGI)
 177:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_PGI (__PGIC__*100+__PGIC_MINOR__)
 178:./Eigen/src/Core/util/Macros.h **** #else
 179:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_PGI 0
 180:./Eigen/src/Core/util/Macros.h **** #endif
 181:./Eigen/src/Core/util/Macros.h **** 
 182:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_ARM set to 1 if the compiler is ARM Compiler
 183:./Eigen/src/Core/util/Macros.h **** #if defined(__CC_ARM) || defined(__ARMCC_VERSION)
 184:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_ARM 1
 185:./Eigen/src/Core/util/Macros.h **** #else
 186:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_ARM 0
 187:./Eigen/src/Core/util/Macros.h **** #endif
 188:./Eigen/src/Core/util/Macros.h **** 
 189:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_COMP_EMSCRIPTEN set to 1 if the compiler is Emscripten Compiler
 190:./Eigen/src/Core/util/Macros.h **** #if defined(__EMSCRIPTEN__)
 191:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_EMSCRIPTEN 1
 192:./Eigen/src/Core/util/Macros.h **** #else
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 119


 193:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_EMSCRIPTEN 0
 194:./Eigen/src/Core/util/Macros.h **** #endif
 195:./Eigen/src/Core/util/Macros.h **** 
 196:./Eigen/src/Core/util/Macros.h **** 
 197:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_GNUC_STRICT set to 1 if the compiler is really GCC and not a compatible compile
 198:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC && !(EIGEN_COMP_CLANG || EIGEN_COMP_ICC || EIGEN_COMP_MINGW || EIGEN_COMP_PGI |
 199:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_GNUC_STRICT 1
 200:./Eigen/src/Core/util/Macros.h **** #else
 201:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_GNUC_STRICT 0
 202:./Eigen/src/Core/util/Macros.h **** #endif
 203:./Eigen/src/Core/util/Macros.h **** 
 204:./Eigen/src/Core/util/Macros.h **** 
 205:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC
 206:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT_LEAST(x,y) ((__GNUC__==x && __GNUC_MINOR__>=y) || __GNUC__>x)
 207:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT_MOST(x,y)  ((__GNUC__==x && __GNUC_MINOR__<=y) || __GNUC__<x)
 208:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT(x,y)       ( __GNUC__==x && __GNUC_MINOR__==y )
 209:./Eigen/src/Core/util/Macros.h **** #else
 210:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT_LEAST(x,y) 0
 211:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT_MOST(x,y)  0
 212:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_GNUC_AT(x,y)       0
 213:./Eigen/src/Core/util/Macros.h **** #endif
 214:./Eigen/src/Core/util/Macros.h **** 
 215:./Eigen/src/Core/util/Macros.h **** // FIXME: could probably be removed as we do not support gcc 3.x anymore
 216:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC && (__GNUC__ <= 3)
 217:./Eigen/src/Core/util/Macros.h **** #define EIGEN_GCC3_OR_OLDER 1
 218:./Eigen/src/Core/util/Macros.h **** #else
 219:./Eigen/src/Core/util/Macros.h **** #define EIGEN_GCC3_OR_OLDER 0
 220:./Eigen/src/Core/util/Macros.h **** #endif
 221:./Eigen/src/Core/util/Macros.h **** 
 222:./Eigen/src/Core/util/Macros.h **** 
 223:./Eigen/src/Core/util/Macros.h **** 
 224:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 225:./Eigen/src/Core/util/Macros.h **** // Architecture identification, EIGEN_ARCH_*
 226:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 227:./Eigen/src/Core/util/Macros.h **** 
 228:./Eigen/src/Core/util/Macros.h **** 
 229:./Eigen/src/Core/util/Macros.h **** #if defined(__x86_64__) || (defined(_M_X64) && !defined(_M_ARM64EC)) || defined(__amd64)
 230:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_x86_64 1
 231:./Eigen/src/Core/util/Macros.h **** #else
 232:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_x86_64 0
 233:./Eigen/src/Core/util/Macros.h **** #endif
 234:./Eigen/src/Core/util/Macros.h **** 
 235:./Eigen/src/Core/util/Macros.h **** #if defined(__i386__) || defined(_M_IX86) || defined(_X86_) || defined(__i386)
 236:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_i386 1
 237:./Eigen/src/Core/util/Macros.h **** #else
 238:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_i386 0
 239:./Eigen/src/Core/util/Macros.h **** #endif
 240:./Eigen/src/Core/util/Macros.h **** 
 241:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_x86_64 || EIGEN_ARCH_i386
 242:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_i386_OR_x86_64 1
 243:./Eigen/src/Core/util/Macros.h **** #else
 244:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_i386_OR_x86_64 0
 245:./Eigen/src/Core/util/Macros.h **** #endif
 246:./Eigen/src/Core/util/Macros.h **** 
 247:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_ARM set to 1 if the architecture is ARM
 248:./Eigen/src/Core/util/Macros.h **** #if defined(__arm__)
 249:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM 1
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 120


 250:./Eigen/src/Core/util/Macros.h **** #else
 251:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM 0
 252:./Eigen/src/Core/util/Macros.h **** #endif
 253:./Eigen/src/Core/util/Macros.h **** 
 254:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_ARM64 set to 1 if the architecture is ARM64
 255:./Eigen/src/Core/util/Macros.h **** #if defined(__aarch64__) || defined(_M_ARM64) || defined(_M_ARM64EC)
 256:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM64 1
 257:./Eigen/src/Core/util/Macros.h **** #else
 258:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM64 0
 259:./Eigen/src/Core/util/Macros.h **** #endif
 260:./Eigen/src/Core/util/Macros.h **** 
 261:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_ARM_OR_ARM64 set to 1 if the architecture is ARM or ARM64
 262:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_ARM || EIGEN_ARCH_ARM64
 263:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM_OR_ARM64 1
 264:./Eigen/src/Core/util/Macros.h **** #else
 265:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_ARM_OR_ARM64 0
 266:./Eigen/src/Core/util/Macros.h **** #endif
 267:./Eigen/src/Core/util/Macros.h **** 
 268:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_ARMV8 set to 1 if the architecture is armv8 or greater.
 269:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_ARM_OR_ARM64 && defined(__ARM_ARCH) && __ARM_ARCH >= 8
 270:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ARCH_ARMV8 1
 271:./Eigen/src/Core/util/Macros.h **** #else
 272:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ARCH_ARMV8 0
 273:./Eigen/src/Core/util/Macros.h **** #endif
 274:./Eigen/src/Core/util/Macros.h **** 
 275:./Eigen/src/Core/util/Macros.h **** 
 276:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_HAS_ARM64_FP16 set to 1 if the architecture provides an IEEE
 277:./Eigen/src/Core/util/Macros.h **** /// compliant Arm fp16 type
 278:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_ARM64
 279:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_HAS_ARM64_FP16
 280:./Eigen/src/Core/util/Macros.h ****     #if defined(__ARM_FP16_FORMAT_IEEE)
 281:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_ARM64_FP16 1
 282:./Eigen/src/Core/util/Macros.h ****     #else
 283:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_ARM64_FP16 0
 284:./Eigen/src/Core/util/Macros.h ****     #endif
 285:./Eigen/src/Core/util/Macros.h ****   #endif
 286:./Eigen/src/Core/util/Macros.h **** #endif
 287:./Eigen/src/Core/util/Macros.h **** 
 288:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_HAS_ARM64_FP16_VECTOR_ARITHMETIC set to 1 if the architecture
 289:./Eigen/src/Core/util/Macros.h **** /// supports Neon vector intrinsics for fp16.
 290:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_ARM64
 291:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_HAS_ARM64_FP16_VECTOR_ARITHMETIC
 292:./Eigen/src/Core/util/Macros.h ****     #if defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
 293:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_ARM64_FP16_VECTOR_ARITHMETIC 1
 294:./Eigen/src/Core/util/Macros.h ****     #else
 295:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_ARM64_FP16_VECTOR_ARITHMETIC 0
 296:./Eigen/src/Core/util/Macros.h ****     #endif
 297:./Eigen/src/Core/util/Macros.h ****   #endif
 298:./Eigen/src/Core/util/Macros.h **** #endif
 299:./Eigen/src/Core/util/Macros.h **** 
 300:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_HAS_ARM64_FP16_SCALAR_ARITHMETIC set to 1 if the architecture
 301:./Eigen/src/Core/util/Macros.h **** /// supports Neon scalar intrinsics for fp16.
 302:./Eigen/src/Core/util/Macros.h **** #if EIGEN_ARCH_ARM64
 303:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_HAS_ARM64_FP16_SCALAR_ARITHMETIC
 304:./Eigen/src/Core/util/Macros.h ****     #if defined(__ARM_FEATURE_FP16_SCALAR_ARITHMETIC)
 305:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_ARM64_FP16_SCALAR_ARITHMETIC 1
 306:./Eigen/src/Core/util/Macros.h ****     #endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 121


 307:./Eigen/src/Core/util/Macros.h ****   #endif
 308:./Eigen/src/Core/util/Macros.h **** #endif
 309:./Eigen/src/Core/util/Macros.h **** 
 310:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_MIPS set to 1 if the architecture is MIPS
 311:./Eigen/src/Core/util/Macros.h **** #if defined(__mips__) || defined(__mips)
 312:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_MIPS 1
 313:./Eigen/src/Core/util/Macros.h **** #else
 314:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_MIPS 0
 315:./Eigen/src/Core/util/Macros.h **** #endif
 316:./Eigen/src/Core/util/Macros.h **** 
 317:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_SPARC set to 1 if the architecture is SPARC
 318:./Eigen/src/Core/util/Macros.h **** #if defined(__sparc__) || defined(__sparc)
 319:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_SPARC 1
 320:./Eigen/src/Core/util/Macros.h **** #else
 321:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_SPARC 0
 322:./Eigen/src/Core/util/Macros.h **** #endif
 323:./Eigen/src/Core/util/Macros.h **** 
 324:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_IA64 set to 1 if the architecture is Intel Itanium
 325:./Eigen/src/Core/util/Macros.h **** #if defined(__ia64__)
 326:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_IA64 1
 327:./Eigen/src/Core/util/Macros.h **** #else
 328:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_IA64 0
 329:./Eigen/src/Core/util/Macros.h **** #endif
 330:./Eigen/src/Core/util/Macros.h **** 
 331:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_ARCH_PPC set to 1 if the architecture is PowerPC
 332:./Eigen/src/Core/util/Macros.h **** #if defined(__powerpc__) || defined(__ppc__) || defined(_M_PPC)
 333:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_PPC 1
 334:./Eigen/src/Core/util/Macros.h **** #else
 335:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_ARCH_PPC 0
 336:./Eigen/src/Core/util/Macros.h **** #endif
 337:./Eigen/src/Core/util/Macros.h **** 
 338:./Eigen/src/Core/util/Macros.h **** 
 339:./Eigen/src/Core/util/Macros.h **** 
 340:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 341:./Eigen/src/Core/util/Macros.h **** // Operating system identification, EIGEN_OS_*
 342:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 343:./Eigen/src/Core/util/Macros.h **** 
 344:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_UNIX set to 1 if the OS is a unix variant
 345:./Eigen/src/Core/util/Macros.h **** #if defined(__unix__) || defined(__unix)
 346:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_UNIX 1
 347:./Eigen/src/Core/util/Macros.h **** #else
 348:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_UNIX 0
 349:./Eigen/src/Core/util/Macros.h **** #endif
 350:./Eigen/src/Core/util/Macros.h **** 
 351:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_LINUX set to 1 if the OS is based on Linux kernel
 352:./Eigen/src/Core/util/Macros.h **** #if defined(__linux__)
 353:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_LINUX 1
 354:./Eigen/src/Core/util/Macros.h **** #else
 355:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_LINUX 0
 356:./Eigen/src/Core/util/Macros.h **** #endif
 357:./Eigen/src/Core/util/Macros.h **** 
 358:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_ANDROID set to 1 if the OS is Android
 359:./Eigen/src/Core/util/Macros.h **** // note: ANDROID is defined when using ndk_build, __ANDROID__ is defined when using a standalone to
 360:./Eigen/src/Core/util/Macros.h **** #if defined(__ANDROID__) || defined(ANDROID)
 361:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_ANDROID 1
 362:./Eigen/src/Core/util/Macros.h **** #else
 363:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_ANDROID 0
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 122


 364:./Eigen/src/Core/util/Macros.h **** #endif
 365:./Eigen/src/Core/util/Macros.h **** 
 366:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_GNULINUX set to 1 if the OS is GNU Linux and not Linux-based OS (e.g., not a
 367:./Eigen/src/Core/util/Macros.h **** #if defined(__gnu_linux__) && !(EIGEN_OS_ANDROID)
 368:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_GNULINUX 1
 369:./Eigen/src/Core/util/Macros.h **** #else
 370:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_GNULINUX 0
 371:./Eigen/src/Core/util/Macros.h **** #endif
 372:./Eigen/src/Core/util/Macros.h **** 
 373:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_BSD set to 1 if the OS is a BSD variant
 374:./Eigen/src/Core/util/Macros.h **** #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) || def
 375:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_BSD 1
 376:./Eigen/src/Core/util/Macros.h **** #else
 377:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_BSD 0
 378:./Eigen/src/Core/util/Macros.h **** #endif
 379:./Eigen/src/Core/util/Macros.h **** 
 380:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_MAC set to 1 if the OS is MacOS
 381:./Eigen/src/Core/util/Macros.h **** #if defined(__APPLE__)
 382:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_MAC 1
 383:./Eigen/src/Core/util/Macros.h **** #else
 384:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_MAC 0
 385:./Eigen/src/Core/util/Macros.h **** #endif
 386:./Eigen/src/Core/util/Macros.h **** 
 387:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_QNX set to 1 if the OS is QNX
 388:./Eigen/src/Core/util/Macros.h **** #if defined(__QNX__)
 389:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_QNX 1
 390:./Eigen/src/Core/util/Macros.h **** #else
 391:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_QNX 0
 392:./Eigen/src/Core/util/Macros.h **** #endif
 393:./Eigen/src/Core/util/Macros.h **** 
 394:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_WIN set to 1 if the OS is Windows based
 395:./Eigen/src/Core/util/Macros.h **** #if defined(_WIN32)
 396:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN 1
 397:./Eigen/src/Core/util/Macros.h **** #else
 398:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN 0
 399:./Eigen/src/Core/util/Macros.h **** #endif
 400:./Eigen/src/Core/util/Macros.h **** 
 401:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_WIN64 set to 1 if the OS is Windows 64bits
 402:./Eigen/src/Core/util/Macros.h **** #if defined(_WIN64)
 403:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN64 1
 404:./Eigen/src/Core/util/Macros.h **** #else
 405:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN64 0
 406:./Eigen/src/Core/util/Macros.h **** #endif
 407:./Eigen/src/Core/util/Macros.h **** 
 408:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_WINCE set to 1 if the OS is Windows CE
 409:./Eigen/src/Core/util/Macros.h **** #if defined(_WIN32_WCE)
 410:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WINCE 1
 411:./Eigen/src/Core/util/Macros.h **** #else
 412:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WINCE 0
 413:./Eigen/src/Core/util/Macros.h **** #endif
 414:./Eigen/src/Core/util/Macros.h **** 
 415:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_CYGWIN set to 1 if the OS is Windows/Cygwin
 416:./Eigen/src/Core/util/Macros.h **** #if defined(__CYGWIN__)
 417:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_CYGWIN 1
 418:./Eigen/src/Core/util/Macros.h **** #else
 419:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_CYGWIN 0
 420:./Eigen/src/Core/util/Macros.h **** #endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 123


 421:./Eigen/src/Core/util/Macros.h **** 
 422:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_WIN_STRICT set to 1 if the OS is really Windows and not some variants
 423:./Eigen/src/Core/util/Macros.h **** #if EIGEN_OS_WIN && !( EIGEN_OS_WINCE || EIGEN_OS_CYGWIN )
 424:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN_STRICT 1
 425:./Eigen/src/Core/util/Macros.h **** #else
 426:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_WIN_STRICT 0
 427:./Eigen/src/Core/util/Macros.h **** #endif
 428:./Eigen/src/Core/util/Macros.h **** 
 429:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_SUN set to __SUNPRO_C if the OS is SUN
 430:./Eigen/src/Core/util/Macros.h **** // compiler  solaris   __SUNPRO_C
 431:./Eigen/src/Core/util/Macros.h **** // version   studio
 432:./Eigen/src/Core/util/Macros.h **** // 5.7       10        0x570
 433:./Eigen/src/Core/util/Macros.h **** // 5.8       11        0x580
 434:./Eigen/src/Core/util/Macros.h **** // 5.9       12        0x590
 435:./Eigen/src/Core/util/Macros.h **** // 5.10	     12.1      0x5100
 436:./Eigen/src/Core/util/Macros.h **** // 5.11	     12.2      0x5110
 437:./Eigen/src/Core/util/Macros.h **** // 5.12	     12.3      0x5120
 438:./Eigen/src/Core/util/Macros.h **** #if (defined(sun) || defined(__sun)) && !(defined(__SVR4) || defined(__svr4__))
 439:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_SUN __SUNPRO_C
 440:./Eigen/src/Core/util/Macros.h **** #else
 441:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_SUN 0
 442:./Eigen/src/Core/util/Macros.h **** #endif
 443:./Eigen/src/Core/util/Macros.h **** 
 444:./Eigen/src/Core/util/Macros.h **** /// \internal EIGEN_OS_SOLARIS set to 1 if the OS is Solaris
 445:./Eigen/src/Core/util/Macros.h **** #if (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))
 446:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_SOLARIS 1
 447:./Eigen/src/Core/util/Macros.h **** #else
 448:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_OS_SOLARIS 0
 449:./Eigen/src/Core/util/Macros.h **** #endif
 450:./Eigen/src/Core/util/Macros.h **** 
 451:./Eigen/src/Core/util/Macros.h **** 
 452:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 453:./Eigen/src/Core/util/Macros.h **** // Detect GPU compilers and architectures
 454:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 455:./Eigen/src/Core/util/Macros.h **** 
 456:./Eigen/src/Core/util/Macros.h **** // NVCC is not supported as the target platform for HIPCC
 457:./Eigen/src/Core/util/Macros.h **** // Note that this also makes EIGEN_CUDACC and EIGEN_HIPCC mutually exclusive
 458:./Eigen/src/Core/util/Macros.h **** #if defined(__NVCC__) && defined(__HIPCC__)
 459:./Eigen/src/Core/util/Macros.h ****   #error "NVCC as the target platform for HIPCC is currently not supported."
 460:./Eigen/src/Core/util/Macros.h **** #endif
 461:./Eigen/src/Core/util/Macros.h **** 
 462:./Eigen/src/Core/util/Macros.h **** #if defined(__CUDACC__) && !defined(EIGEN_NO_CUDA)
 463:./Eigen/src/Core/util/Macros.h ****   // Means the compiler is either nvcc or clang with CUDA enabled
 464:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_CUDACC __CUDACC__
 465:./Eigen/src/Core/util/Macros.h **** #endif
 466:./Eigen/src/Core/util/Macros.h **** 
 467:./Eigen/src/Core/util/Macros.h **** #if defined(__CUDA_ARCH__) && !defined(EIGEN_NO_CUDA)
 468:./Eigen/src/Core/util/Macros.h ****   // Means we are generating code for the device
 469:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_CUDA_ARCH __CUDA_ARCH__
 470:./Eigen/src/Core/util/Macros.h **** #endif
 471:./Eigen/src/Core/util/Macros.h **** 
 472:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_CUDACC)
 473:./Eigen/src/Core/util/Macros.h **** #include <cuda.h>
 474:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_CUDA_SDK_VER (CUDA_VERSION * 10)
 475:./Eigen/src/Core/util/Macros.h **** #else
 476:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_CUDA_SDK_VER 0
 477:./Eigen/src/Core/util/Macros.h **** #endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 124


 478:./Eigen/src/Core/util/Macros.h **** 
 479:./Eigen/src/Core/util/Macros.h **** #if defined(__HIPCC__) && !defined(EIGEN_NO_HIP)
 480:./Eigen/src/Core/util/Macros.h ****   // Means the compiler is HIPCC (analogous to EIGEN_CUDACC, but for HIP)
 481:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HIPCC __HIPCC__
 482:./Eigen/src/Core/util/Macros.h **** 
 483:./Eigen/src/Core/util/Macros.h ****   // We need to include hip_runtime.h here because it pulls in
 484:./Eigen/src/Core/util/Macros.h ****   // ++ hip_common.h which contains the define for  __HIP_DEVICE_COMPILE__
 485:./Eigen/src/Core/util/Macros.h ****   // ++ host_defines.h which contains the defines for the __host__ and __device__ macros
 486:./Eigen/src/Core/util/Macros.h ****   #include <hip/hip_runtime.h>
 487:./Eigen/src/Core/util/Macros.h **** 
 488:./Eigen/src/Core/util/Macros.h ****   #if defined(__HIP_DEVICE_COMPILE__)
 489:./Eigen/src/Core/util/Macros.h ****     // analogous to EIGEN_CUDA_ARCH, but for HIP
 490:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HIP_DEVICE_COMPILE __HIP_DEVICE_COMPILE__
 491:./Eigen/src/Core/util/Macros.h ****   #endif
 492:./Eigen/src/Core/util/Macros.h **** 
 493:./Eigen/src/Core/util/Macros.h ****   // For HIP (ROCm 3.5 and higher), we need to explicitly set the launch_bounds attribute
 494:./Eigen/src/Core/util/Macros.h ****   // value to 1024. The compiler assigns a default value of 256 when the attribute is not
 495:./Eigen/src/Core/util/Macros.h ****   // specified. This results in failures on the HIP platform, for cases when a GPU kernel
 496:./Eigen/src/Core/util/Macros.h ****   // without an explicit launch_bounds attribute is called with a threads_per_block value
 497:./Eigen/src/Core/util/Macros.h ****   // greater than 256.
 498:./Eigen/src/Core/util/Macros.h ****   //
 499:./Eigen/src/Core/util/Macros.h ****   // This is a regression in functioanlity and is expected to be fixed within the next
 500:./Eigen/src/Core/util/Macros.h ****   // couple of ROCm releases (compiler will go back to using 1024 value as the default)
 501:./Eigen/src/Core/util/Macros.h ****   //
 502:./Eigen/src/Core/util/Macros.h ****   // In the meantime, we will use a "only enabled for HIP" macro to set the launch_bounds
 503:./Eigen/src/Core/util/Macros.h ****   // attribute.
 504:./Eigen/src/Core/util/Macros.h **** 
 505:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HIP_LAUNCH_BOUNDS_1024 __launch_bounds__(1024)
 506:./Eigen/src/Core/util/Macros.h **** 
 507:./Eigen/src/Core/util/Macros.h **** #endif
 508:./Eigen/src/Core/util/Macros.h **** 
 509:./Eigen/src/Core/util/Macros.h **** #if !defined(EIGEN_HIP_LAUNCH_BOUNDS_1024)
 510:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HIP_LAUNCH_BOUNDS_1024
 511:./Eigen/src/Core/util/Macros.h **** #endif // !defined(EIGEN_HIP_LAUNCH_BOUNDS_1024)
 512:./Eigen/src/Core/util/Macros.h **** 
 513:./Eigen/src/Core/util/Macros.h **** // Unify CUDA/HIPCC
 514:./Eigen/src/Core/util/Macros.h **** 
 515:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_CUDACC) || defined(EIGEN_HIPCC)
 516:./Eigen/src/Core/util/Macros.h **** //
 517:./Eigen/src/Core/util/Macros.h **** // If either EIGEN_CUDACC or EIGEN_HIPCC is defined, then define EIGEN_GPUCC
 518:./Eigen/src/Core/util/Macros.h **** //
 519:./Eigen/src/Core/util/Macros.h **** #define EIGEN_GPUCC
 520:./Eigen/src/Core/util/Macros.h **** //
 521:./Eigen/src/Core/util/Macros.h **** // EIGEN_HIPCC implies the HIP compiler and is used to tweak Eigen code for use in HIP kernels
 522:./Eigen/src/Core/util/Macros.h **** // EIGEN_CUDACC implies the CUDA compiler and is used to tweak Eigen code for use in CUDA kernels
 523:./Eigen/src/Core/util/Macros.h **** //
 524:./Eigen/src/Core/util/Macros.h **** // In most cases the same tweaks are required to the Eigen code to enable in both the HIP and CUDA 
 525:./Eigen/src/Core/util/Macros.h **** // For those cases, the corresponding code should be guarded with
 526:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_GPUCC)
 527:./Eigen/src/Core/util/Macros.h **** // instead of
 528:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_CUDACC) || defined(EIGEN_HIPCC)
 529:./Eigen/src/Core/util/Macros.h **** //
 530:./Eigen/src/Core/util/Macros.h **** // For cases where the tweak is specific to HIP, the code should be guarded with
 531:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_HIPCC)
 532:./Eigen/src/Core/util/Macros.h **** //
 533:./Eigen/src/Core/util/Macros.h **** // For cases where the tweak is specific to CUDA, the code should be guarded with
 534:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_CUDACC)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 125


 535:./Eigen/src/Core/util/Macros.h **** //
 536:./Eigen/src/Core/util/Macros.h **** #endif
 537:./Eigen/src/Core/util/Macros.h **** 
 538:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_CUDA_ARCH) || defined(EIGEN_HIP_DEVICE_COMPILE)
 539:./Eigen/src/Core/util/Macros.h **** //
 540:./Eigen/src/Core/util/Macros.h **** // If either EIGEN_CUDA_ARCH or EIGEN_HIP_DEVICE_COMPILE is defined, then define EIGEN_GPU_COMPILE_
 541:./Eigen/src/Core/util/Macros.h **** //
 542:./Eigen/src/Core/util/Macros.h **** #define EIGEN_GPU_COMPILE_PHASE
 543:./Eigen/src/Core/util/Macros.h **** //
 544:./Eigen/src/Core/util/Macros.h **** // GPU compilers (HIPCC, NVCC) typically do two passes over the source code,
 545:./Eigen/src/Core/util/Macros.h **** //   + one to compile the source for the "host" (ie CPU)
 546:./Eigen/src/Core/util/Macros.h **** //   + another to compile the source for the "device" (ie. GPU)
 547:./Eigen/src/Core/util/Macros.h **** //
 548:./Eigen/src/Core/util/Macros.h **** // Code that needs to enabled only during the either the "host" or "device" compilation phase
 549:./Eigen/src/Core/util/Macros.h **** // needs to be guarded with a macro that indicates the current compilation phase
 550:./Eigen/src/Core/util/Macros.h **** //
 551:./Eigen/src/Core/util/Macros.h **** // EIGEN_HIP_DEVICE_COMPILE implies the device compilation phase in HIP
 552:./Eigen/src/Core/util/Macros.h **** // EIGEN_CUDA_ARCH implies the device compilation phase in CUDA
 553:./Eigen/src/Core/util/Macros.h **** //
 554:./Eigen/src/Core/util/Macros.h **** // In most cases, the "host" / "device" specific code is the same for both HIP and CUDA
 555:./Eigen/src/Core/util/Macros.h **** // For those cases, the code should be guarded with
 556:./Eigen/src/Core/util/Macros.h **** //       #if defined(EIGEN_GPU_COMPILE_PHASE)
 557:./Eigen/src/Core/util/Macros.h **** // instead of
 558:./Eigen/src/Core/util/Macros.h **** //       #if defined(EIGEN_CUDA_ARCH) || defined(EIGEN_HIP_DEVICE_COMPILE)
 559:./Eigen/src/Core/util/Macros.h **** //
 560:./Eigen/src/Core/util/Macros.h **** // For cases where the tweak is specific to HIP, the code should be guarded with
 561:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_HIP_DEVICE_COMPILE)
 562:./Eigen/src/Core/util/Macros.h **** //
 563:./Eigen/src/Core/util/Macros.h **** // For cases where the tweak is specific to CUDA, the code should be guarded with
 564:./Eigen/src/Core/util/Macros.h **** //      #if defined(EIGEN_CUDA_ARCH)
 565:./Eigen/src/Core/util/Macros.h **** //
 566:./Eigen/src/Core/util/Macros.h **** #endif
 567:./Eigen/src/Core/util/Macros.h **** 
 568:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_USE_SYCL) && defined(__SYCL_DEVICE_ONLY__)
 569:./Eigen/src/Core/util/Macros.h **** // EIGEN_USE_SYCL is a user-defined macro while __SYCL_DEVICE_ONLY__ is a compiler-defined macro.
 570:./Eigen/src/Core/util/Macros.h **** // In most cases we want to check if both macros are defined which can be done using the define bel
 571:./Eigen/src/Core/util/Macros.h **** #define SYCL_DEVICE_ONLY
 572:./Eigen/src/Core/util/Macros.h **** #endif
 573:./Eigen/src/Core/util/Macros.h **** 
 574:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 575:./Eigen/src/Core/util/Macros.h **** // Detect Compiler/Architecture/OS specific features
 576:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 577:./Eigen/src/Core/util/Macros.h **** 
 578:./Eigen/src/Core/util/Macros.h **** #if EIGEN_GNUC_AT_MOST(4,3) && !EIGEN_COMP_CLANG
 579:./Eigen/src/Core/util/Macros.h ****   // see bug 89
 580:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO 0
 581:./Eigen/src/Core/util/Macros.h **** #else
 582:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO 1
 583:./Eigen/src/Core/util/Macros.h **** #endif
 584:./Eigen/src/Core/util/Macros.h **** 
 585:./Eigen/src/Core/util/Macros.h **** // Cross compiler wrapper around LLVM's __has_builtin
 586:./Eigen/src/Core/util/Macros.h **** #ifdef __has_builtin
 587:./Eigen/src/Core/util/Macros.h **** #  define EIGEN_HAS_BUILTIN(x) __has_builtin(x)
 588:./Eigen/src/Core/util/Macros.h **** #else
 589:./Eigen/src/Core/util/Macros.h **** #  define EIGEN_HAS_BUILTIN(x) 0
 590:./Eigen/src/Core/util/Macros.h **** #endif
 591:./Eigen/src/Core/util/Macros.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 126


 592:./Eigen/src/Core/util/Macros.h **** // A Clang feature extension to determine compiler features.
 593:./Eigen/src/Core/util/Macros.h **** // We use it to determine 'cxx_rvalue_references'
 594:./Eigen/src/Core/util/Macros.h **** #ifndef __has_feature
 595:./Eigen/src/Core/util/Macros.h **** # define __has_feature(x) 0
 596:./Eigen/src/Core/util/Macros.h **** #endif
 597:./Eigen/src/Core/util/Macros.h **** 
 598:./Eigen/src/Core/util/Macros.h **** // Some old compilers do not support template specializations like:
 599:./Eigen/src/Core/util/Macros.h **** // template<typename T,int N> void foo(const T x[N]);
 600:./Eigen/src/Core/util/Macros.h **** #if !(   EIGEN_COMP_CLANG && (   (EIGEN_COMP_CLANG<309)                                            
 601:./Eigen/src/Core/util/Macros.h ****                               || (defined(__apple_build_version__) && (__apple_build_version__ < 90
 602:./Eigen/src/Core/util/Macros.h ****       || EIGEN_COMP_GNUC_STRICT && EIGEN_COMP_GNUC<49)
 603:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STATIC_ARRAY_TEMPLATE 1
 604:./Eigen/src/Core/util/Macros.h **** #else
 605:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STATIC_ARRAY_TEMPLATE 0
 606:./Eigen/src/Core/util/Macros.h **** #endif
 607:./Eigen/src/Core/util/Macros.h **** 
 608:./Eigen/src/Core/util/Macros.h **** // The macro EIGEN_CPLUSPLUS is a replacement for __cplusplus/_MSVC_LANG that
 609:./Eigen/src/Core/util/Macros.h **** // works for both platforms, indicating the C++ standard version number.
 610:./Eigen/src/Core/util/Macros.h **** //
 611:./Eigen/src/Core/util/Macros.h **** // With MSVC, without defining /Zc:__cplusplus, the __cplusplus macro will
 612:./Eigen/src/Core/util/Macros.h **** // report 199711L regardless of the language standard specified via /std.
 613:./Eigen/src/Core/util/Macros.h **** // We need to rely on _MSVC_LANG instead, which is only available after
 614:./Eigen/src/Core/util/Macros.h **** // VS2015.3.
 615:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_MSVC_LANG > 0
 616:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CPLUSPLUS EIGEN_COMP_MSVC_LANG
 617:./Eigen/src/Core/util/Macros.h **** #elif EIGEN_COMP_MSVC >= 1900
 618:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CPLUSPLUS 201103L
 619:./Eigen/src/Core/util/Macros.h **** #elif defined(__cplusplus)
 620:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CPLUSPLUS __cplusplus
 621:./Eigen/src/Core/util/Macros.h **** #else
 622:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CPLUSPLUS 0
 623:./Eigen/src/Core/util/Macros.h **** #endif
 624:./Eigen/src/Core/util/Macros.h **** 
 625:./Eigen/src/Core/util/Macros.h **** // The macro EIGEN_COMP_CXXVER defines the c++ verson expected by the compiler.
 626:./Eigen/src/Core/util/Macros.h **** // For instance, if compiling with gcc and -std=c++17, then EIGEN_COMP_CXXVER
 627:./Eigen/src/Core/util/Macros.h **** // is defined to 17.
 628:./Eigen/src/Core/util/Macros.h **** #if EIGEN_CPLUSPLUS > 201703L
 629:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CXXVER 20
 630:./Eigen/src/Core/util/Macros.h **** #elif EIGEN_CPLUSPLUS > 201402L
 631:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CXXVER 17
 632:./Eigen/src/Core/util/Macros.h **** #elif EIGEN_CPLUSPLUS > 201103L
 633:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CXXVER 14
 634:./Eigen/src/Core/util/Macros.h **** #elif EIGEN_CPLUSPLUS >= 201103L
 635:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CXXVER 11
 636:./Eigen/src/Core/util/Macros.h **** #else
 637:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_COMP_CXXVER 03
 638:./Eigen/src/Core/util/Macros.h **** #endif
 639:./Eigen/src/Core/util/Macros.h **** 
 640:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX14_VARIABLE_TEMPLATES
 641:./Eigen/src/Core/util/Macros.h ****   #if defined(__cpp_variable_templates) && __cpp_variable_templates >= 201304 && EIGEN_MAX_CPP_VER>
 642:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX14_VARIABLE_TEMPLATES 1
 643:./Eigen/src/Core/util/Macros.h ****   #else
 644:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX14_VARIABLE_TEMPLATES 0
 645:./Eigen/src/Core/util/Macros.h ****   #endif
 646:./Eigen/src/Core/util/Macros.h **** #endif
 647:./Eigen/src/Core/util/Macros.h **** 
 648:./Eigen/src/Core/util/Macros.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 127


 649:./Eigen/src/Core/util/Macros.h **** // The macros EIGEN_HAS_CXX?? defines a rough estimate of available c++ features
 650:./Eigen/src/Core/util/Macros.h **** // but in practice we should not rely on them but rather on the availabilty of
 651:./Eigen/src/Core/util/Macros.h **** // individual features as defined later.
 652:./Eigen/src/Core/util/Macros.h **** // This is why there is no EIGEN_HAS_CXX17.
 653:./Eigen/src/Core/util/Macros.h **** // FIXME: get rid of EIGEN_HAS_CXX14 and maybe even EIGEN_HAS_CXX11.
 654:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && EIGEN_COMP_CXXVER>=11
 655:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX11 1
 656:./Eigen/src/Core/util/Macros.h **** #else
 657:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX11 0
 658:./Eigen/src/Core/util/Macros.h **** #endif
 659:./Eigen/src/Core/util/Macros.h **** 
 660:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=14 && EIGEN_COMP_CXXVER>=14
 661:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX14 1
 662:./Eigen/src/Core/util/Macros.h **** #else
 663:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX14 0
 664:./Eigen/src/Core/util/Macros.h **** #endif
 665:./Eigen/src/Core/util/Macros.h **** 
 666:./Eigen/src/Core/util/Macros.h **** // Do we support r-value references?
 667:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_RVALUE_REFERENCES
 668:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && \
 669:./Eigen/src/Core/util/Macros.h ****     (__has_feature(cxx_rvalue_references) || \
 670:./Eigen/src/Core/util/Macros.h ****      (EIGEN_COMP_CXXVER >= 11) || (EIGEN_COMP_MSVC >= 1600))
 671:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HAS_RVALUE_REFERENCES 1
 672:./Eigen/src/Core/util/Macros.h **** #else
 673:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HAS_RVALUE_REFERENCES 0
 674:./Eigen/src/Core/util/Macros.h **** #endif
 675:./Eigen/src/Core/util/Macros.h **** #endif
 676:./Eigen/src/Core/util/Macros.h **** 
 677:./Eigen/src/Core/util/Macros.h **** // Does the compiler support C99?
 678:./Eigen/src/Core/util/Macros.h **** // Need to include <cmath> to make sure _GLIBCXX_USE_C99 gets defined
 679:./Eigen/src/Core/util/Macros.h **** #include <cmath>
 680:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_C99_MATH
 681:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && \
 682:./Eigen/src/Core/util/Macros.h ****     ((defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901))       \
 683:./Eigen/src/Core/util/Macros.h ****   || (defined(__GNUC__) && defined(_GLIBCXX_USE_C99)) \
 684:./Eigen/src/Core/util/Macros.h ****   || (defined(_LIBCPP_VERSION) && !defined(_MSC_VER)) \
 685:./Eigen/src/Core/util/Macros.h ****   || (EIGEN_COMP_MSVC >= 1900) || defined(SYCL_DEVICE_ONLY))
 686:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HAS_C99_MATH 1
 687:./Eigen/src/Core/util/Macros.h **** #else
 688:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_HAS_C99_MATH 0
 689:./Eigen/src/Core/util/Macros.h **** #endif
 690:./Eigen/src/Core/util/Macros.h **** #endif
 691:./Eigen/src/Core/util/Macros.h **** 
 692:./Eigen/src/Core/util/Macros.h **** // Does the compiler support result_of?
 693:./Eigen/src/Core/util/Macros.h **** // result_of was deprecated in c++17 and removed in c++ 20
 694:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_STD_RESULT_OF
 695:./Eigen/src/Core/util/Macros.h **** #if EIGEN_HAS_CXX11 && EIGEN_COMP_CXXVER < 17
 696:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_RESULT_OF 1
 697:./Eigen/src/Core/util/Macros.h **** #else
 698:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_RESULT_OF 0
 699:./Eigen/src/Core/util/Macros.h **** #endif
 700:./Eigen/src/Core/util/Macros.h **** #endif
 701:./Eigen/src/Core/util/Macros.h **** 
 702:./Eigen/src/Core/util/Macros.h **** // Does the compiler support std::hash?
 703:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_STD_HASH
 704:./Eigen/src/Core/util/Macros.h **** // The std::hash struct is defined in C++11 but is not labelled as a __device__
 705:./Eigen/src/Core/util/Macros.h **** // function and is not constexpr, so cannot be used on device.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 128


 706:./Eigen/src/Core/util/Macros.h **** #if EIGEN_HAS_CXX11 && !defined(EIGEN_GPU_COMPILE_PHASE)
 707:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_HASH 1
 708:./Eigen/src/Core/util/Macros.h **** #else
 709:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_HASH 0
 710:./Eigen/src/Core/util/Macros.h **** #endif
 711:./Eigen/src/Core/util/Macros.h **** #endif  // EIGEN_HAS_STD_HASH
 712:./Eigen/src/Core/util/Macros.h **** 
 713:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_STD_INVOKE_RESULT
 714:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER >= 17 && EIGEN_COMP_CXXVER >= 17
 715:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_INVOKE_RESULT 1
 716:./Eigen/src/Core/util/Macros.h **** #else
 717:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_STD_INVOKE_RESULT 0
 718:./Eigen/src/Core/util/Macros.h **** #endif
 719:./Eigen/src/Core/util/Macros.h **** #endif
 720:./Eigen/src/Core/util/Macros.h **** 
 721:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_ALIGNAS
 722:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && EIGEN_HAS_CXX11 &&   \
 723:./Eigen/src/Core/util/Macros.h ****       (     __has_feature(cxx_alignas)            \
 724:./Eigen/src/Core/util/Macros.h ****         ||  EIGEN_HAS_CXX14                       \
 725:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_COMP_MSVC >= 1800)              \
 726:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_GNUC_AT_LEAST(4,8))             \
 727:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_COMP_CLANG>=305)                \
 728:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_COMP_ICC>=1500)                 \
 729:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_COMP_PGI>=1500)                 \
 730:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_COMP_SUNCC>=0x5130))
 731:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_ALIGNAS 1
 732:./Eigen/src/Core/util/Macros.h **** #else
 733:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_ALIGNAS 0
 734:./Eigen/src/Core/util/Macros.h **** #endif
 735:./Eigen/src/Core/util/Macros.h **** #endif
 736:./Eigen/src/Core/util/Macros.h **** 
 737:./Eigen/src/Core/util/Macros.h **** // Does the compiler support type_traits?
 738:./Eigen/src/Core/util/Macros.h **** // - full support of type traits was added only to GCC 5.1.0.
 739:./Eigen/src/Core/util/Macros.h **** // - 20150626 corresponds to the last release of 4.x libstdc++
 740:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_TYPE_TRAITS
 741:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && (EIGEN_HAS_CXX11 || EIGEN_COMP_MSVC >= 1700) \
 742:./Eigen/src/Core/util/Macros.h ****   && ((!EIGEN_COMP_GNUC_STRICT) || EIGEN_GNUC_AT_LEAST(5, 1)) \
 743:./Eigen/src/Core/util/Macros.h ****   && ((!defined(__GLIBCXX__))   || __GLIBCXX__ > 20150626)
 744:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_TYPE_TRAITS 1
 745:./Eigen/src/Core/util/Macros.h **** #define EIGEN_INCLUDE_TYPE_TRAITS
 746:./Eigen/src/Core/util/Macros.h **** #else
 747:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_TYPE_TRAITS 0
 748:./Eigen/src/Core/util/Macros.h **** #endif
 749:./Eigen/src/Core/util/Macros.h **** #endif
 750:./Eigen/src/Core/util/Macros.h **** 
 751:./Eigen/src/Core/util/Macros.h **** // Does the compiler support variadic templates?
 752:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_VARIADIC_TEMPLATES
 753:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=11 && (EIGEN_COMP_CXXVER >= 11) \
 754:./Eigen/src/Core/util/Macros.h ****   && (!defined(__NVCC__) || !EIGEN_ARCH_ARM_OR_ARM64 || (EIGEN_COMP_NVCC >= 80000) )
 755:./Eigen/src/Core/util/Macros.h ****     // ^^ Disable the use of variadic templates when compiling with versions of nvcc older than 8.0
 756:./Eigen/src/Core/util/Macros.h ****     //    this prevents nvcc from crashing when compiling Eigen on Tegra X1
 757:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_VARIADIC_TEMPLATES 1
 758:./Eigen/src/Core/util/Macros.h **** #elif  EIGEN_MAX_CPP_VER>=11 && (EIGEN_COMP_CXXVER >= 11) && defined(SYCL_DEVICE_ONLY)
 759:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_VARIADIC_TEMPLATES 1
 760:./Eigen/src/Core/util/Macros.h **** #else
 761:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_VARIADIC_TEMPLATES 0
 762:./Eigen/src/Core/util/Macros.h **** #endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 129


 763:./Eigen/src/Core/util/Macros.h **** #endif
 764:./Eigen/src/Core/util/Macros.h **** 
 765:./Eigen/src/Core/util/Macros.h **** // Does the compiler fully support const expressions? (as in c++14)
 766:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CONSTEXPR
 767:./Eigen/src/Core/util/Macros.h ****   #if defined(EIGEN_CUDACC)
 768:./Eigen/src/Core/util/Macros.h ****   // Const expressions are supported provided that c++11 is enabled and we're using either clang or
 769:./Eigen/src/Core/util/Macros.h ****     #if EIGEN_MAX_CPP_VER>=14 && (EIGEN_COMP_CXXVER >= 11 && (EIGEN_COMP_CLANG || EIGEN_COMP_NVCC >
 770:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_HAS_CONSTEXPR 1
 771:./Eigen/src/Core/util/Macros.h ****     #endif
 772:./Eigen/src/Core/util/Macros.h ****   #elif EIGEN_MAX_CPP_VER>=14 && (__has_feature(cxx_relaxed_constexpr) || (EIGEN_COMP_CXXVER >= 14)
 773:./Eigen/src/Core/util/Macros.h ****     (EIGEN_GNUC_AT_LEAST(4,8) && (EIGEN_COMP_CXXVER >= 11)) || \
 774:./Eigen/src/Core/util/Macros.h ****     (EIGEN_COMP_CLANG >= 306 && (EIGEN_COMP_CXXVER >= 11)))
 775:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CONSTEXPR 1
 776:./Eigen/src/Core/util/Macros.h ****   #endif
 777:./Eigen/src/Core/util/Macros.h **** 
 778:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_HAS_CONSTEXPR
 779:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CONSTEXPR 0
 780:./Eigen/src/Core/util/Macros.h ****   #endif
 781:./Eigen/src/Core/util/Macros.h **** 
 782:./Eigen/src/Core/util/Macros.h **** #endif // EIGEN_HAS_CONSTEXPR
 783:./Eigen/src/Core/util/Macros.h **** 
 784:./Eigen/src/Core/util/Macros.h **** #if EIGEN_HAS_CONSTEXPR
 785:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CONSTEXPR constexpr
 786:./Eigen/src/Core/util/Macros.h **** #else
 787:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CONSTEXPR
 788:./Eigen/src/Core/util/Macros.h **** #endif
 789:./Eigen/src/Core/util/Macros.h **** 
 790:./Eigen/src/Core/util/Macros.h **** // Does the compiler support C++11 math?
 791:./Eigen/src/Core/util/Macros.h **** // Let's be conservative and enable the default C++11 implementation only if we are sure it exists
 792:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX11_MATH
 793:./Eigen/src/Core/util/Macros.h ****   #if EIGEN_MAX_CPP_VER>=11 && ((EIGEN_COMP_CXXVER > 11) || (EIGEN_COMP_CXXVER == 11) && (EIGEN_COM
 794:./Eigen/src/Core/util/Macros.h ****       && (EIGEN_ARCH_i386_OR_x86_64) && (EIGEN_OS_GNULINUX || EIGEN_OS_WIN_STRICT || EIGEN_OS_MAC))
 795:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_MATH 1
 796:./Eigen/src/Core/util/Macros.h ****   #else
 797:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_MATH 0
 798:./Eigen/src/Core/util/Macros.h ****   #endif
 799:./Eigen/src/Core/util/Macros.h **** #endif
 800:./Eigen/src/Core/util/Macros.h **** 
 801:./Eigen/src/Core/util/Macros.h **** // Does the compiler support proper C++11 containers?
 802:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX11_CONTAINERS
 803:./Eigen/src/Core/util/Macros.h ****   #if    EIGEN_MAX_CPP_VER>=11 && \
 804:./Eigen/src/Core/util/Macros.h ****          ((EIGEN_COMP_CXXVER > 11) \
 805:./Eigen/src/Core/util/Macros.h ****       || ((EIGEN_COMP_CXXVER == 11) && (EIGEN_COMP_GNUC_STRICT || EIGEN_COMP_CLANG || EIGEN_COMP_MS
 806:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_CONTAINERS 1
 807:./Eigen/src/Core/util/Macros.h ****   #else
 808:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_CONTAINERS 0
 809:./Eigen/src/Core/util/Macros.h ****   #endif
 810:./Eigen/src/Core/util/Macros.h **** #endif
 811:./Eigen/src/Core/util/Macros.h **** 
 812:./Eigen/src/Core/util/Macros.h **** // Does the compiler support C++11 noexcept?
 813:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX11_NOEXCEPT
 814:./Eigen/src/Core/util/Macros.h ****   #if    EIGEN_MAX_CPP_VER>=11 && \
 815:./Eigen/src/Core/util/Macros.h ****          (__has_feature(cxx_noexcept) \
 816:./Eigen/src/Core/util/Macros.h ****       || (EIGEN_COMP_CXXVER > 11) \
 817:./Eigen/src/Core/util/Macros.h ****       || ((EIGEN_COMP_CXXVER == 11) && (EIGEN_COMP_GNUC_STRICT || EIGEN_COMP_CLANG || EIGEN_COMP_MS
 818:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_NOEXCEPT 1
 819:./Eigen/src/Core/util/Macros.h ****   #else
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 130


 820:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_NOEXCEPT 0
 821:./Eigen/src/Core/util/Macros.h ****   #endif
 822:./Eigen/src/Core/util/Macros.h **** #endif
 823:./Eigen/src/Core/util/Macros.h **** 
 824:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX11_ATOMIC
 825:./Eigen/src/Core/util/Macros.h ****   #if    EIGEN_MAX_CPP_VER>=11 && \
 826:./Eigen/src/Core/util/Macros.h ****          (__has_feature(cxx_atomic) \
 827:./Eigen/src/Core/util/Macros.h ****       || (EIGEN_COMP_CXXVER > 11) \
 828:./Eigen/src/Core/util/Macros.h ****       || ((EIGEN_COMP_CXXVER == 11) && (EIGEN_COMP_MSVC==0 || EIGEN_COMP_MSVC >= 1700)))
 829:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_ATOMIC 1
 830:./Eigen/src/Core/util/Macros.h ****   #else
 831:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_ATOMIC 0
 832:./Eigen/src/Core/util/Macros.h ****   #endif
 833:./Eigen/src/Core/util/Macros.h **** #endif
 834:./Eigen/src/Core/util/Macros.h **** 
 835:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX11_OVERRIDE_FINAL
 836:./Eigen/src/Core/util/Macros.h ****   #if    EIGEN_MAX_CPP_VER>=11 && \
 837:./Eigen/src/Core/util/Macros.h ****        (EIGEN_COMP_CXXVER >= 11 || EIGEN_COMP_MSVC >= 1700)
 838:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_OVERRIDE_FINAL 1
 839:./Eigen/src/Core/util/Macros.h ****   #else
 840:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_HAS_CXX11_OVERRIDE_FINAL 0
 841:./Eigen/src/Core/util/Macros.h ****   #endif
 842:./Eigen/src/Core/util/Macros.h **** #endif
 843:./Eigen/src/Core/util/Macros.h **** 
 844:./Eigen/src/Core/util/Macros.h **** // NOTE: the required Apple's clang version is very conservative
 845:./Eigen/src/Core/util/Macros.h **** //       and it could be that XCode 9 works just fine.
 846:./Eigen/src/Core/util/Macros.h **** // NOTE: the MSVC version is based on https://en.cppreference.com/w/cpp/compiler_support
 847:./Eigen/src/Core/util/Macros.h **** //       and not tested.
 848:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_CXX17_OVERALIGN
 849:./Eigen/src/Core/util/Macros.h **** #if EIGEN_MAX_CPP_VER>=17 && EIGEN_COMP_CXXVER>=17 && (                                 \
 850:./Eigen/src/Core/util/Macros.h ****            (EIGEN_COMP_MSVC >= 1912)                                                    \
 851:./Eigen/src/Core/util/Macros.h ****         || (EIGEN_GNUC_AT_LEAST(7,0))                                                   \
 852:./Eigen/src/Core/util/Macros.h ****         || ((!defined(__apple_build_version__)) && (EIGEN_COMP_CLANG>=500))             \
 853:./Eigen/src/Core/util/Macros.h ****         || (( defined(__apple_build_version__)) && (__apple_build_version__>=10000000)) \
 854:./Eigen/src/Core/util/Macros.h ****       )
 855:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX17_OVERALIGN 1
 856:./Eigen/src/Core/util/Macros.h **** #else
 857:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_CXX17_OVERALIGN 0
 858:./Eigen/src/Core/util/Macros.h **** #endif
 859:./Eigen/src/Core/util/Macros.h **** #endif
 860:./Eigen/src/Core/util/Macros.h **** 
 861:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_CUDACC) && EIGEN_HAS_CONSTEXPR
 862:./Eigen/src/Core/util/Macros.h ****   // While available already with c++11, this is useful mostly starting with c++14 and relaxed cons
 863:./Eigen/src/Core/util/Macros.h ****   #if defined(__NVCC__)
 864:./Eigen/src/Core/util/Macros.h ****     // nvcc considers constexpr functions as __host__ __device__ with the option --expt-relaxed-con
 865:./Eigen/src/Core/util/Macros.h ****     #ifdef __CUDACC_RELAXED_CONSTEXPR__
 866:./Eigen/src/Core/util/Macros.h ****       #define EIGEN_CONSTEXPR_ARE_DEVICE_FUNC
 867:./Eigen/src/Core/util/Macros.h ****     #endif
 868:./Eigen/src/Core/util/Macros.h ****   #elif defined(__clang__) && defined(__CUDA__) && __has_feature(cxx_relaxed_constexpr)
 869:./Eigen/src/Core/util/Macros.h ****     // clang++ always considers constexpr functions as implicitly __host__ __device__
 870:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_CONSTEXPR_ARE_DEVICE_FUNC
 871:./Eigen/src/Core/util/Macros.h ****   #endif
 872:./Eigen/src/Core/util/Macros.h **** #endif
 873:./Eigen/src/Core/util/Macros.h **** 
 874:./Eigen/src/Core/util/Macros.h **** // Does the compiler support the __int128 and __uint128_t extensions for 128-bit
 875:./Eigen/src/Core/util/Macros.h **** // integer arithmetic?
 876:./Eigen/src/Core/util/Macros.h **** //
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 131


 877:./Eigen/src/Core/util/Macros.h **** // Clang and GCC define __SIZEOF_INT128__ when these extensions are supported,
 878:./Eigen/src/Core/util/Macros.h **** // but we avoid using them in certain cases:
 879:./Eigen/src/Core/util/Macros.h **** //
 880:./Eigen/src/Core/util/Macros.h **** // * Building using Clang for Windows, where the Clang runtime library has
 881:./Eigen/src/Core/util/Macros.h **** //   128-bit support only on LP64 architectures, but Windows is LLP64.
 882:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_HAS_BUILTIN_INT128
 883:./Eigen/src/Core/util/Macros.h **** #if defined(__SIZEOF_INT128__) && !(EIGEN_OS_WIN && EIGEN_COMP_CLANG)
 884:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_BUILTIN_INT128 1
 885:./Eigen/src/Core/util/Macros.h **** #else
 886:./Eigen/src/Core/util/Macros.h **** #define EIGEN_HAS_BUILTIN_INT128 0
 887:./Eigen/src/Core/util/Macros.h **** #endif
 888:./Eigen/src/Core/util/Macros.h **** #endif
 889:./Eigen/src/Core/util/Macros.h **** 
 890:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 891:./Eigen/src/Core/util/Macros.h **** // Preprocessor programming helpers
 892:./Eigen/src/Core/util/Macros.h **** //------------------------------------------------------------------------------------------
 893:./Eigen/src/Core/util/Macros.h **** 
 894:./Eigen/src/Core/util/Macros.h **** // This macro can be used to prevent from macro expansion, e.g.:
 895:./Eigen/src/Core/util/Macros.h **** //   std::max EIGEN_NOT_A_MACRO(a,b)
 896:./Eigen/src/Core/util/Macros.h **** #define EIGEN_NOT_A_MACRO
 897:./Eigen/src/Core/util/Macros.h **** 
 898:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DEBUG_VAR(x) std::cerr << #x << " = " << x << std::endl;
 899:./Eigen/src/Core/util/Macros.h **** 
 900:./Eigen/src/Core/util/Macros.h **** // concatenate two tokens
 901:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CAT2(a,b) a ## b
 902:./Eigen/src/Core/util/Macros.h **** #define EIGEN_CAT(a,b) EIGEN_CAT2(a,b)
 903:./Eigen/src/Core/util/Macros.h **** 
 904:./Eigen/src/Core/util/Macros.h **** #define EIGEN_COMMA ,
 905:./Eigen/src/Core/util/Macros.h **** 
 906:./Eigen/src/Core/util/Macros.h **** // convert a token to a string
 907:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MAKESTRING2(a) #a
 908:./Eigen/src/Core/util/Macros.h **** #define EIGEN_MAKESTRING(a) EIGEN_MAKESTRING2(a)
 909:./Eigen/src/Core/util/Macros.h **** 
 910:./Eigen/src/Core/util/Macros.h **** // EIGEN_STRONG_INLINE is a stronger version of the inline, using __forceinline on MSVC,
 911:./Eigen/src/Core/util/Macros.h **** // but it still doesn't use GCC's always_inline. This is useful in (common) situations where MSVC n
 912:./Eigen/src/Core/util/Macros.h **** // but GCC is still doing fine with just inline.
 913:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_STRONG_INLINE
 914:./Eigen/src/Core/util/Macros.h **** #if (EIGEN_COMP_MSVC || EIGEN_COMP_ICC) && !defined(EIGEN_GPUCC)
 915:./Eigen/src/Core/util/Macros.h **** #define EIGEN_STRONG_INLINE __forceinline
 916:./Eigen/src/Core/util/Macros.h **** #else
 917:./Eigen/src/Core/util/Macros.h **** #define EIGEN_STRONG_INLINE inline
 918:./Eigen/src/Core/util/Macros.h **** #endif
 919:./Eigen/src/Core/util/Macros.h **** #endif
 920:./Eigen/src/Core/util/Macros.h **** 
 921:./Eigen/src/Core/util/Macros.h **** // EIGEN_ALWAYS_INLINE is the stronget, it has the effect of making the function inline and adding 
 922:./Eigen/src/Core/util/Macros.h **** // attribute to maximize inlining. This should only be used when really necessary: in particular,
 923:./Eigen/src/Core/util/Macros.h **** // it uses __attribute__((always_inline)) on GCC, which most of the time is useless and can severel
 924:./Eigen/src/Core/util/Macros.h **** // FIXME with the always_inline attribute,
 925:./Eigen/src/Core/util/Macros.h **** // gcc 3.4.x and 4.1 reports the following compilation error:
 926:./Eigen/src/Core/util/Macros.h **** //   Eval.h:91: sorry, unimplemented: inlining failed in call to 'const Eigen::Eval<Derived> Eigen:
 927:./Eigen/src/Core/util/Macros.h **** //    : function body not available
 928:./Eigen/src/Core/util/Macros.h **** //   See also bug 1367
 929:./Eigen/src/Core/util/Macros.h **** #if EIGEN_GNUC_AT_LEAST(4,2) && !defined(SYCL_DEVICE_ONLY)
 930:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ALWAYS_INLINE __attribute__((always_inline)) inline
 931:./Eigen/src/Core/util/Macros.h **** #else
 932:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ALWAYS_INLINE EIGEN_STRONG_INLINE
 933:./Eigen/src/Core/util/Macros.h **** #endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 132


 934:./Eigen/src/Core/util/Macros.h **** 
 935:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC
 936:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DONT_INLINE __attribute__((noinline))
 937:./Eigen/src/Core/util/Macros.h **** #elif EIGEN_COMP_MSVC
 938:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DONT_INLINE __declspec(noinline)
 939:./Eigen/src/Core/util/Macros.h **** #else
 940:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DONT_INLINE
 941:./Eigen/src/Core/util/Macros.h **** #endif
 942:./Eigen/src/Core/util/Macros.h **** 
 943:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC
 944:./Eigen/src/Core/util/Macros.h **** #define EIGEN_PERMISSIVE_EXPR __extension__
 945:./Eigen/src/Core/util/Macros.h **** #else
 946:./Eigen/src/Core/util/Macros.h **** #define EIGEN_PERMISSIVE_EXPR
 947:./Eigen/src/Core/util/Macros.h **** #endif
 948:./Eigen/src/Core/util/Macros.h **** 
 949:./Eigen/src/Core/util/Macros.h **** // GPU stuff
 950:./Eigen/src/Core/util/Macros.h **** 
 951:./Eigen/src/Core/util/Macros.h **** // Disable some features when compiling with GPU compilers (NVCC/clang-cuda/SYCL/HIPCC)
 952:./Eigen/src/Core/util/Macros.h **** #if defined(EIGEN_CUDACC) || defined(SYCL_DEVICE_ONLY) || defined(EIGEN_HIPCC)
 953:./Eigen/src/Core/util/Macros.h ****   // Do not try asserts on device code
 954:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_NO_DEBUG
 955:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_NO_DEBUG
 956:./Eigen/src/Core/util/Macros.h ****   #endif
 957:./Eigen/src/Core/util/Macros.h **** 
 958:./Eigen/src/Core/util/Macros.h ****   #ifdef EIGEN_INTERNAL_DEBUGGING
 959:./Eigen/src/Core/util/Macros.h ****   #undef EIGEN_INTERNAL_DEBUGGING
 960:./Eigen/src/Core/util/Macros.h ****   #endif
 961:./Eigen/src/Core/util/Macros.h **** 
 962:./Eigen/src/Core/util/Macros.h ****   #ifdef EIGEN_EXCEPTIONS
 963:./Eigen/src/Core/util/Macros.h ****   #undef EIGEN_EXCEPTIONS
 964:./Eigen/src/Core/util/Macros.h ****   #endif
 965:./Eigen/src/Core/util/Macros.h **** #endif
 966:./Eigen/src/Core/util/Macros.h **** 
 967:./Eigen/src/Core/util/Macros.h **** #if defined(SYCL_DEVICE_ONLY)
 968:./Eigen/src/Core/util/Macros.h ****   #ifndef EIGEN_DONT_VECTORIZE
 969:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_DONT_VECTORIZE
 970:./Eigen/src/Core/util/Macros.h ****   #endif
 971:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_DEVICE_FUNC __attribute__((flatten)) __attribute__((always_inline))
 972:./Eigen/src/Core/util/Macros.h **** // All functions callable from CUDA/HIP code must be qualified with __device__
 973:./Eigen/src/Core/util/Macros.h **** #elif defined(EIGEN_GPUCC)
 974:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_DEVICE_FUNC __host__ __device__
 975:./Eigen/src/Core/util/Macros.h **** #else
 976:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_DEVICE_FUNC
 977:./Eigen/src/Core/util/Macros.h **** #endif
 978:./Eigen/src/Core/util/Macros.h **** 
 979:./Eigen/src/Core/util/Macros.h **** 
 980:./Eigen/src/Core/util/Macros.h **** // this macro allows to get rid of linking errors about multiply defined functions.
 981:./Eigen/src/Core/util/Macros.h **** //  - static is not very good because it prevents definitions from different object files to be mer
 982:./Eigen/src/Core/util/Macros.h **** //           So static causes the resulting linked executable to be bloated with multiple copies of
 983:./Eigen/src/Core/util/Macros.h **** //  - inline is not perfect either as it unwantedly hints the compiler toward inlining the function
 984:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_DEVICE_FUNC
 985:./Eigen/src/Core/util/Macros.h **** #define EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_DEVICE_FUNC inline
 986:./Eigen/src/Core/util/Macros.h **** 
 987:./Eigen/src/Core/util/Macros.h **** #ifdef NDEBUG
 988:./Eigen/src/Core/util/Macros.h **** # ifndef EIGEN_NO_DEBUG
 989:./Eigen/src/Core/util/Macros.h **** #  define EIGEN_NO_DEBUG
 990:./Eigen/src/Core/util/Macros.h **** # endif
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 133


 991:./Eigen/src/Core/util/Macros.h **** #endif
 992:./Eigen/src/Core/util/Macros.h **** 
 993:./Eigen/src/Core/util/Macros.h **** // eigen_plain_assert is where we implement the workaround for the assert() bug in GCC <= 4.3, see 
 994:./Eigen/src/Core/util/Macros.h **** #ifdef EIGEN_NO_DEBUG
 995:./Eigen/src/Core/util/Macros.h ****   #ifdef SYCL_DEVICE_ONLY // used to silence the warning on SYCL device
 996:./Eigen/src/Core/util/Macros.h ****     #define eigen_plain_assert(x) EIGEN_UNUSED_VARIABLE(x)
 997:./Eigen/src/Core/util/Macros.h ****   #else
 998:./Eigen/src/Core/util/Macros.h ****     #define eigen_plain_assert(x)
 999:./Eigen/src/Core/util/Macros.h ****   #endif
1000:./Eigen/src/Core/util/Macros.h **** #else
1001:./Eigen/src/Core/util/Macros.h ****   #if EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO
1002:./Eigen/src/Core/util/Macros.h ****     namespace Eigen {
1003:./Eigen/src/Core/util/Macros.h ****     namespace internal {
1004:./Eigen/src/Core/util/Macros.h ****     inline bool copy_bool(bool b) { return b; }
1005:./Eigen/src/Core/util/Macros.h ****     }
1006:./Eigen/src/Core/util/Macros.h ****     }
1007:./Eigen/src/Core/util/Macros.h ****     #define eigen_plain_assert(x) assert(x)
1008:./Eigen/src/Core/util/Macros.h ****   #else
1009:./Eigen/src/Core/util/Macros.h ****     // work around bug 89
1010:./Eigen/src/Core/util/Macros.h ****     #include <cstdlib>   // for abort
1011:./Eigen/src/Core/util/Macros.h ****     #include <iostream>  // for std::cerr
1012:./Eigen/src/Core/util/Macros.h **** 
1013:./Eigen/src/Core/util/Macros.h ****     namespace Eigen {
1014:./Eigen/src/Core/util/Macros.h ****     namespace internal {
1015:./Eigen/src/Core/util/Macros.h ****     // trivial function copying a bool. Must be EIGEN_DONT_INLINE, so we implement it after includi
1016:./Eigen/src/Core/util/Macros.h ****     // see bug 89.
1017:./Eigen/src/Core/util/Macros.h ****     namespace {
1018:./Eigen/src/Core/util/Macros.h ****     EIGEN_DONT_INLINE bool copy_bool(bool b) { return b; }
1019:./Eigen/src/Core/util/Macros.h ****     }
1020:./Eigen/src/Core/util/Macros.h ****     inline void assert_fail(const char *condition, const char *function, const char *file, int line
1021:./Eigen/src/Core/util/Macros.h ****     {
1022:./Eigen/src/Core/util/Macros.h ****       std::cerr << "assertion failed: " << condition << " in function " << function << " at " << fi
1023:./Eigen/src/Core/util/Macros.h ****       abort();
1024:./Eigen/src/Core/util/Macros.h ****     }
1025:./Eigen/src/Core/util/Macros.h ****     }
1026:./Eigen/src/Core/util/Macros.h ****     }
1027:./Eigen/src/Core/util/Macros.h ****     #define eigen_plain_assert(x) \
1028:./Eigen/src/Core/util/Macros.h ****       do { \
1029:./Eigen/src/Core/util/Macros.h ****         if(!Eigen::internal::copy_bool(x)) \
1030:./Eigen/src/Core/util/Macros.h ****           Eigen::internal::assert_fail(EIGEN_MAKESTRING(x), __PRETTY_FUNCTION__, __FILE__, __LINE__
1031:./Eigen/src/Core/util/Macros.h ****       } while(false)
1032:./Eigen/src/Core/util/Macros.h ****   #endif
1033:./Eigen/src/Core/util/Macros.h **** #endif
1034:./Eigen/src/Core/util/Macros.h **** 
1035:./Eigen/src/Core/util/Macros.h **** // eigen_assert can be overridden
1036:./Eigen/src/Core/util/Macros.h **** #ifndef eigen_assert
1037:./Eigen/src/Core/util/Macros.h **** #define eigen_assert(x) eigen_plain_assert(x)
1038:./Eigen/src/Core/util/Macros.h **** #endif
1039:./Eigen/src/Core/util/Macros.h **** 
1040:./Eigen/src/Core/util/Macros.h **** #ifdef EIGEN_INTERNAL_DEBUGGING
1041:./Eigen/src/Core/util/Macros.h **** #define eigen_internal_assert(x) eigen_assert(x)
1042:./Eigen/src/Core/util/Macros.h **** #else
1043:./Eigen/src/Core/util/Macros.h **** #define eigen_internal_assert(x)
1044:./Eigen/src/Core/util/Macros.h **** #endif
1045:./Eigen/src/Core/util/Macros.h **** 
1046:./Eigen/src/Core/util/Macros.h **** #ifdef EIGEN_NO_DEBUG
1047:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ONLY_USED_FOR_DEBUG(x) EIGEN_UNUSED_VARIABLE(x)
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 134


1048:./Eigen/src/Core/util/Macros.h **** #else
1049:./Eigen/src/Core/util/Macros.h **** #define EIGEN_ONLY_USED_FOR_DEBUG(x)
1050:./Eigen/src/Core/util/Macros.h **** #endif
1051:./Eigen/src/Core/util/Macros.h **** 
1052:./Eigen/src/Core/util/Macros.h **** #ifndef EIGEN_NO_DEPRECATED_WARNING
1053:./Eigen/src/Core/util/Macros.h ****   #if EIGEN_COMP_GNUC
1054:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_DEPRECATED __attribute__((deprecated))
1055:./Eigen/src/Core/util/Macros.h ****   #elif EIGEN_COMP_MSVC
1056:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_DEPRECATED __declspec(deprecated)
1057:./Eigen/src/Core/util/Macros.h ****   #else
1058:./Eigen/src/Core/util/Macros.h ****     #define EIGEN_DEPRECATED
1059:./Eigen/src/Core/util/Macros.h ****   #endif
1060:./Eigen/src/Core/util/Macros.h **** #else
1061:./Eigen/src/Core/util/Macros.h ****   #define EIGEN_DEPRECATED
1062:./Eigen/src/Core/util/Macros.h **** #endif
1063:./Eigen/src/Core/util/Macros.h **** 
1064:./Eigen/src/Core/util/Macros.h **** #if EIGEN_COMP_GNUC
1065:./Eigen/src/Core/util/Macros.h **** #define EIGEN_UNUSED __attribute__((unused))
1066:./Eigen/src/Core/util/Macros.h **** #else
1067:./Eigen/src/Core/util/Macros.h **** #define EIGEN_UNUSED
1068:./Eigen/src/Core/util/Macros.h **** #endif
1069:./Eigen/src/Core/util/Macros.h **** 
1070:./Eigen/src/Core/util/Macros.h **** // Suppresses 'unused variable' warnings.
1071:./Eigen/src/Core/util/Macros.h **** namespace Eigen {
1072:./Eigen/src/Core/util/Macros.h ****   namespace internal {
1073:./Eigen/src/Core/util/Macros.h ****     template<typename T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void ignore_unused_variable(const T&
 898              		.loc 14 1073 69 is_stmt 1 view .LVU140
 899              		.loc 14 1073 69 is_stmt 0 view .LVU141
 900              	.LBE379:
 901              	.LBE378:
 902              	.LBE377:
 903              	.LBE376:
 904              	.LBE371:
 905              	.LBE370:
 906              	.LBE369:
 907              	.LBE368:
 908              	.LBB380:
 909              	.LBI380:
 633:./Eigen/src/Core/AssignEvaluator.h ****     : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)
 910              		.loc 9 633 3 is_stmt 1 view .LVU142
 911              	.LBB381:
 912              	.LBB382:
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 913              		.loc 9 634 7 is_stmt 0 view .LVU143
 914 0008 02AB     		add	r3, sp, #8
 915              	.LVL56:
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 916              		.loc 9 634 7 view .LVU144
 917 000a 0393     		str	r3, [sp, #12]
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 918              		.loc 9 634 19 view .LVU145
 919 000c 01AB     		add	r3, sp, #4
 920              	.LVL57:
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 921              		.loc 9 634 19 view .LVU146
 922 000e 0493     		str	r3, [sp, #16]
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 135


 923              		.loc 9 634 31 view .LVU147
 924 0010 07AB     		add	r3, sp, #28
 925              	.LVL58:
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 926              		.loc 9 634 31 view .LVU148
 927 0012 0593     		str	r3, [sp, #20]
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 928              		.loc 9 634 48 view .LVU149
 929 0014 0690     		str	r0, [sp, #24]
 930              	.LVL59:
 634:./Eigen/src/Core/AssignEvaluator.h ****   {
 931              		.loc 9 634 48 view .LVU150
 932              	.LBE382:
 933              	.LBE381:
 934              	.LBE380:
 935              	.LBB383:
 936              	.LBI383:
 525:./Eigen/src/Core/AssignEvaluator.h ****   {
 937              		.loc 9 525 53 is_stmt 1 view .LVU151
 938              	.LBB384:
 528:./Eigen/src/Core/AssignEvaluator.h ****   }
 939              		.loc 9 528 106 is_stmt 0 view .LVU152
 940 0016 03A8     		add	r0, sp, #12
 941              	.LVL60:
 528:./Eigen/src/Core/AssignEvaluator.h ****   }
 942              		.loc 9 528 106 view .LVU153
 943 0018 FFF7FEFF 		bl	_ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_
 944              	.LVL61:
 528:./Eigen/src/Core/AssignEvaluator.h ****   }
 945              		.loc 9 528 106 view .LVU154
 946              	.LBE384:
 947              	.LBE383:
 948              	.LBB385:
 949              	.LBI385:
 273:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
 950              		.loc 10 273 8 is_stmt 1 view .LVU155
 951              	.LBB386:
 952              	.LBB387:
 953              	.LBI387:
 163:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator_base<Derived>
 954              		.loc 10 163 8 view .LVU156
 955              	.LBB388:
 956              	.LBB389:
 957              	.LBI389:
 122:./Eigen/src/Core/CoreEvaluators.h **** private:
 958              		.loc 10 122 41 view .LVU157
 122:./Eigen/src/Core/CoreEvaluators.h **** private:
 959              		.loc 10 122 41 is_stmt 0 view .LVU158
 960              	.LBE389:
 961              	.LBE388:
 962              	.LBE387:
 963              	.LBE386:
 964              	.LBE385:
 965              	.LBB390:
 966              	.LBI390:
 497:./Eigen/src/Core/CoreEvaluators.h ****   : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
 967              		.loc 10 497 8 is_stmt 1 view .LVU159
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 136


 968              	.LBB391:
 969              	.LBB392:
 970              	.LBI392:
 122:./Eigen/src/Core/CoreEvaluators.h **** private:
 971              		.loc 10 122 41 view .LVU160
 122:./Eigen/src/Core/CoreEvaluators.h **** private:
 972              		.loc 10 122 41 is_stmt 0 view .LVU161
 973              	.LBE392:
 974              	.LBE391:
 975              	.LBE390:
 976              	.LBE362:
 977              	.LBE361:
 978              	.LBE360:
 979              	.LBE359:
 980              	.LBE358:
 791:./Eigen/src/Core/PlainObjectBase.h ****     {
 792:./Eigen/src/Core/PlainObjectBase.h ****       // I don't think we need this resize call since the lazyAssign will anyways resize
 793:./Eigen/src/Core/PlainObjectBase.h ****       // and lazyAssign will be called by the assign selector.
 794:./Eigen/src/Core/PlainObjectBase.h ****       //_resize_to_match(other);
 795:./Eigen/src/Core/PlainObjectBase.h ****       // the 'false' below means to enforce lazy evaluation. We don't use lazyAssign() because
 796:./Eigen/src/Core/PlainObjectBase.h ****       // it wouldn't allow to copy a row-vector into a column-vector.
 797:./Eigen/src/Core/PlainObjectBase.h ****       internal::call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scal
 798:./Eigen/src/Core/PlainObjectBase.h ****       return this->derived();
 799:./Eigen/src/Core/PlainObjectBase.h ****     }
 981              		.loc 7 799 5 view .LVU162
 982 001c 2046     		mov	r0, r4
 983 001e 08B0     		add	sp, sp, #32
 984              	.LCFI18:
 985              		.cfi_def_cfa_offset 8
 986              		@ sp needed
 987 0020 10BD     		pop	{r4, pc}
 988              		.loc 7 799 5 view .LVU163
 989              		.cfi_endproc
 990              	.LFE9342:
 991              		.cantunwind
 992              		.fnend
 994              		.section	.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryO
 995              		.align	1
 996              		.weak	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8int
 997              		.syntax unified
 998              		.thumb
 999              		.thumb_func
 1001              	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16
 1002              		.fnstart
 1003              	.LVL62:
 1004              	.LFB9224:
 589:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 1005              		.loc 7 589 25 is_stmt 1 view -0
 1006              		.cfi_startproc
 1007              		@ args = 0, pretend = 0, frame = 0
 1008              		@ frame_needed = 0, uses_anonymous_args = 0
 589:./Eigen/src/Core/PlainObjectBase.h ****       : m_storage()
 1009              		.loc 7 589 25 is_stmt 0 view .LVU165
 1010 0000 38B5     		push	{r3, r4, r5, lr}
 1011              		.save {r3, r4, r5, lr}
 1012              	.LCFI19:
 1013              		.cfi_def_cfa_offset 16
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 137


 1014              		.cfi_offset 3, -16
 1015              		.cfi_offset 4, -12
 1016              		.cfi_offset 5, -8
 1017              		.cfi_offset 14, -4
 1018 0002 0446     		mov	r4, r0
 1019 0004 0D46     		mov	r5, r1
 1020              	.LVL63:
 1021              	.LBB393:
 1022              	.LBB394:
 1023              	.LBI394:
 1024              		.loc 4 485 5 is_stmt 1 view .LVU166
 1025              	.LBB395:
 1026              	.LBI395:
 1027              		.loc 5 681 23 view .LVU167
 1028              		.loc 5 681 23 is_stmt 0 view .LVU168
 1029              	.LBE395:
 1030              	.LBE394:
 1031              	.LBB396:
 1032              	.LBI396:
 211:./Eigen/src/Core/DenseStorage.h ****       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
 1033              		.loc 12 211 23 is_stmt 1 view .LVU169
 1034              	.LBB397:
 1035              	.LBI397:
  49:./Eigen/src/Core/DenseStorage.h ****   {
 1036              		.loc 12 49 3 view .LVU170
  49:./Eigen/src/Core/DenseStorage.h ****   {
 1037              		.loc 12 49 3 is_stmt 0 view .LVU171
 1038              	.LBE397:
 1039              	.LBE396:
 1040              	.LBB398:
 1041              	.LBI398:
 800:./Eigen/src/Core/PlainObjectBase.h **** 
 801:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T0, typename T1>
 802:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 803:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::Size
 804:./Eigen/src/Core/PlainObjectBase.h ****     {
 805:./Eigen/src/Core/PlainObjectBase.h ****       const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value;
 806:./Eigen/src/Core/PlainObjectBase.h ****       const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value;
 807:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT(t0_is_integer_alike &&
 808:./Eigen/src/Core/PlainObjectBase.h ****                           t1_is_integer_alike,
 809:./Eigen/src/Core/PlainObjectBase.h ****                           FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
 810:./Eigen/src/Core/PlainObjectBase.h ****       resize(rows,cols);
 811:./Eigen/src/Core/PlainObjectBase.h ****     }
 812:./Eigen/src/Core/PlainObjectBase.h **** 
 813:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T0, typename T1>
 814:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 815:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Ba
 816:./Eigen/src/Core/PlainObjectBase.h ****     {
 817:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
 818:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[0] = Scalar(val0);
 819:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[1] = Scalar(val1);
 820:./Eigen/src/Core/PlainObjectBase.h ****     }
 821:./Eigen/src/Core/PlainObjectBase.h **** 
 822:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T0, typename T1>
 823:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 824:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,
 825:./Eigen/src/Core/PlainObjectBase.h ****                                     typename internal::enable_if<    (!internal::is_same<Index,Scal
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 138


 826:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && (internal::is_same<T0,Index>::
 827:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && (internal::is_same<T1,Index>::
 828:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && Base::SizeAtCompileTime==2,T1>
 829:./Eigen/src/Core/PlainObjectBase.h ****     {
 830:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
 831:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[0] = Scalar(val0);
 832:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[1] = Scalar(val1);
 833:./Eigen/src/Core/PlainObjectBase.h ****     }
 834:./Eigen/src/Core/PlainObjectBase.h **** 
 835:./Eigen/src/Core/PlainObjectBase.h ****     // The argument is convertible to the Index type and we either have a non 1x1 Matrix, or a dyna
 836:./Eigen/src/Core/PlainObjectBase.h ****     // then the argument is meant to be the size of the object.
 837:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 838:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 839:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompi
 840:./Eigen/src/Core/PlainObjectBase.h ****                                                                               && ((!internal::is_sa
 841:./Eigen/src/Core/PlainObjectBase.h ****     {
 842:./Eigen/src/Core/PlainObjectBase.h ****       // NOTE MSVC 2008 complains if we directly put bool(NumTraits<T>::IsInteger) as the EIGEN_STA
 843:./Eigen/src/Core/PlainObjectBase.h ****       const bool is_integer_alike = internal::is_valid_index_type<T>::value;
 844:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_UNUSED_VARIABLE(is_integer_alike);
 845:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT(is_integer_alike,
 846:./Eigen/src/Core/PlainObjectBase.h ****                           FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
 847:./Eigen/src/Core/PlainObjectBase.h ****       resize(size);
 848:./Eigen/src/Core/PlainObjectBase.h ****     }
 849:./Eigen/src/Core/PlainObjectBase.h **** 
 850:./Eigen/src/Core/PlainObjectBase.h ****     // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coeffic
 851:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 852:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 853:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCo
 854:./Eigen/src/Core/PlainObjectBase.h ****     {
 855:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)
 856:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[0] = val0;
 857:./Eigen/src/Core/PlainObjectBase.h ****     }
 858:./Eigen/src/Core/PlainObjectBase.h **** 
 859:./Eigen/src/Core/PlainObjectBase.h ****     // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coeffic
 860:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 861:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 862:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Index& val0,
 863:./Eigen/src/Core/PlainObjectBase.h ****                                     typename internal::enable_if<    (!internal::is_same<Index,Scal
 864:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && (internal::is_same<Index,T>::v
 865:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && Base::SizeAtCompileTime==1
 866:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && internal::is_convertible<T, Sc
 867:./Eigen/src/Core/PlainObjectBase.h ****     {
 868:./Eigen/src/Core/PlainObjectBase.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)
 869:./Eigen/src/Core/PlainObjectBase.h ****       m_storage.data()[0] = Scalar(val0);
 870:./Eigen/src/Core/PlainObjectBase.h ****     }
 871:./Eigen/src/Core/PlainObjectBase.h **** 
 872:./Eigen/src/Core/PlainObjectBase.h ****     // Initialize a fixed size matrix from a pointer to raw data
 873:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 874:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 875:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Scalar* data){
 876:./Eigen/src/Core/PlainObjectBase.h ****       this->_set_noalias(ConstMapType(data));
 877:./Eigen/src/Core/PlainObjectBase.h ****     }
 878:./Eigen/src/Core/PlainObjectBase.h **** 
 879:./Eigen/src/Core/PlainObjectBase.h ****     // Initialize an arbitrary matrix from a dense expression
 880:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T, typename OtherDerived>
 881:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 882:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 139


 883:./Eigen/src/Core/PlainObjectBase.h ****       this->_set_noalias(other);
 884:./Eigen/src/Core/PlainObjectBase.h ****     }
 885:./Eigen/src/Core/PlainObjectBase.h **** 
 886:./Eigen/src/Core/PlainObjectBase.h ****     // Initialize an arbitrary matrix from an object convertible to the Derived type.
 887:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 888:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 889:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Derived& other){
 890:./Eigen/src/Core/PlainObjectBase.h ****       this->_set_noalias(other);
 891:./Eigen/src/Core/PlainObjectBase.h ****     }
 892:./Eigen/src/Core/PlainObjectBase.h **** 
 893:./Eigen/src/Core/PlainObjectBase.h ****     // Initialize an arbitrary matrix from a generic Eigen expression
 894:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T, typename OtherDerived>
 895:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 896:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other){
 897:./Eigen/src/Core/PlainObjectBase.h ****       this->derived() = other;
 898:./Eigen/src/Core/PlainObjectBase.h ****     }
 899:./Eigen/src/Core/PlainObjectBase.h **** 
 900:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T, typename OtherDerived>
 901:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 902:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other)
 903:./Eigen/src/Core/PlainObjectBase.h ****     {
 904:./Eigen/src/Core/PlainObjectBase.h ****       resize(other.rows(), other.cols());
 905:./Eigen/src/Core/PlainObjectBase.h ****       other.evalTo(this->derived());
 906:./Eigen/src/Core/PlainObjectBase.h ****     }
 907:./Eigen/src/Core/PlainObjectBase.h **** 
 908:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T, typename OtherDerived, int ColsAtCompileTime>
 909:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 910:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
 911:./Eigen/src/Core/PlainObjectBase.h ****     {
 912:./Eigen/src/Core/PlainObjectBase.h ****       this->derived() = r;
 913:./Eigen/src/Core/PlainObjectBase.h ****     }
 914:./Eigen/src/Core/PlainObjectBase.h **** 
 915:./Eigen/src/Core/PlainObjectBase.h ****     // For fixed-size Array<Scalar,...>
 916:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 917:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 918:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Scalar& val0,
 919:./Eigen/src/Core/PlainObjectBase.h ****                                     typename internal::enable_if<    Base::SizeAtCompileTime!=Dynam
 920:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && Base::SizeAtCompileTime!=1
 921:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && internal::is_convertible<T, Sc
 922:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && internal::is_same<typename int
 923:./Eigen/src/Core/PlainObjectBase.h ****     {
 924:./Eigen/src/Core/PlainObjectBase.h ****       Base::setConstant(val0);
 925:./Eigen/src/Core/PlainObjectBase.h ****     }
 926:./Eigen/src/Core/PlainObjectBase.h **** 
 927:./Eigen/src/Core/PlainObjectBase.h ****     // For fixed-size Array<Index,...>
 928:./Eigen/src/Core/PlainObjectBase.h ****     template<typename T>
 929:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 930:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_STRONG_INLINE void _init1(const Index& val0,
 931:./Eigen/src/Core/PlainObjectBase.h ****                                     typename internal::enable_if<    (!internal::is_same<Index,Scal
 932:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && (internal::is_same<Index,T>::v
 933:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && Base::SizeAtCompileTime!=Dynam
 934:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && Base::SizeAtCompileTime!=1
 935:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && internal::is_convertible<T, Sc
 936:./Eigen/src/Core/PlainObjectBase.h ****                                                                   && internal::is_same<typename int
 937:./Eigen/src/Core/PlainObjectBase.h ****     {
 938:./Eigen/src/Core/PlainObjectBase.h ****       Base::setConstant(val0);
 939:./Eigen/src/Core/PlainObjectBase.h ****     }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 140


 940:./Eigen/src/Core/PlainObjectBase.h **** 
 941:./Eigen/src/Core/PlainObjectBase.h ****     template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
 942:./Eigen/src/Core/PlainObjectBase.h ****     friend struct internal::matrix_swap_impl;
 943:./Eigen/src/Core/PlainObjectBase.h **** 
 944:./Eigen/src/Core/PlainObjectBase.h ****   public:
 945:./Eigen/src/Core/PlainObjectBase.h **** 
 946:./Eigen/src/Core/PlainObjectBase.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 947:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal
 948:./Eigen/src/Core/PlainObjectBase.h ****       * \brief Override DenseBase::swap() since for dynamic-sized matrices
 949:./Eigen/src/Core/PlainObjectBase.h ****       * of same type it is enough to swap the data pointers.
 950:./Eigen/src/Core/PlainObjectBase.h ****       */
 951:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 952:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 953:./Eigen/src/Core/PlainObjectBase.h ****     void swap(DenseBase<OtherDerived> & other)
 954:./Eigen/src/Core/PlainObjectBase.h ****     {
 955:./Eigen/src/Core/PlainObjectBase.h ****       enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileT
 956:./Eigen/src/Core/PlainObjectBase.h ****       internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), o
 957:./Eigen/src/Core/PlainObjectBase.h ****     }
 958:./Eigen/src/Core/PlainObjectBase.h **** 
 959:./Eigen/src/Core/PlainObjectBase.h ****     /** \internal
 960:./Eigen/src/Core/PlainObjectBase.h ****       * \brief const version forwarded to DenseBase::swap
 961:./Eigen/src/Core/PlainObjectBase.h ****       */
 962:./Eigen/src/Core/PlainObjectBase.h ****     template<typename OtherDerived>
 963:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 964:./Eigen/src/Core/PlainObjectBase.h ****     void swap(DenseBase<OtherDerived> const & other)
 965:./Eigen/src/Core/PlainObjectBase.h ****     { Base::swap(other.derived()); }
 966:./Eigen/src/Core/PlainObjectBase.h **** 
 967:./Eigen/src/Core/PlainObjectBase.h ****     EIGEN_DEVICE_FUNC
 968:./Eigen/src/Core/PlainObjectBase.h ****     static EIGEN_STRONG_INLINE void _check_template_params()
 1042              		.loc 7 968 37 is_stmt 1 view .LVU172
 1043              		.loc 7 968 37 is_stmt 0 view .LVU173
 1044              	.LBE398:
 1045              	.LBB399:
 1046              	.LBI399:
 354:./Eigen/src/Core/PlainObjectBase.h ****     {
 1047              		.loc 7 354 30 is_stmt 1 view .LVU174
 1048              	.LBB400:
 369:./Eigen/src/Core/PlainObjectBase.h ****     }
 1049              		.loc 7 369 18 is_stmt 0 view .LVU175
 1050 0006 0322     		movs	r2, #3
 1051 0008 1146     		mov	r1, r2
 1052              	.LVL64:
 369:./Eigen/src/Core/PlainObjectBase.h ****     }
 1053              		.loc 7 369 18 view .LVU176
 1054 000a FFF7FEFF 		bl	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii
 1055              	.LVL65:
 369:./Eigen/src/Core/PlainObjectBase.h ****     }
 1056              		.loc 7 369 18 view .LVU177
 1057              	.LBE400:
 1058              	.LBE399:
 594:./Eigen/src/Core/PlainObjectBase.h ****     }
 1059              		.loc 7 594 19 view .LVU178
 1060 000e 2946     		mov	r1, r5
 1061 0010 2046     		mov	r0, r4
 1062 0012 FFF7FEFF 		bl	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryO
 1063              	.LVL66:
 1064              	.LBE393:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 141


 595:./Eigen/src/Core/PlainObjectBase.h **** 
 1065              		.loc 7 595 5 view .LVU179
 1066 0016 2046     		mov	r0, r4
 1067 0018 38BD     		pop	{r3, r4, r5, pc}
 595:./Eigen/src/Core/PlainObjectBase.h **** 
 1068              		.loc 7 595 5 view .LVU180
 1069              		.cfi_endproc
 1070              	.LFE9224:
 1071              		.fnend
 1073              		.weak	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC1INS_14CwiseNullaryOpINS_8int
 1074              		.thumb_set _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC1INS_14CwiseNullaryOpINS
 1075              		.section	.text._Z4testv,"ax",%progbits
 1076              		.align	1
 1077              		.global	_Z4testv
 1078              		.syntax unified
 1079              		.thumb
 1080              		.thumb_func
 1082              	_Z4testv:
 1083              		.fnstart
 1084              	.LFB8591:
   1:HigherLevelApps/HigherLevelApps.c/mpc.cpp **** #include <Eigen/Dense>
   2:HigherLevelApps/HigherLevelApps.c/mpc.cpp **** 
   3:HigherLevelApps/HigherLevelApps.c/mpc.cpp **** int test() {
 1085              		.loc 1 3 12 is_stmt 1 view -0
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 80
 1088              		@ frame_needed = 0, uses_anonymous_args = 0
 1089 0000 00B5     		push	{lr}
 1090              		.save {lr}
 1091              	.LCFI20:
 1092              		.cfi_def_cfa_offset 4
 1093              		.cfi_offset 14, -4
 1094              		.pad #84
 1095 0002 95B0     		sub	sp, sp, #84
 1096              	.LCFI21:
 1097              		.cfi_def_cfa_offset 88
   4:HigherLevelApps/HigherLevelApps.c/mpc.cpp ****     Eigen::Matrix3d m = Eigen::Matrix3d::Random();
 1098              		.loc 1 4 5 view .LVU182
 1099              	.LBB401:
 1100              	.LBI401:
  20:./Eigen/src/Core/Random.h **** };
  21:./Eigen/src/Core/Random.h **** 
  22:./Eigen/src/Core/Random.h **** template<typename Scalar>
  23:./Eigen/src/Core/Random.h **** struct functor_traits<scalar_random_op<Scalar> >
  24:./Eigen/src/Core/Random.h **** { enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };
  25:./Eigen/src/Core/Random.h **** 
  26:./Eigen/src/Core/Random.h **** } // end namespace internal
  27:./Eigen/src/Core/Random.h **** 
  28:./Eigen/src/Core/Random.h **** /** \returns a random matrix expression
  29:./Eigen/src/Core/Random.h ****   *
  30:./Eigen/src/Core/Random.h ****   * Numbers are uniformly spread through their whole definition range for integer types,
  31:./Eigen/src/Core/Random.h ****   * and in the [-1:1] range for floating point scalar types.
  32:./Eigen/src/Core/Random.h ****   * 
  33:./Eigen/src/Core/Random.h ****   * The parameters \a rows and \a cols are the number of rows and of columns of
  34:./Eigen/src/Core/Random.h ****   * the returned matrix. Must be compatible with this MatrixBase type.
  35:./Eigen/src/Core/Random.h ****   *
  36:./Eigen/src/Core/Random.h ****   * \not_reentrant
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 142


  37:./Eigen/src/Core/Random.h ****   * 
  38:./Eigen/src/Core/Random.h ****   * This variant is meant to be used for dynamic-size matrix types. For fixed-size types,
  39:./Eigen/src/Core/Random.h ****   * it is redundant to pass \a rows and \a cols as arguments, so Random() should be used
  40:./Eigen/src/Core/Random.h ****   * instead.
  41:./Eigen/src/Core/Random.h ****   * 
  42:./Eigen/src/Core/Random.h ****   *
  43:./Eigen/src/Core/Random.h ****   * Example: \include MatrixBase_random_int_int.cpp
  44:./Eigen/src/Core/Random.h ****   * Output: \verbinclude MatrixBase_random_int_int.out
  45:./Eigen/src/Core/Random.h ****   *
  46:./Eigen/src/Core/Random.h ****   * This expression has the "evaluate before nesting" flag so that it will be evaluated into
  47:./Eigen/src/Core/Random.h ****   * a temporary matrix whenever it is nested in a larger expression. This prevents unexpected
  48:./Eigen/src/Core/Random.h ****   * behavior with expressions involving random matrices.
  49:./Eigen/src/Core/Random.h ****   * 
  50:./Eigen/src/Core/Random.h ****   * See DenseBase::NullaryExpr(Index, const CustomNullaryOp&) for an example using C++11 random gen
  51:./Eigen/src/Core/Random.h ****   *
  52:./Eigen/src/Core/Random.h ****   * \sa DenseBase::setRandom(), DenseBase::Random(Index), DenseBase::Random()
  53:./Eigen/src/Core/Random.h ****   */
  54:./Eigen/src/Core/Random.h **** template<typename Derived>
  55:./Eigen/src/Core/Random.h **** inline const typename DenseBase<Derived>::RandomReturnType
  56:./Eigen/src/Core/Random.h **** DenseBase<Derived>::Random(Index rows, Index cols)
  57:./Eigen/src/Core/Random.h **** {
  58:./Eigen/src/Core/Random.h ****   return NullaryExpr(rows, cols, internal::scalar_random_op<Scalar>());
  59:./Eigen/src/Core/Random.h **** }
  60:./Eigen/src/Core/Random.h **** 
  61:./Eigen/src/Core/Random.h **** /** \returns a random vector expression
  62:./Eigen/src/Core/Random.h ****   *
  63:./Eigen/src/Core/Random.h ****   * Numbers are uniformly spread through their whole definition range for integer types,
  64:./Eigen/src/Core/Random.h ****   * and in the [-1:1] range for floating point scalar types.
  65:./Eigen/src/Core/Random.h ****   *
  66:./Eigen/src/Core/Random.h ****   * The parameter \a size is the size of the returned vector.
  67:./Eigen/src/Core/Random.h ****   * Must be compatible with this MatrixBase type.
  68:./Eigen/src/Core/Random.h ****   *
  69:./Eigen/src/Core/Random.h ****   * \only_for_vectors
  70:./Eigen/src/Core/Random.h ****   * \not_reentrant
  71:./Eigen/src/Core/Random.h ****   *
  72:./Eigen/src/Core/Random.h ****   * This variant is meant to be used for dynamic-size vector types. For fixed-size types,
  73:./Eigen/src/Core/Random.h ****   * it is redundant to pass \a size as argument, so Random() should be used
  74:./Eigen/src/Core/Random.h ****   * instead.
  75:./Eigen/src/Core/Random.h ****   *
  76:./Eigen/src/Core/Random.h ****   * Example: \include MatrixBase_random_int.cpp
  77:./Eigen/src/Core/Random.h ****   * Output: \verbinclude MatrixBase_random_int.out
  78:./Eigen/src/Core/Random.h ****   *
  79:./Eigen/src/Core/Random.h ****   * This expression has the "evaluate before nesting" flag so that it will be evaluated into
  80:./Eigen/src/Core/Random.h ****   * a temporary vector whenever it is nested in a larger expression. This prevents unexpected
  81:./Eigen/src/Core/Random.h ****   * behavior with expressions involving random matrices.
  82:./Eigen/src/Core/Random.h ****   *
  83:./Eigen/src/Core/Random.h ****   * \sa DenseBase::setRandom(), DenseBase::Random(Index,Index), DenseBase::Random()
  84:./Eigen/src/Core/Random.h ****   */
  85:./Eigen/src/Core/Random.h **** template<typename Derived>
  86:./Eigen/src/Core/Random.h **** inline const typename DenseBase<Derived>::RandomReturnType
  87:./Eigen/src/Core/Random.h **** DenseBase<Derived>::Random(Index size)
  88:./Eigen/src/Core/Random.h **** {
  89:./Eigen/src/Core/Random.h ****   return NullaryExpr(size, internal::scalar_random_op<Scalar>());
  90:./Eigen/src/Core/Random.h **** }
  91:./Eigen/src/Core/Random.h **** 
  92:./Eigen/src/Core/Random.h **** /** \returns a fixed-size random matrix or vector expression
  93:./Eigen/src/Core/Random.h ****   *
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 143


  94:./Eigen/src/Core/Random.h ****   * Numbers are uniformly spread through their whole definition range for integer types,
  95:./Eigen/src/Core/Random.h ****   * and in the [-1:1] range for floating point scalar types.
  96:./Eigen/src/Core/Random.h ****   * 
  97:./Eigen/src/Core/Random.h ****   * This variant is only for fixed-size MatrixBase types. For dynamic-size types, you
  98:./Eigen/src/Core/Random.h ****   * need to use the variants taking size arguments.
  99:./Eigen/src/Core/Random.h ****   *
 100:./Eigen/src/Core/Random.h ****   * Example: \include MatrixBase_random.cpp
 101:./Eigen/src/Core/Random.h ****   * Output: \verbinclude MatrixBase_random.out
 102:./Eigen/src/Core/Random.h ****   *
 103:./Eigen/src/Core/Random.h ****   * This expression has the "evaluate before nesting" flag so that it will be evaluated into
 104:./Eigen/src/Core/Random.h ****   * a temporary matrix whenever it is nested in a larger expression. This prevents unexpected
 105:./Eigen/src/Core/Random.h ****   * behavior with expressions involving random matrices.
 106:./Eigen/src/Core/Random.h ****   * 
 107:./Eigen/src/Core/Random.h ****   * \not_reentrant
 108:./Eigen/src/Core/Random.h ****   *
 109:./Eigen/src/Core/Random.h ****   * \sa DenseBase::setRandom(), DenseBase::Random(Index,Index), DenseBase::Random(Index)
 110:./Eigen/src/Core/Random.h ****   */
 111:./Eigen/src/Core/Random.h **** template<typename Derived>
 112:./Eigen/src/Core/Random.h **** inline const typename DenseBase<Derived>::RandomReturnType
 113:./Eigen/src/Core/Random.h **** DenseBase<Derived>::Random()
 1101              		.loc 6 113 1 view .LVU183
 1102              	.LVL67:
 1103              	.LBB402:
 1104              	.LBB403:
 1105              	.LBI403:
  18:./Eigen/src/Core/Random.h ****   inline const Scalar operator() () const { return random<Scalar>(); }
 1106              		.loc 6 18 3 view .LVU184
  18:./Eigen/src/Core/Random.h ****   inline const Scalar operator() () const { return random<Scalar>(); }
 1107              		.loc 6 18 3 is_stmt 0 view .LVU185
 1108              	.LBE403:
 1109              	.LBB404:
 1110              	.LBI404:
  85:./Eigen/src/Core/CwiseNullaryOp.h **** 
  86:./Eigen/src/Core/CwiseNullaryOp.h ****   protected:
  87:./Eigen/src/Core/CwiseNullaryOp.h ****     const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;
  88:./Eigen/src/Core/CwiseNullaryOp.h ****     const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;
  89:./Eigen/src/Core/CwiseNullaryOp.h ****     const NullaryOp m_functor;
  90:./Eigen/src/Core/CwiseNullaryOp.h **** };
  91:./Eigen/src/Core/CwiseNullaryOp.h **** 
  92:./Eigen/src/Core/CwiseNullaryOp.h **** 
  93:./Eigen/src/Core/CwiseNullaryOp.h **** /** \returns an expression of a matrix defined by a custom functor \a func
  94:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  95:./Eigen/src/Core/CwiseNullaryOp.h ****   * The parameters \a rows and \a cols are the number of rows and of columns of
  96:./Eigen/src/Core/CwiseNullaryOp.h ****   * the returned matrix. Must be compatible with this MatrixBase type.
  97:./Eigen/src/Core/CwiseNullaryOp.h ****   *
  98:./Eigen/src/Core/CwiseNullaryOp.h ****   * This variant is meant to be used for dynamic-size matrix types. For fixed-size types,
  99:./Eigen/src/Core/CwiseNullaryOp.h ****   * it is redundant to pass \a rows and \a cols as arguments, so Zero() should be used
 100:./Eigen/src/Core/CwiseNullaryOp.h ****   * instead.
 101:./Eigen/src/Core/CwiseNullaryOp.h ****   *
 102:./Eigen/src/Core/CwiseNullaryOp.h ****   * The template parameter \a CustomNullaryOp is the type of the functor.
 103:./Eigen/src/Core/CwiseNullaryOp.h ****   *
 104:./Eigen/src/Core/CwiseNullaryOp.h ****   * \sa class CwiseNullaryOp
 105:./Eigen/src/Core/CwiseNullaryOp.h ****   */
 106:./Eigen/src/Core/CwiseNullaryOp.h **** template<typename Derived>
 107:./Eigen/src/Core/CwiseNullaryOp.h **** template<typename CustomNullaryOp>
 108:./Eigen/src/Core/CwiseNullaryOp.h **** EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 109:./Eigen/src/Core/CwiseNullaryOp.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 144


 110:./Eigen/src/Core/CwiseNullaryOp.h **** const CwiseNullaryOp<CustomNullaryOp,typename DenseBase<Derived>::PlainObject>
 111:./Eigen/src/Core/CwiseNullaryOp.h **** #else
 112:./Eigen/src/Core/CwiseNullaryOp.h **** const CwiseNullaryOp<CustomNullaryOp,PlainObject>
 113:./Eigen/src/Core/CwiseNullaryOp.h **** #endif
 114:./Eigen/src/Core/CwiseNullaryOp.h **** DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)
 1111              		.loc 3 114 1 is_stmt 1 view .LVU186
 1112              	.LBB405:
 115:./Eigen/src/Core/CwiseNullaryOp.h **** {
 116:./Eigen/src/Core/CwiseNullaryOp.h ****   return CwiseNullaryOp<CustomNullaryOp, PlainObject>(rows, cols, func);
 1113              		.loc 3 116 71 is_stmt 0 view .LVU187
 1114 0004 13AB     		add	r3, sp, #76
 1115              	.LVL68:
 1116              		.loc 3 116 71 view .LVU188
 1117 0006 0322     		movs	r2, #3
 1118 0008 1146     		mov	r1, r2
 1119 000a 12A8     		add	r0, sp, #72
 1120 000c FFF7FEFF 		bl	_ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE
 1121              	.LVL69:
 1122              		.loc 3 116 71 view .LVU189
 1123              	.LBE405:
 1124              	.LBE404:
 1125              	.LBE402:
 1126              	.LBE401:
 1127              	.LBB406:
 1128              	.LBI406:
 1129              		.file 15 "./Eigen/src/Core/Matrix.h"
   1:./Eigen/src/Core/Matrix.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/Matrix.h **** // for linear algebra.
   3:./Eigen/src/Core/Matrix.h **** //
   4:./Eigen/src/Core/Matrix.h **** // Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/Matrix.h **** // Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/Matrix.h **** //
   7:./Eigen/src/Core/Matrix.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/Matrix.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/Matrix.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/Matrix.h **** 
  11:./Eigen/src/Core/Matrix.h **** #ifndef EIGEN_MATRIX_H
  12:./Eigen/src/Core/Matrix.h **** #define EIGEN_MATRIX_H
  13:./Eigen/src/Core/Matrix.h **** 
  14:./Eigen/src/Core/Matrix.h **** namespace Eigen {
  15:./Eigen/src/Core/Matrix.h **** 
  16:./Eigen/src/Core/Matrix.h **** namespace internal {
  17:./Eigen/src/Core/Matrix.h **** template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
  18:./Eigen/src/Core/Matrix.h **** struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
  19:./Eigen/src/Core/Matrix.h **** {
  20:./Eigen/src/Core/Matrix.h **** private:
  21:./Eigen/src/Core/Matrix.h ****   enum { size = internal::size_at_compile_time<_Rows,_Cols>::ret };
  22:./Eigen/src/Core/Matrix.h ****   typedef typename find_best_packet<_Scalar,size>::type PacketScalar;
  23:./Eigen/src/Core/Matrix.h ****   enum {
  24:./Eigen/src/Core/Matrix.h ****       row_major_bit = _Options&RowMajor ? RowMajorBit : 0,
  25:./Eigen/src/Core/Matrix.h ****       is_dynamic_size_storage = _MaxRows==Dynamic || _MaxCols==Dynamic,
  26:./Eigen/src/Core/Matrix.h ****       max_size = is_dynamic_size_storage ? Dynamic : _MaxRows*_MaxCols,
  27:./Eigen/src/Core/Matrix.h ****       default_alignment = compute_default_alignment<_Scalar,max_size>::value,
  28:./Eigen/src/Core/Matrix.h ****       actual_alignment = ((_Options&DontAlign)==0) ? default_alignment : 0,
  29:./Eigen/src/Core/Matrix.h ****       required_alignment = unpacket_traits<PacketScalar>::alignment,
  30:./Eigen/src/Core/Matrix.h ****       packet_access_bit = (packet_traits<_Scalar>::Vectorizable && (EIGEN_UNALIGNED_VECTORIZE || (a
  31:./Eigen/src/Core/Matrix.h ****     };
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 145


  32:./Eigen/src/Core/Matrix.h **** 
  33:./Eigen/src/Core/Matrix.h **** public:
  34:./Eigen/src/Core/Matrix.h ****   typedef _Scalar Scalar;
  35:./Eigen/src/Core/Matrix.h ****   typedef Dense StorageKind;
  36:./Eigen/src/Core/Matrix.h ****   typedef Eigen::Index StorageIndex;
  37:./Eigen/src/Core/Matrix.h ****   typedef MatrixXpr XprKind;
  38:./Eigen/src/Core/Matrix.h ****   enum {
  39:./Eigen/src/Core/Matrix.h ****     RowsAtCompileTime = _Rows,
  40:./Eigen/src/Core/Matrix.h ****     ColsAtCompileTime = _Cols,
  41:./Eigen/src/Core/Matrix.h ****     MaxRowsAtCompileTime = _MaxRows,
  42:./Eigen/src/Core/Matrix.h ****     MaxColsAtCompileTime = _MaxCols,
  43:./Eigen/src/Core/Matrix.h ****     Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,
  44:./Eigen/src/Core/Matrix.h ****     Options = _Options,
  45:./Eigen/src/Core/Matrix.h ****     InnerStrideAtCompileTime = 1,
  46:./Eigen/src/Core/Matrix.h ****     OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime,
  47:./Eigen/src/Core/Matrix.h **** 
  48:./Eigen/src/Core/Matrix.h ****     // FIXME, the following flag in only used to define NeedsToAlign in PlainObjectBase
  49:./Eigen/src/Core/Matrix.h ****     EvaluatorFlags = LinearAccessBit | DirectAccessBit | packet_access_bit | row_major_bit,
  50:./Eigen/src/Core/Matrix.h ****     Alignment = actual_alignment
  51:./Eigen/src/Core/Matrix.h ****   };
  52:./Eigen/src/Core/Matrix.h **** };
  53:./Eigen/src/Core/Matrix.h **** }
  54:./Eigen/src/Core/Matrix.h **** 
  55:./Eigen/src/Core/Matrix.h **** /** \class Matrix
  56:./Eigen/src/Core/Matrix.h ****   * \ingroup Core_Module
  57:./Eigen/src/Core/Matrix.h ****   *
  58:./Eigen/src/Core/Matrix.h ****   * \brief The matrix class, also used for vectors and row-vectors
  59:./Eigen/src/Core/Matrix.h ****   *
  60:./Eigen/src/Core/Matrix.h ****   * The %Matrix class is the work-horse for all \em dense (\ref dense "note") matrices and vectors 
  61:./Eigen/src/Core/Matrix.h ****   * Vectors are matrices with one column, and row-vectors are matrices with one row.
  62:./Eigen/src/Core/Matrix.h ****   *
  63:./Eigen/src/Core/Matrix.h ****   * The %Matrix class encompasses \em both fixed-size and dynamic-size objects (\ref fixedsize "not
  64:./Eigen/src/Core/Matrix.h ****   *
  65:./Eigen/src/Core/Matrix.h ****   * The first three template parameters are required:
  66:./Eigen/src/Core/Matrix.h ****   * \tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.
  67:./Eigen/src/Core/Matrix.h ****   *                 User defined scalar types are supported as well (see \ref user_defined_scalars 
  68:./Eigen/src/Core/Matrix.h ****   * \tparam _Rows Number of rows, or \b Dynamic
  69:./Eigen/src/Core/Matrix.h ****   * \tparam _Cols Number of columns, or \b Dynamic
  70:./Eigen/src/Core/Matrix.h ****   *
  71:./Eigen/src/Core/Matrix.h ****   * The remaining template parameters are optional -- in most cases you don't have to worry about t
  72:./Eigen/src/Core/Matrix.h ****   * \tparam _Options A combination of either \b #RowMajor or \b #ColMajor, and of either
  73:./Eigen/src/Core/Matrix.h ****   *                 \b #AutoAlign or \b #DontAlign.
  74:./Eigen/src/Core/Matrix.h ****   *                 The former controls \ref TopicStorageOrders "storage order", and defaults to co
  75:./Eigen/src/Core/Matrix.h ****   *                 for vectorization. It defaults to aligning matrices except for fixed sizes that
  76:./Eigen/src/Core/Matrix.h ****   * \tparam _MaxRows Maximum number of rows. Defaults to \a _Rows (\ref maxrows "note").
  77:./Eigen/src/Core/Matrix.h ****   * \tparam _MaxCols Maximum number of columns. Defaults to \a _Cols (\ref maxrows "note").
  78:./Eigen/src/Core/Matrix.h ****   *
  79:./Eigen/src/Core/Matrix.h ****   * Eigen provides a number of typedefs covering the usual cases. Here are some examples:
  80:./Eigen/src/Core/Matrix.h ****   *
  81:./Eigen/src/Core/Matrix.h ****   * \li \c Matrix2d is a 2x2 square matrix of doubles (\c Matrix<double, 2, 2>)
  82:./Eigen/src/Core/Matrix.h ****   * \li \c Vector4f is a vector of 4 floats (\c Matrix<float, 4, 1>)
  83:./Eigen/src/Core/Matrix.h ****   * \li \c RowVector3i is a row-vector of 3 ints (\c Matrix<int, 1, 3>)
  84:./Eigen/src/Core/Matrix.h ****   *
  85:./Eigen/src/Core/Matrix.h ****   * \li \c MatrixXf is a dynamic-size matrix of floats (\c Matrix<float, Dynamic, Dynamic>)
  86:./Eigen/src/Core/Matrix.h ****   * \li \c VectorXf is a dynamic-size vector of floats (\c Matrix<float, Dynamic, 1>)
  87:./Eigen/src/Core/Matrix.h ****   *
  88:./Eigen/src/Core/Matrix.h ****   * \li \c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\c Matrix<float, 2,
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 146


  89:./Eigen/src/Core/Matrix.h ****   * \li \c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\c Matrix<double, D
  90:./Eigen/src/Core/Matrix.h ****   *
  91:./Eigen/src/Core/Matrix.h ****   * See \link matrixtypedefs this page \endlink for a complete list of predefined \em %Matrix and \
  92:./Eigen/src/Core/Matrix.h ****   *
  93:./Eigen/src/Core/Matrix.h ****   * You can access elements of vectors and matrices using normal subscripting:
  94:./Eigen/src/Core/Matrix.h ****   *
  95:./Eigen/src/Core/Matrix.h ****   * \code
  96:./Eigen/src/Core/Matrix.h ****   * Eigen::VectorXd v(10);
  97:./Eigen/src/Core/Matrix.h ****   * v[0] = 0.1;
  98:./Eigen/src/Core/Matrix.h ****   * v[1] = 0.2;
  99:./Eigen/src/Core/Matrix.h ****   * v(0) = 0.3;
 100:./Eigen/src/Core/Matrix.h ****   * v(1) = 0.4;
 101:./Eigen/src/Core/Matrix.h ****   *
 102:./Eigen/src/Core/Matrix.h ****   * Eigen::MatrixXi m(10, 10);
 103:./Eigen/src/Core/Matrix.h ****   * m(0, 1) = 1;
 104:./Eigen/src/Core/Matrix.h ****   * m(0, 2) = 2;
 105:./Eigen/src/Core/Matrix.h ****   * m(0, 3) = 3;
 106:./Eigen/src/Core/Matrix.h ****   * \endcode
 107:./Eigen/src/Core/Matrix.h ****   *
 108:./Eigen/src/Core/Matrix.h ****   * This class can be extended with the help of the plugin mechanism described on the page
 109:./Eigen/src/Core/Matrix.h ****   * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_MATRIX_PLUGIN.
 110:./Eigen/src/Core/Matrix.h ****   *
 111:./Eigen/src/Core/Matrix.h ****   * <i><b>Some notes:</b></i>
 112:./Eigen/src/Core/Matrix.h ****   *
 113:./Eigen/src/Core/Matrix.h ****   * <dl>
 114:./Eigen/src/Core/Matrix.h ****   * <dt><b>\anchor dense Dense versus sparse:</b></dt>
 115:./Eigen/src/Core/Matrix.h ****   * <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and 
 116:./Eigen/src/Core/Matrix.h ****   *
 117:./Eigen/src/Core/Matrix.h ****   * Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are sto
 118:./Eigen/src/Core/Matrix.h ****   * This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonze
 119:./Eigen/src/Core/Matrix.h ****   *
 120:./Eigen/src/Core/Matrix.h ****   * <dt><b>\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>
 121:./Eigen/src/Core/Matrix.h ****   * <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this c
 122:./Eigen/src/Core/Matrix.h ****   * of coefficients as a fixed-size array, as a class member. This makes sense for very small matri
 123:./Eigen/src/Core/Matrix.h ****   * to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their 
 124:./Eigen/src/Core/Matrix.h ****   *
 125:./Eigen/src/Core/Matrix.h ****   * Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-tim
 126:./Eigen/src/Core/Matrix.h ****   * variables, and the array of coefficients is allocated dynamically on the heap.
 127:./Eigen/src/Core/Matrix.h ****   *
 128:./Eigen/src/Core/Matrix.h ****   * Note that \em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynami
 129:./Eigen/src/Core/Matrix.h ****   * If you want this behavior, see the Sparse module.</dd>
 130:./Eigen/src/Core/Matrix.h ****   *
 131:./Eigen/src/Core/Matrix.h ****   * <dt><b>\anchor maxrows _MaxRows and _MaxCols:</b></dt>
 132:./Eigen/src/Core/Matrix.h ****   * <dd>In most cases, one just leaves these parameters to the default values.
 133:./Eigen/src/Core/Matrix.h ****   * These parameters mean the maximum size of rows and columns that the matrix may have. They are u
 134:./Eigen/src/Core/Matrix.h ****   * when the exact numbers of rows and columns are not known are compile-time, but it is known at c
 135:./Eigen/src/Core/Matrix.h ****   * exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices
 136:./Eigen/src/Core/Matrix.h ****   * are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>
 137:./Eigen/src/Core/Matrix.h ****   * </dl>
 138:./Eigen/src/Core/Matrix.h ****   *
 139:./Eigen/src/Core/Matrix.h ****   * <i><b>ABI and storage layout</b></i>
 140:./Eigen/src/Core/Matrix.h ****   *
 141:./Eigen/src/Core/Matrix.h ****   * The table below summarizes the ABI of some possible Matrix instances which is fixed thorough th
 142:./Eigen/src/Core/Matrix.h ****   * <table  class="manual">
 143:./Eigen/src/Core/Matrix.h ****   * <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>
 144:./Eigen/src/Core/Matrix.h ****   * <tr><td>\code Matrix<T,Dynamic,Dynamic> \endcode</td><td>\code
 145:./Eigen/src/Core/Matrix.h ****   * struct {
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 147


 146:./Eigen/src/Core/Matrix.h ****   *   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0
 147:./Eigen/src/Core/Matrix.h ****   *   Eigen::Index rows, cols;
 148:./Eigen/src/Core/Matrix.h ****   *  };
 149:./Eigen/src/Core/Matrix.h ****   * \endcode</td></tr>
 150:./Eigen/src/Core/Matrix.h ****   * <tr class="alt"><td>\code
 151:./Eigen/src/Core/Matrix.h ****   * Matrix<T,Dynamic,1>
 152:./Eigen/src/Core/Matrix.h ****   * Matrix<T,1,Dynamic> \endcode</td><td>\code
 153:./Eigen/src/Core/Matrix.h ****   * struct {
 154:./Eigen/src/Core/Matrix.h ****   *   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0
 155:./Eigen/src/Core/Matrix.h ****   *   Eigen::Index size;
 156:./Eigen/src/Core/Matrix.h ****   *  };
 157:./Eigen/src/Core/Matrix.h ****   * \endcode</td></tr>
 158:./Eigen/src/Core/Matrix.h ****   * <tr><td>\code Matrix<T,Rows,Cols> \endcode</td><td>\code
 159:./Eigen/src/Core/Matrix.h ****   * struct {
 160:./Eigen/src/Core/Matrix.h ****   *   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0
 161:./Eigen/src/Core/Matrix.h ****   *  };
 162:./Eigen/src/Core/Matrix.h ****   * \endcode</td></tr>
 163:./Eigen/src/Core/Matrix.h ****   * <tr class="alt"><td>\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \endcode</td><td>\code
 164:./Eigen/src/Core/Matrix.h ****   * struct {
 165:./Eigen/src/Core/Matrix.h ****   *   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0
 166:./Eigen/src/Core/Matrix.h ****   *   Eigen::Index rows, cols;
 167:./Eigen/src/Core/Matrix.h ****   *  };
 168:./Eigen/src/Core/Matrix.h ****   * \endcode</td></tr>
 169:./Eigen/src/Core/Matrix.h ****   * </table>
 170:./Eigen/src/Core/Matrix.h ****   * Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defi
 171:./Eigen/src/Core/Matrix.h ****   * smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.
 172:./Eigen/src/Core/Matrix.h ****   *
 173:./Eigen/src/Core/Matrix.h ****   * \see MatrixBase for the majority of the API methods for matrices, \ref TopicClassHierarchy,
 174:./Eigen/src/Core/Matrix.h ****   * \ref TopicStorageOrders
 175:./Eigen/src/Core/Matrix.h ****   */
 176:./Eigen/src/Core/Matrix.h **** 
 177:./Eigen/src/Core/Matrix.h **** template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
 178:./Eigen/src/Core/Matrix.h **** class Matrix
 179:./Eigen/src/Core/Matrix.h ****   : public PlainObjectBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
 180:./Eigen/src/Core/Matrix.h **** {
 181:./Eigen/src/Core/Matrix.h ****   public:
 182:./Eigen/src/Core/Matrix.h **** 
 183:./Eigen/src/Core/Matrix.h ****     /** \brief Base class typedef.
 184:./Eigen/src/Core/Matrix.h ****       * \sa PlainObjectBase
 185:./Eigen/src/Core/Matrix.h ****       */
 186:./Eigen/src/Core/Matrix.h ****     typedef PlainObjectBase<Matrix> Base;
 187:./Eigen/src/Core/Matrix.h **** 
 188:./Eigen/src/Core/Matrix.h ****     enum { Options = _Options };
 189:./Eigen/src/Core/Matrix.h **** 
 190:./Eigen/src/Core/Matrix.h ****     EIGEN_DENSE_PUBLIC_INTERFACE(Matrix)
 191:./Eigen/src/Core/Matrix.h **** 
 192:./Eigen/src/Core/Matrix.h ****     typedef typename Base::PlainObject PlainObject;
 193:./Eigen/src/Core/Matrix.h **** 
 194:./Eigen/src/Core/Matrix.h ****     using Base::base;
 195:./Eigen/src/Core/Matrix.h ****     using Base::coeffRef;
 196:./Eigen/src/Core/Matrix.h **** 
 197:./Eigen/src/Core/Matrix.h ****     /**
 198:./Eigen/src/Core/Matrix.h ****       * \brief Assigns matrices to each other.
 199:./Eigen/src/Core/Matrix.h ****       *
 200:./Eigen/src/Core/Matrix.h ****       * \note This is a special case of the templated operator=. Its purpose is
 201:./Eigen/src/Core/Matrix.h ****       * to prevent a default operator= from hiding the templated operator=.
 202:./Eigen/src/Core/Matrix.h ****       *
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 148


 203:./Eigen/src/Core/Matrix.h ****       * \callgraph
 204:./Eigen/src/Core/Matrix.h ****       */
 205:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 206:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)
 207:./Eigen/src/Core/Matrix.h ****     {
 208:./Eigen/src/Core/Matrix.h ****       return Base::_set(other);
 209:./Eigen/src/Core/Matrix.h ****     }
 210:./Eigen/src/Core/Matrix.h **** 
 211:./Eigen/src/Core/Matrix.h ****     /** \internal
 212:./Eigen/src/Core/Matrix.h ****       * \brief Copies the value of the expression \a other into \c *this with automatic resizing.
 213:./Eigen/src/Core/Matrix.h ****       *
 214:./Eigen/src/Core/Matrix.h ****       * *this might be resized to match the dimensions of \a other. If *this was a null matrix (not
 215:./Eigen/src/Core/Matrix.h ****       * it will be initialized.
 216:./Eigen/src/Core/Matrix.h ****       *
 217:./Eigen/src/Core/Matrix.h ****       * Note that copying a row-vector into a vector (and conversely) is allowed.
 218:./Eigen/src/Core/Matrix.h ****       * The resizing, if any, is then done in the appropriate way so that row-vectors
 219:./Eigen/src/Core/Matrix.h ****       * remain row-vectors and vectors remain vectors.
 220:./Eigen/src/Core/Matrix.h ****       */
 221:./Eigen/src/Core/Matrix.h ****     template<typename OtherDerived>
 222:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 223:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other)
 224:./Eigen/src/Core/Matrix.h ****     {
 225:./Eigen/src/Core/Matrix.h ****       return Base::_set(other);
 226:./Eigen/src/Core/Matrix.h ****     }
 227:./Eigen/src/Core/Matrix.h **** 
 228:./Eigen/src/Core/Matrix.h ****     /* Here, doxygen failed to copy the brief information when using \copydoc */
 229:./Eigen/src/Core/Matrix.h **** 
 230:./Eigen/src/Core/Matrix.h ****     /**
 231:./Eigen/src/Core/Matrix.h ****       * \brief Copies the generic expression \a other into *this.
 232:./Eigen/src/Core/Matrix.h ****       * \copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)
 233:./Eigen/src/Core/Matrix.h ****       */
 234:./Eigen/src/Core/Matrix.h ****     template<typename OtherDerived>
 235:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 236:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)
 237:./Eigen/src/Core/Matrix.h ****     {
 238:./Eigen/src/Core/Matrix.h ****       return Base::operator=(other);
 239:./Eigen/src/Core/Matrix.h ****     }
 240:./Eigen/src/Core/Matrix.h **** 
 241:./Eigen/src/Core/Matrix.h ****     template<typename OtherDerived>
 242:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 243:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)
 244:./Eigen/src/Core/Matrix.h ****     {
 245:./Eigen/src/Core/Matrix.h ****       return Base::operator=(func);
 246:./Eigen/src/Core/Matrix.h ****     }
 247:./Eigen/src/Core/Matrix.h **** 
 248:./Eigen/src/Core/Matrix.h ****     /** \brief Default constructor.
 249:./Eigen/src/Core/Matrix.h ****       *
 250:./Eigen/src/Core/Matrix.h ****       * For fixed-size matrices, does nothing.
 251:./Eigen/src/Core/Matrix.h ****       *
 252:./Eigen/src/Core/Matrix.h ****       * For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. 
 253:./Eigen/src/Core/Matrix.h ****       * is called a null matrix. This constructor is the unique way to create null matrices: resizi
 254:./Eigen/src/Core/Matrix.h ****       * a matrix to 0 is not supported.
 255:./Eigen/src/Core/Matrix.h ****       *
 256:./Eigen/src/Core/Matrix.h ****       * \sa resize(Index,Index)
 257:./Eigen/src/Core/Matrix.h ****       */
 258:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 259:./Eigen/src/Core/Matrix.h ****     Matrix() : Base()
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 149


 260:./Eigen/src/Core/Matrix.h ****     {
 261:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 262:./Eigen/src/Core/Matrix.h ****       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 263:./Eigen/src/Core/Matrix.h ****     }
 264:./Eigen/src/Core/Matrix.h **** 
 265:./Eigen/src/Core/Matrix.h ****     // FIXME is it still needed
 266:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 267:./Eigen/src/Core/Matrix.h ****     explicit Matrix(internal::constructor_without_unaligned_array_assert)
 268:./Eigen/src/Core/Matrix.h ****       : Base(internal::constructor_without_unaligned_array_assert())
 269:./Eigen/src/Core/Matrix.h ****     { Base::_check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED }
 270:./Eigen/src/Core/Matrix.h **** 
 271:./Eigen/src/Core/Matrix.h **** #if EIGEN_HAS_RVALUE_REFERENCES
 272:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 273:./Eigen/src/Core/Matrix.h ****     Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)
 274:./Eigen/src/Core/Matrix.h ****       : Base(std::move(other))
 275:./Eigen/src/Core/Matrix.h ****     {
 276:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 277:./Eigen/src/Core/Matrix.h ****     }
 278:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 279:./Eigen/src/Core/Matrix.h ****     Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::va
 280:./Eigen/src/Core/Matrix.h ****     {
 281:./Eigen/src/Core/Matrix.h ****       Base::operator=(std::move(other));
 282:./Eigen/src/Core/Matrix.h ****       return *this;
 283:./Eigen/src/Core/Matrix.h ****     }
 284:./Eigen/src/Core/Matrix.h **** #endif
 285:./Eigen/src/Core/Matrix.h **** 
 286:./Eigen/src/Core/Matrix.h **** #if EIGEN_HAS_CXX11
 287:./Eigen/src/Core/Matrix.h ****     /** \copydoc PlainObjectBase(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const
 288:./Eigen/src/Core/Matrix.h ****      *
 289:./Eigen/src/Core/Matrix.h ****      * Example: \include Matrix_variadic_ctor_cxx11.cpp
 290:./Eigen/src/Core/Matrix.h ****      * Output: \verbinclude Matrix_variadic_ctor_cxx11.out
 291:./Eigen/src/Core/Matrix.h ****      *
 292:./Eigen/src/Core/Matrix.h ****      * \sa Matrix(const std::initializer_list<std::initializer_list<Scalar>>&)
 293:./Eigen/src/Core/Matrix.h ****      */
 294:./Eigen/src/Core/Matrix.h ****     template <typename... ArgTypes>
 295:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 296:./Eigen/src/Core/Matrix.h ****     Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&
 297:./Eigen/src/Core/Matrix.h ****       : Base(a0, a1, a2, a3, args...) {}
 298:./Eigen/src/Core/Matrix.h **** 
 299:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs a Matrix and initializes it from the coefficients given as initializer-li
 300:./Eigen/src/Core/Matrix.h ****       *
 301:./Eigen/src/Core/Matrix.h ****       * In the general case, the constructor takes a list of rows, each row being represented as a 
 302:./Eigen/src/Core/Matrix.h ****       *
 303:./Eigen/src/Core/Matrix.h ****       * Example: \include Matrix_initializer_list_23_cxx11.cpp
 304:./Eigen/src/Core/Matrix.h ****       * Output: \verbinclude Matrix_initializer_list_23_cxx11.out
 305:./Eigen/src/Core/Matrix.h ****       *
 306:./Eigen/src/Core/Matrix.h ****       * Each of the inner initializer lists must contain the exact same number of elements, otherwi
 307:./Eigen/src/Core/Matrix.h ****       *
 308:./Eigen/src/Core/Matrix.h ****       * In the case of a compile-time column vector, implicit transposition from a single row is al
 309:./Eigen/src/Core/Matrix.h ****       * Therefore <code>VectorXd{{1,2,3,4,5}}</code> is legal and the more verbose syntax
 310:./Eigen/src/Core/Matrix.h ****       * <code>RowVectorXd{{1},{2},{3},{4},{5}}</code> can be avoided:
 311:./Eigen/src/Core/Matrix.h ****       *
 312:./Eigen/src/Core/Matrix.h ****       * Example: \include Matrix_initializer_list_vector_cxx11.cpp
 313:./Eigen/src/Core/Matrix.h ****       * Output: \verbinclude Matrix_initializer_list_vector_cxx11.out
 314:./Eigen/src/Core/Matrix.h ****       *
 315:./Eigen/src/Core/Matrix.h ****       * In the case of fixed-sized matrices, the initializer list sizes must exactly match the matr
 316:./Eigen/src/Core/Matrix.h ****       * and implicit transposition is allowed for compile-time vectors only.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 150


 317:./Eigen/src/Core/Matrix.h ****       *
 318:./Eigen/src/Core/Matrix.h ****       * \sa Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const A
 319:./Eigen/src/Core/Matrix.h ****       */
 320:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 321:./Eigen/src/Core/Matrix.h ****     explicit EIGEN_STRONG_INLINE Matrix(const std::initializer_list<std::initializer_list<Scalar>>&
 322:./Eigen/src/Core/Matrix.h **** #endif // end EIGEN_HAS_CXX11
 323:./Eigen/src/Core/Matrix.h **** 
 324:./Eigen/src/Core/Matrix.h **** #ifndef EIGEN_PARSED_BY_DOXYGEN
 325:./Eigen/src/Core/Matrix.h **** 
 326:./Eigen/src/Core/Matrix.h ****     // This constructor is for both 1x1 matrices and dynamic vectors
 327:./Eigen/src/Core/Matrix.h ****     template<typename T>
 328:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 329:./Eigen/src/Core/Matrix.h ****     explicit Matrix(const T& x)
 330:./Eigen/src/Core/Matrix.h ****     {
 331:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 332:./Eigen/src/Core/Matrix.h ****       Base::template _init1<T>(x);
 333:./Eigen/src/Core/Matrix.h ****     }
 334:./Eigen/src/Core/Matrix.h **** 
 335:./Eigen/src/Core/Matrix.h ****     template<typename T0, typename T1>
 336:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 337:./Eigen/src/Core/Matrix.h ****     Matrix(const T0& x, const T1& y)
 338:./Eigen/src/Core/Matrix.h ****     {
 339:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 340:./Eigen/src/Core/Matrix.h ****       Base::template _init2<T0,T1>(x, y);
 341:./Eigen/src/Core/Matrix.h ****     }
 342:./Eigen/src/Core/Matrix.h **** 
 343:./Eigen/src/Core/Matrix.h **** 
 344:./Eigen/src/Core/Matrix.h **** #else
 345:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs a fixed-sized matrix initialized with coefficients starting at \a data */
 346:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 347:./Eigen/src/Core/Matrix.h ****     explicit Matrix(const Scalar *data);
 348:./Eigen/src/Core/Matrix.h **** 
 349:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs a vector or row-vector with given dimension. \only_for_vectors
 350:./Eigen/src/Core/Matrix.h ****       *
 351:./Eigen/src/Core/Matrix.h ****       * This is useful for dynamic-size vectors. For fixed-size vectors,
 352:./Eigen/src/Core/Matrix.h ****       * it is redundant to pass these parameters, so one should use the default constructor
 353:./Eigen/src/Core/Matrix.h ****       * Matrix() instead.
 354:./Eigen/src/Core/Matrix.h ****       *
 355:./Eigen/src/Core/Matrix.h ****       * \warning This constructor is disabled for fixed-size \c 1x1 matrices. For instance,
 356:./Eigen/src/Core/Matrix.h ****       * calling Matrix<double,1,1>(1) will call the initialization constructor: Matrix(const Scalar
 357:./Eigen/src/Core/Matrix.h ****       * For fixed-size \c 1x1 matrices it is therefore recommended to use the default
 358:./Eigen/src/Core/Matrix.h ****       * constructor Matrix() instead, especially when using one of the non standard
 359:./Eigen/src/Core/Matrix.h ****       * \c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\c NAN} macros (see \ref TopicPreprocessorDirectives)
 360:./Eigen/src/Core/Matrix.h ****       */
 361:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE explicit Matrix(Index dim);
 362:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs an initialized 1x1 matrix with the given coefficient
 363:./Eigen/src/Core/Matrix.h ****       * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
 364:./Eigen/src/Core/Matrix.h ****     Matrix(const Scalar& x);
 365:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs an uninitialized matrix with \a rows rows and \a cols columns.
 366:./Eigen/src/Core/Matrix.h ****       *
 367:./Eigen/src/Core/Matrix.h ****       * This is useful for dynamic-size matrices. For fixed-size matrices,
 368:./Eigen/src/Core/Matrix.h ****       * it is redundant to pass these parameters, so one should use the default constructor
 369:./Eigen/src/Core/Matrix.h ****       * Matrix() instead.
 370:./Eigen/src/Core/Matrix.h ****       *
 371:./Eigen/src/Core/Matrix.h ****       * \warning This constructor is disabled for fixed-size \c 1x2 and \c 2x1 vectors. For instanc
 372:./Eigen/src/Core/Matrix.h ****       * calling Matrix2f(2,1) will call the initialization constructor: Matrix(const Scalar& x, con
 373:./Eigen/src/Core/Matrix.h ****       * For fixed-size \c 1x2 or \c 2x1 vectors it is therefore recommended to use the default
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 151


 374:./Eigen/src/Core/Matrix.h ****       * constructor Matrix() instead, especially when using one of the non standard
 375:./Eigen/src/Core/Matrix.h ****       * \c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\c NAN} macros (see \ref TopicPreprocessorDirectives)
 376:./Eigen/src/Core/Matrix.h ****       */
 377:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 378:./Eigen/src/Core/Matrix.h ****     Matrix(Index rows, Index cols);
 379:./Eigen/src/Core/Matrix.h **** 
 380:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs an initialized 2D vector with given coefficients
 381:./Eigen/src/Core/Matrix.h ****       * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
 382:./Eigen/src/Core/Matrix.h ****     Matrix(const Scalar& x, const Scalar& y);
 383:./Eigen/src/Core/Matrix.h ****     #endif  // end EIGEN_PARSED_BY_DOXYGEN
 384:./Eigen/src/Core/Matrix.h **** 
 385:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs an initialized 3D vector with given coefficients
 386:./Eigen/src/Core/Matrix.h ****       * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
 387:./Eigen/src/Core/Matrix.h ****       */
 388:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 389:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
 390:./Eigen/src/Core/Matrix.h ****     {
 391:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 392:./Eigen/src/Core/Matrix.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
 393:./Eigen/src/Core/Matrix.h ****       m_storage.data()[0] = x;
 394:./Eigen/src/Core/Matrix.h ****       m_storage.data()[1] = y;
 395:./Eigen/src/Core/Matrix.h ****       m_storage.data()[2] = z;
 396:./Eigen/src/Core/Matrix.h ****     }
 397:./Eigen/src/Core/Matrix.h ****     /** \brief Constructs an initialized 4D vector with given coefficients
 398:./Eigen/src/Core/Matrix.h ****       * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
 399:./Eigen/src/Core/Matrix.h ****       */
 400:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 401:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
 402:./Eigen/src/Core/Matrix.h ****     {
 403:./Eigen/src/Core/Matrix.h ****       Base::_check_template_params();
 404:./Eigen/src/Core/Matrix.h ****       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
 405:./Eigen/src/Core/Matrix.h ****       m_storage.data()[0] = x;
 406:./Eigen/src/Core/Matrix.h ****       m_storage.data()[1] = y;
 407:./Eigen/src/Core/Matrix.h ****       m_storage.data()[2] = z;
 408:./Eigen/src/Core/Matrix.h ****       m_storage.data()[3] = w;
 409:./Eigen/src/Core/Matrix.h ****     }
 410:./Eigen/src/Core/Matrix.h **** 
 411:./Eigen/src/Core/Matrix.h **** 
 412:./Eigen/src/Core/Matrix.h ****     /** \brief Copy constructor */
 413:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 414:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)
 415:./Eigen/src/Core/Matrix.h ****     { }
 416:./Eigen/src/Core/Matrix.h **** 
 417:./Eigen/src/Core/Matrix.h ****     /** \brief Copy constructor for generic expressions.
 418:./Eigen/src/Core/Matrix.h ****       * \sa MatrixBase::operator=(const EigenBase<OtherDerived>&)
 419:./Eigen/src/Core/Matrix.h ****       */
 420:./Eigen/src/Core/Matrix.h ****     template<typename OtherDerived>
 421:./Eigen/src/Core/Matrix.h ****     EIGEN_DEVICE_FUNC
 422:./Eigen/src/Core/Matrix.h ****     EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)
 1130              		.loc 15 422 25 is_stmt 1 view .LVU190
 1131              	.LBB407:
 1132              	.LBB408:
 1133              	.LBB409:
 1134              	.LBI409:
 1135              		.file 16 "./Eigen/src/Core/EigenBase.h"
   1:./Eigen/src/Core/EigenBase.h **** // This file is part of Eigen, a lightweight C++ template library
   2:./Eigen/src/Core/EigenBase.h **** // for linear algebra.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 152


   3:./Eigen/src/Core/EigenBase.h **** //
   4:./Eigen/src/Core/EigenBase.h **** // Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>
   5:./Eigen/src/Core/EigenBase.h **** // Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>
   6:./Eigen/src/Core/EigenBase.h **** //
   7:./Eigen/src/Core/EigenBase.h **** // This Source Code Form is subject to the terms of the Mozilla
   8:./Eigen/src/Core/EigenBase.h **** // Public License v. 2.0. If a copy of the MPL was not distributed
   9:./Eigen/src/Core/EigenBase.h **** // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
  10:./Eigen/src/Core/EigenBase.h **** 
  11:./Eigen/src/Core/EigenBase.h **** #ifndef EIGEN_EIGENBASE_H
  12:./Eigen/src/Core/EigenBase.h **** #define EIGEN_EIGENBASE_H
  13:./Eigen/src/Core/EigenBase.h **** 
  14:./Eigen/src/Core/EigenBase.h **** namespace Eigen {
  15:./Eigen/src/Core/EigenBase.h **** 
  16:./Eigen/src/Core/EigenBase.h **** /** \class EigenBase
  17:./Eigen/src/Core/EigenBase.h ****   * \ingroup Core_Module
  18:./Eigen/src/Core/EigenBase.h ****   *
  19:./Eigen/src/Core/EigenBase.h ****   * Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor 
  20:./Eigen/src/Core/EigenBase.h ****   *
  21:./Eigen/src/Core/EigenBase.h ****   * In other words, an EigenBase object is an object that can be copied into a MatrixBase.
  22:./Eigen/src/Core/EigenBase.h ****   *
  23:./Eigen/src/Core/EigenBase.h ****   * Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal 
  24:./Eigen/src/Core/EigenBase.h ****   *
  25:./Eigen/src/Core/EigenBase.h ****   * Notice that this class is trivial, it is only used to disambiguate overloaded functions.
  26:./Eigen/src/Core/EigenBase.h ****   *
  27:./Eigen/src/Core/EigenBase.h ****   * \sa \blank \ref TopicClassHierarchy
  28:./Eigen/src/Core/EigenBase.h ****   */
  29:./Eigen/src/Core/EigenBase.h **** template<typename Derived> struct EigenBase
  30:./Eigen/src/Core/EigenBase.h **** {
  31:./Eigen/src/Core/EigenBase.h **** //   typedef typename internal::plain_matrix_type<Derived>::type PlainObject;
  32:./Eigen/src/Core/EigenBase.h **** 
  33:./Eigen/src/Core/EigenBase.h ****   /** \brief The interface type of indices
  34:./Eigen/src/Core/EigenBase.h ****     * \details To change this, \c \#define the preprocessor symbol \c EIGEN_DEFAULT_DENSE_INDEX_TYP
  35:./Eigen/src/Core/EigenBase.h ****     * \sa StorageIndex, \ref TopicPreprocessorDirectives.
  36:./Eigen/src/Core/EigenBase.h ****     * DEPRECATED: Since Eigen 3.3, its usage is deprecated. Use Eigen::Index instead.
  37:./Eigen/src/Core/EigenBase.h ****     * Deprecation is not marked with a doxygen comment because there are too many existing usages t
  38:./Eigen/src/Core/EigenBase.h ****     */
  39:./Eigen/src/Core/EigenBase.h ****   typedef Eigen::Index Index;
  40:./Eigen/src/Core/EigenBase.h **** 
  41:./Eigen/src/Core/EigenBase.h ****   // FIXME is it needed?
  42:./Eigen/src/Core/EigenBase.h ****   typedef typename internal::traits<Derived>::StorageKind StorageKind;
  43:./Eigen/src/Core/EigenBase.h **** 
  44:./Eigen/src/Core/EigenBase.h ****   /** \returns a reference to the derived object */
  45:./Eigen/src/Core/EigenBase.h ****   EIGEN_DEVICE_FUNC
  46:./Eigen/src/Core/EigenBase.h ****   Derived& derived() { return *static_cast<Derived*>(this); }
  47:./Eigen/src/Core/EigenBase.h ****   /** \returns a const reference to the derived object */
  48:./Eigen/src/Core/EigenBase.h ****   EIGEN_DEVICE_FUNC
  49:./Eigen/src/Core/EigenBase.h ****   const Derived& derived() const { return *static_cast<const Derived*>(this); }
 1136              		.loc 16 49 18 view .LVU191
 1137              		.loc 16 49 18 is_stmt 0 view .LVU192
 1138              	.LBE409:
 423:./Eigen/src/Core/Matrix.h ****       : Base(other.derived())
 1139              		.loc 15 423 29 view .LVU193
 1140 0010 12A9     		add	r1, sp, #72
 1141              	.LVL70:
 1142              		.loc 15 423 29 view .LVU194
 1143 0012 6846     		mov	r0, sp
 1144 0014 FFF7FEFF 		bl	_ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8intern
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 153


 1145              	.LVL71:
 1146              		.loc 15 423 29 view .LVU195
 1147              	.LBE408:
 1148              	.LBE407:
 1149              	.LBE406:
   5:HigherLevelApps/HigherLevelApps.c/mpc.cpp ****     return 0;
 1150              		.loc 1 5 5 is_stmt 1 view .LVU196
   6:HigherLevelApps/HigherLevelApps.c/mpc.cpp **** }...
 1151              		.loc 1 6 1 is_stmt 0 view .LVU197
 1152 0018 0020     		movs	r0, #0
 1153 001a 15B0     		add	sp, sp, #84
 1154              	.LCFI22:
 1155              		.cfi_def_cfa_offset 4
 1156              		@ sp needed
 1157 001c 5DF804FB 		ldr	pc, [sp], #4
 1158              		.cfi_endproc
 1159              	.LFE8591:
 1160              		.fnend
 1162              		.text
 1163              	.Letext0:
 1164              		.file 17 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\basic_string.h"
 1165              		.file 18 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cmath"
 1166              		.file 19 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\type_traits"
 1167              		.file 20 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\arm-none-eabi\\thumb\\v7e-m+fp
 1168              		.file 21 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\debug\\debug.h"
 1169              		.file 22 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cwchar"
 1170              		.file 23 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\exception_ptr.h"
 1171              		.file 24 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\char_traits.h"
 1172              		.file 25 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cstdint"
 1173              		.file 26 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\clocale"
 1174              		.file 27 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\new_allocator.h"
 1175              		.file 28 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\allocator.h"
 1176              		.file 29 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\string_view"
 1177              		.file 30 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\complex"
 1178              		.file 31 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cstdlib"
 1179              		.file 32 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cstdio"
 1180              		.file 33 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\alloc_traits.h"
 1181              		.file 34 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\initializer_list"
 1182              		.file 35 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\stringfwd.h"
 1183              		.file 36 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\system_error"
 1184              		.file 37 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cwctype"
 1185              		.file 38 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cstddef"
 1186              		.file 39 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\stl_iterator.h"
 1187              		.file 40 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\functional"
 1188              		.file 41 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\cstring"
 1189              		.file 42 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\stl_iterator_base_types.
 1190              		.file 43 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\bits\\predefined_ops.h"
 1191              		.file 44 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\ext\\alloc_traits.h"
 1192              		.file 45 "c:\\msys64\\mingw64\\lib\\gcc\\arm-none-eabi\\12.2.0\\include\\stddef.h"
 1193              		.file 46 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\machine\\_default_types.h"
 1194              		.file 47 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\sys\\_types.h"
 1195              		.file 48 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\sys\\reent.h"
 1196              		.file 49 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\sys\\lock.h"
 1197              		.file 50 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\math.h"
 1198              		.file 51 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\stdlib.h"
 1199              		.file 52 "c:\\msys64\\mingw64\\lib\\gcc\\arm-none-eabi\\12.2.0\\include\\stdarg.h"
 1200              		.file 53 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\wchar.h"
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 154


 1201              		.file 54 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\sys\\_stdint.h"
 1202              		.file 55 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\stdint.h"
 1203              		.file 56 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\locale.h"
 1204              		.file 57 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\stdio.h"
 1205              		.file 58 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\wctype.h"
 1206              		.file 59 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\string.h"
 1207              		.file 60 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\c++\\12.2.0\\pstl\\execution_defs.h"
 1208              		.file 61 "./Eigen/Core"
 1209              		.file 62 "./Eigen/src/Core/util/Constants.h"
 1210              		.file 63 "./Eigen/src/Core/GenericPacketMath.h"
 1211              		.file 64 "./Eigen/src/Core/arch/Default/BFloat16.h"
 1212              		.file 65 "./Eigen/src/Core/util/IndexedViewHelper.h"
 1213              		.file 66 "./Eigen/src/Core/util/IntegralConstant.h"
 1214              		.file 67 "./Eigen/src/Core/products/GeneralBlockPanelKernel.h"
 1215              		.file 68 "./Eigen/src/Core/util/Meta.h"
 1216              		.file 69 "./Eigen/src/Core/util/ForwardDeclarations.h"
 1217              		.file 70 "./Eigen/src/Core/Transpose.h"
 1218              		.file 71 "./Eigen/src/Core/NumTraits.h"
 1219              		.file 72 "./Eigen/src/Core/arch/Default/Half.h"
 1220              		.file 73 "<built-in>"
 1221              		.file 74 "./Eigen/src/Core/util/SymbolicIndex.h"
 1222              		.file 75 "./Eigen/src/Core/util/ReshapedHelper.h"
 1223              		.file 76 "./Eigen/src/Core/ArithmeticSequence.h"
 1224              		.file 77 "./Eigen/src/Core/IO.h"
 1225              		.file 78 "./Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
 1226              		.file 79 "./Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
 1227              		.file 80 "./Eigen/src/Core/Assign.h"
 1228              		.file 81 "./Eigen/src/Core/Dot.h"
 1229              		.file 82 "./Eigen/src/Core/StableNorm.h"
 1230              		.file 83 "./Eigen/src/Core/Diagonal.h"
 1231              		.file 84 "./Eigen/src/Core/DiagonalMatrix.h"
 1232              		.file 85 "./Eigen/src/Core/PermutationMatrix.h"
 1233              		.file 86 "./Eigen/src/Core/TriangularMatrix.h"
 1234              		.file 87 "./Eigen/src/Core/NoAlias.h"
 1235              		.file 88 "./Eigen/src/Core/Redux.h"
 1236              		.file 89 "./Eigen/src/LU/FullPivLU.h"
 1237              		.file 90 "./Eigen/src/LU/PartialPivLU.h"
 1238              		.file 91 "./Eigen/src/LU/InverseImpl.h"
 1239              		.file 92 "./Eigen/src/LU/Determinant.h"
 1240              		.file 93 "./Eigen/src/Cholesky/LLT.h"
 1241              		.file 94 "./Eigen/src/Cholesky/LDLT.h"
 1242              		.file 95 "./Eigen/src/QR/HouseholderQR.h"
 1243              		.file 96 "./Eigen/src/QR/ColPivHouseholderQR.h"
 1244              		.file 97 "./Eigen/src/QR/FullPivHouseholderQR.h"
 1245              		.file 98 "./Eigen/src/QR/CompleteOrthogonalDecomposition.h"
 1246              		.file 99 "./Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
 1247              		.file 100 "./Eigen/src/SVD/JacobiSVD.h"
 1248              		.file 101 "./Eigen/src/SVD/BDCSVD.h"
 1249              		.file 102 "./Eigen/src/Geometry/OrthoMethods.h"
 1250              		.file 103 "./Eigen/src/Geometry/EulerAngles.h"
 1251              		.file 104 "./Eigen/src/Geometry/Homogeneous.h"
 1252              		.file 105 "./Eigen/src/Householder/Householder.h"
 1253              		.file 106 "./Eigen/src/Core/CommaInitializer.h"
 1254              		.file 107 "./Eigen/src/Core/Fuzzy.h"
 1255              		.file 108 "./Eigen/src/Core/BooleanRedux.h"
 1256              		.file 109 "./Eigen/src/Core/SelfCwiseBinaryOp.h"
 1257              		.file 110 "./Eigen/src/Core/NestByValue.h"
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 155


 1258              		.file 111 "./Eigen/src/Core/VectorwiseOp.h"
 1259              		.file 112 "./Eigen/src/Core/Reverse.h"
 1260              		.file 113 "./Eigen/src/Core/StlIterators.h"
 1261              		.file 114 "./Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
 1262              		.file 115 "./Eigen/src/Core/../plugins/BlockMethods.h"
 1263              		.file 116 "./Eigen/src/Core/../plugins/ReshapedMethods.h"
 1264              		.file 117 "c:\\msys64\\mingw64\\arm-none-eabi\\include\\assert.h"
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 156


DEFINED SYMBOLS
                            *ABS*:00000000 mpc.cpp
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:21     .rodata._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei.str1.4:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:32     .text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:38     .text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000000 _ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:77     .text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000014 $d
.ARM.extab.text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000000 $d
.ARM.exidx.text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:38     .text._ZN5Eigen8internal19variable_if_dynamicIiLi3EEC2Ei:00000000 _ZN5Eigen8internal19variable_if_dynamicIiLi3EEC1Ei
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:88     .rodata._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_.str1.4:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:104    .text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:110    .text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_:00000000 _ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:184    .text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_:00000030 $d
.ARM.exidx.text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:110    .text._ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2EiiRKS3_:00000000 _ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC1EiiRKS3_
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:195    .rodata._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii.str1.4:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:214    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:220    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:00000000 _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:266    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:00000024 $d
.ARM.extab.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:00000000 $d
.ARM.exidx.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE6resizeEii:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:279    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:285    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_:00000000 _ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:348    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_:00000048 $d
.ARM.exidx.text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runERKdS4_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:356    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:362    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv:00000000 _ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:398    .text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv:00000024 $d
.ARM.exidx.text._ZN5Eigen8internal19random_default_implIdLb0ELb0EE3runEv:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:406    .text._ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS2_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES4_EEEENS0_9assign_opIddEELi0EE11assignCoeffEi:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:412    .text._ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS2_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES4_EEEENS0_9assign_opIddEELi0EE11assignCoeffEi:00000000 _ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS2_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES4_EEEENS0_9assign_opIddEELi0EE11assignCoeffEi
.ARM.exidx.text._ZN5Eigen8internal31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS2_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES4_EEEENS0_9assign_opIddEELi0EE11assignCoeffEi:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:484    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi7ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:490    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi7ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi7ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi7ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:530    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi6ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:536    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi6ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi6ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi6ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:568    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi5ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:574    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi5ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi5ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi5ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:606    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi4ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:612    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi4ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi4ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi4ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:644    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi3ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:650    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi3ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi3ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi3ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:682    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi2ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:688    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi2ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi2ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi2ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:720    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi1ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:726    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi1ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi1ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi1ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:758    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi0ELi9EE3runERSE_:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:764    .text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi0ELi9EE3runERSE_:00000000 _ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi0ELi9EE3runERSE_
.ARM.exidx.text._ZN5Eigen8internal54copy_using_evaluator_LinearTraversal_CompleteUnrollingINS0_31generic_dense_assignment_kernelINS0_9evaluatorINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEENS3_INS_14CwiseNullaryOpINS0_16scalar_random_opIdEES5_EEEENS0_9assign_opIddEELi0EEELi0ELi9EE3runERSE_:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:796    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERS2_RKNS_9DenseBaseIT_EE:00000000 $t
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s 			page 157


C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:802    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERS2_RKNS_9DenseBaseIT_EE:00000000 _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERS2_RKNS_9DenseBaseIT_EE
.ARM.exidx.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEE12_set_noaliasINS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERS2_RKNS_9DenseBaseIT_EE:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:995    .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:1001   .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE:00000000 _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE
.ARM.exidx.text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE:00000000 $d
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:1001   .text._ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC2INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE:00000000 _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC1INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:1076   .text._Z4testv:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccJL6Mda.s:1082   .text._Z4testv:00000000 _Z4testv
         .ARM.exidx.text._Z4testv:00000000 $d
                           .group:00000000 _ZN5Eigen8internal19variable_if_dynamicIiLi3EEC5Ei
                           .group:00000000 _ZN5Eigen14CwiseNullaryOpINS_8internal16scalar_random_opIdEENS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC5EiiRKS3_
                           .group:00000000 _ZN5Eigen15PlainObjectBaseINS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEEEC5INS_14CwiseNullaryOpINS_8internal16scalar_random_opIdEES2_EEEERKNS_9DenseBaseIT_EE

UNDEFINED SYMBOLS
__assert_func
__aeabi_unwind_cpp_pr1
__aeabi_unwind_cpp_pr0
__aeabi_dsub
__aeabi_i2d
__aeabi_dmul
__aeabi_ddiv
__aeabi_dadd
rand
