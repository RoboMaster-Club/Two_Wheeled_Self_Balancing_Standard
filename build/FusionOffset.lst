ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"FusionOffset.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "BSP/BSP.c/FusionOffset.c"
  20              		.section	.text.FusionOffsetInitialise,"ax",%progbits
  21              		.align	1
  22              		.global	FusionOffsetInitialise
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	FusionOffsetInitialise:
  28              	.LVL0:
  29              	.LFB21:
   1:BSP/BSP.c/FusionOffset.c **** /**
   2:BSP/BSP.c/FusionOffset.c ****  * @file FusionOffset.c
   3:BSP/BSP.c/FusionOffset.c ****  * @author Seb Madgwick
   4:BSP/BSP.c/FusionOffset.c ****  * @brief Gyroscope offset correction algorithm for run-time calibration of the
   5:BSP/BSP.c/FusionOffset.c ****  * gyroscope offset.
   6:BSP/BSP.c/FusionOffset.c ****  */
   7:BSP/BSP.c/FusionOffset.c **** 
   8:BSP/BSP.c/FusionOffset.c **** //------------------------------------------------------------------------------
   9:BSP/BSP.c/FusionOffset.c **** // Includes
  10:BSP/BSP.c/FusionOffset.c **** 
  11:BSP/BSP.c/FusionOffset.c **** #include "FusionOffset.h"
  12:BSP/BSP.c/FusionOffset.c **** #include <math.h> // fabs
  13:BSP/BSP.c/FusionOffset.c **** 
  14:BSP/BSP.c/FusionOffset.c **** //------------------------------------------------------------------------------
  15:BSP/BSP.c/FusionOffset.c **** // Definitions
  16:BSP/BSP.c/FusionOffset.c **** 
  17:BSP/BSP.c/FusionOffset.c **** /**
  18:BSP/BSP.c/FusionOffset.c ****  * @brief Cutoff frequency in Hz.
  19:BSP/BSP.c/FusionOffset.c ****  */
  20:BSP/BSP.c/FusionOffset.c **** #define CUTOFF_FREQUENCY (0.02f)
  21:BSP/BSP.c/FusionOffset.c **** 
  22:BSP/BSP.c/FusionOffset.c **** /**
  23:BSP/BSP.c/FusionOffset.c ****  * @brief Timeout in seconds.
  24:BSP/BSP.c/FusionOffset.c ****  */
  25:BSP/BSP.c/FusionOffset.c **** #define TIMEOUT (5)
  26:BSP/BSP.c/FusionOffset.c **** 
  27:BSP/BSP.c/FusionOffset.c **** /**
  28:BSP/BSP.c/FusionOffset.c ****  * @brief Threshold in degrees per second.
  29:BSP/BSP.c/FusionOffset.c ****  */
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 2


  30:BSP/BSP.c/FusionOffset.c **** #define THRESHOLD (3.0f)
  31:BSP/BSP.c/FusionOffset.c **** 
  32:BSP/BSP.c/FusionOffset.c **** //------------------------------------------------------------------------------
  33:BSP/BSP.c/FusionOffset.c **** // Functions
  34:BSP/BSP.c/FusionOffset.c **** 
  35:BSP/BSP.c/FusionOffset.c **** /**
  36:BSP/BSP.c/FusionOffset.c ****  * @brief Initialises the gyroscope offset algorithm.
  37:BSP/BSP.c/FusionOffset.c ****  * @param offset Gyroscope offset algorithm structure.
  38:BSP/BSP.c/FusionOffset.c ****  * @param sampleRate Sample rate in Hz.
  39:BSP/BSP.c/FusionOffset.c ****  */
  40:BSP/BSP.c/FusionOffset.c **** void FusionOffsetInitialise(FusionOffset *const offset, const unsigned int sampleRate) {
  30              		.loc 1 40 88 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		@ link register save eliminated.
  41:BSP/BSP.c/FusionOffset.c ****     offset->filterCoefficient = 2.0f * (float) M_PI * CUTOFF_FREQUENCY * (1.0f / (float) sampleRate
  35              		.loc 1 41 5 view .LVU1
  36              		.loc 1 41 82 is_stmt 0 view .LVU2
  37 0000 07EE901A 		vmov	s15, r1	@ int
  38 0004 B8EE677A 		vcvt.f32.u32	s14, s15
  39              		.loc 1 41 80 view .LVU3
  40 0008 F7EE006A 		vmov.f32	s13, #1.0e+0
  41 000c C6EE877A 		vdiv.f32	s15, s13, s14
  42              		.loc 1 41 72 view .LVU4
  43 0010 9FED077A 		vldr.32	s14, .L2
  44 0014 67EE877A 		vmul.f32	s15, s15, s14
  45              		.loc 1 41 31 view .LVU5
  46 0018 C0ED007A 		vstr.32	s15, [r0]
  42:BSP/BSP.c/FusionOffset.c ****     offset->timeout = TIMEOUT * sampleRate;
  47              		.loc 1 42 5 is_stmt 1 view .LVU6
  48              		.loc 1 42 31 is_stmt 0 view .LVU7
  49 001c 01EB8101 		add	r1, r1, r1, lsl #2
  50              	.LVL1:
  51              		.loc 1 42 21 view .LVU8
  52 0020 4160     		str	r1, [r0, #4]
  43:BSP/BSP.c/FusionOffset.c ****     offset->timer = 0;
  53              		.loc 1 43 5 is_stmt 1 view .LVU9
  54              		.loc 1 43 19 is_stmt 0 view .LVU10
  55 0022 0023     		movs	r3, #0
  56 0024 8360     		str	r3, [r0, #8]
  44:BSP/BSP.c/FusionOffset.c ****     offset->gyroscopeOffset = FUSION_VECTOR_ZERO;
  57              		.loc 1 44 5 is_stmt 1 view .LVU11
  58              		.loc 1 44 29 is_stmt 0 view .LVU12
  59 0026 0023     		movs	r3, #0
  60 0028 C360     		str	r3, [r0, #12]	@ float
  61 002a 0361     		str	r3, [r0, #16]	@ float
  62 002c 4361     		str	r3, [r0, #20]	@ float
  45:BSP/BSP.c/FusionOffset.c **** }
  63              		.loc 1 45 1 view .LVU13
  64 002e 7047     		bx	lr
  65              	.L3:
  66              		.align	2
  67              	.L2:
  68 0030 FDAD003E 		.word	1040231933
  69              		.cfi_endproc
  70              	.LFE21:
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 3


  72              		.section	.text.FusionOffsetUpdate,"ax",%progbits
  73              		.align	1
  74              		.global	FusionOffsetUpdate
  75              		.syntax unified
  76              		.thumb
  77              		.thumb_func
  79              	FusionOffsetUpdate:
  80              	.LVL2:
  81              	.LFB22:
  46:BSP/BSP.c/FusionOffset.c **** 
  47:BSP/BSP.c/FusionOffset.c **** /**
  48:BSP/BSP.c/FusionOffset.c ****  * @brief Updates the gyroscope offset algorithm and returns the corrected
  49:BSP/BSP.c/FusionOffset.c ****  * gyroscope measurement.
  50:BSP/BSP.c/FusionOffset.c ****  * @param offset Gyroscope offset algorithm structure.
  51:BSP/BSP.c/FusionOffset.c ****  * @param gyroscope Gyroscope measurement in degrees per second.
  52:BSP/BSP.c/FusionOffset.c ****  * @return Corrected gyroscope measurement in degrees per second.
  53:BSP/BSP.c/FusionOffset.c ****  */
  54:BSP/BSP.c/FusionOffset.c **** FusionVector FusionOffsetUpdate(FusionOffset *const offset, FusionVector gyroscope) {
  82              		.loc 1 54 85 is_stmt 1 view -0
  83              		.cfi_startproc
  84              		@ args = 0, pretend = 0, frame = 128
  85              		@ frame_needed = 0, uses_anonymous_args = 0
  86              		.loc 1 54 85 is_stmt 0 view .LVU15
  87 0000 10B5     		push	{r4, lr}
  88              	.LCFI0:
  89              		.cfi_def_cfa_offset 8
  90              		.cfi_offset 4, -8
  91              		.cfi_offset 14, -4
  92 0002 A0B0     		sub	sp, sp, #128
  93              	.LCFI1:
  94              		.cfi_def_cfa_offset 136
  95 0004 0346     		mov	r3, r0
  96 0006 8DED050A 		vstr.32	s0, [sp, #20]
  97 000a CDED060A 		vstr.32	s1, [sp, #24]
  98 000e 8DED071A 		vstr.32	s2, [sp, #28]
  55:BSP/BSP.c/FusionOffset.c **** 
  56:BSP/BSP.c/FusionOffset.c ****     // Subtract offset from gyroscope measurement
  57:BSP/BSP.c/FusionOffset.c ****     gyroscope = FusionVectorSubtract(gyroscope, offset->gyroscopeOffset);
  99              		.loc 1 57 5 is_stmt 1 view .LVU16
 100 0012 0DF1200C 		add	ip, sp, #32
 101 0016 00F10C02 		add	r2, r0, #12
 102 001a 07CA     		ldm	r2, {r0, r1, r2}
 103              	.LVL3:
 104              		.loc 1 57 5 is_stmt 0 view .LVU17
 105 001c 8CE80700 		stm	ip, {r0, r1, r2}
 106              	.LBB8:
 107              	.LBI8:
 108              		.file 2 "BSP/BSP.h/FusionMath.h"
   1:BSP/BSP.h/FusionMath.h **** /**
   2:BSP/BSP.h/FusionMath.h ****  * @file FusionMath.h
   3:BSP/BSP.h/FusionMath.h ****  * @author Seb Madgwick
   4:BSP/BSP.h/FusionMath.h ****  * @brief Math library.
   5:BSP/BSP.h/FusionMath.h ****  */
   6:BSP/BSP.h/FusionMath.h **** 
   7:BSP/BSP.h/FusionMath.h **** #ifndef FUSION_MATH_H
   8:BSP/BSP.h/FusionMath.h **** #define FUSION_MATH_H
   9:BSP/BSP.h/FusionMath.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 4


  10:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
  11:BSP/BSP.h/FusionMath.h **** // Includes
  12:BSP/BSP.h/FusionMath.h **** 
  13:BSP/BSP.h/FusionMath.h **** #include <math.h> // M_PI, sqrtf, atan2f, asinf
  14:BSP/BSP.h/FusionMath.h **** #include <stdbool.h>
  15:BSP/BSP.h/FusionMath.h **** #include <stdint.h>
  16:BSP/BSP.h/FusionMath.h **** 
  17:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
  18:BSP/BSP.h/FusionMath.h **** // Definitions
  19:BSP/BSP.h/FusionMath.h **** 
  20:BSP/BSP.h/FusionMath.h **** /**
  21:BSP/BSP.h/FusionMath.h ****  * @brief 3D vector.
  22:BSP/BSP.h/FusionMath.h ****  */
  23:BSP/BSP.h/FusionMath.h **** typedef union {
  24:BSP/BSP.h/FusionMath.h ****     float array[3];
  25:BSP/BSP.h/FusionMath.h **** 
  26:BSP/BSP.h/FusionMath.h ****     struct {
  27:BSP/BSP.h/FusionMath.h ****         float x;
  28:BSP/BSP.h/FusionMath.h ****         float y;
  29:BSP/BSP.h/FusionMath.h ****         float z;
  30:BSP/BSP.h/FusionMath.h ****     } axis;
  31:BSP/BSP.h/FusionMath.h **** } FusionVector;
  32:BSP/BSP.h/FusionMath.h **** 
  33:BSP/BSP.h/FusionMath.h **** /**
  34:BSP/BSP.h/FusionMath.h ****  * @brief Quaternion.
  35:BSP/BSP.h/FusionMath.h ****  */
  36:BSP/BSP.h/FusionMath.h **** typedef union {
  37:BSP/BSP.h/FusionMath.h ****     float array[4];
  38:BSP/BSP.h/FusionMath.h **** 
  39:BSP/BSP.h/FusionMath.h ****     struct {
  40:BSP/BSP.h/FusionMath.h ****         float w;
  41:BSP/BSP.h/FusionMath.h ****         float x;
  42:BSP/BSP.h/FusionMath.h ****         float y;
  43:BSP/BSP.h/FusionMath.h ****         float z;
  44:BSP/BSP.h/FusionMath.h ****     } element;
  45:BSP/BSP.h/FusionMath.h **** } FusionQuaternion;
  46:BSP/BSP.h/FusionMath.h **** 
  47:BSP/BSP.h/FusionMath.h **** /**
  48:BSP/BSP.h/FusionMath.h ****  * @brief 3x3 matrix in row-major order.
  49:BSP/BSP.h/FusionMath.h ****  * See http://en.wikipedia.org/wiki/Row-major_order
  50:BSP/BSP.h/FusionMath.h ****  */
  51:BSP/BSP.h/FusionMath.h **** typedef union {
  52:BSP/BSP.h/FusionMath.h ****     float array[3][3];
  53:BSP/BSP.h/FusionMath.h **** 
  54:BSP/BSP.h/FusionMath.h ****     struct {
  55:BSP/BSP.h/FusionMath.h ****         float xx;
  56:BSP/BSP.h/FusionMath.h ****         float xy;
  57:BSP/BSP.h/FusionMath.h ****         float xz;
  58:BSP/BSP.h/FusionMath.h ****         float yx;
  59:BSP/BSP.h/FusionMath.h ****         float yy;
  60:BSP/BSP.h/FusionMath.h ****         float yz;
  61:BSP/BSP.h/FusionMath.h ****         float zx;
  62:BSP/BSP.h/FusionMath.h ****         float zy;
  63:BSP/BSP.h/FusionMath.h ****         float zz;
  64:BSP/BSP.h/FusionMath.h ****     } element;
  65:BSP/BSP.h/FusionMath.h **** } FusionMatrix;
  66:BSP/BSP.h/FusionMath.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 5


  67:BSP/BSP.h/FusionMath.h **** /**
  68:BSP/BSP.h/FusionMath.h ****  * @brief Euler angles.  Roll, pitch, and yaw correspond to rotations around
  69:BSP/BSP.h/FusionMath.h ****  * X, Y, and Z respectively.
  70:BSP/BSP.h/FusionMath.h ****  */
  71:BSP/BSP.h/FusionMath.h **** typedef union {
  72:BSP/BSP.h/FusionMath.h ****     float array[3];
  73:BSP/BSP.h/FusionMath.h **** 
  74:BSP/BSP.h/FusionMath.h ****     struct {
  75:BSP/BSP.h/FusionMath.h ****         float roll;
  76:BSP/BSP.h/FusionMath.h ****         float pitch;
  77:BSP/BSP.h/FusionMath.h ****         float yaw;
  78:BSP/BSP.h/FusionMath.h ****     } angle;
  79:BSP/BSP.h/FusionMath.h **** } FusionEuler;
  80:BSP/BSP.h/FusionMath.h **** 
  81:BSP/BSP.h/FusionMath.h **** /**
  82:BSP/BSP.h/FusionMath.h ****  * @brief Vector of zeros.
  83:BSP/BSP.h/FusionMath.h ****  */
  84:BSP/BSP.h/FusionMath.h **** #define FUSION_VECTOR_ZERO ((FusionVector){ .array = {0.0f, 0.0f, 0.0f} })
  85:BSP/BSP.h/FusionMath.h **** 
  86:BSP/BSP.h/FusionMath.h **** /**
  87:BSP/BSP.h/FusionMath.h ****  * @brief Vector of ones.
  88:BSP/BSP.h/FusionMath.h ****  */
  89:BSP/BSP.h/FusionMath.h **** #define FUSION_VECTOR_ONES ((FusionVector){ .array = {1.0f, 1.0f, 1.0f} })
  90:BSP/BSP.h/FusionMath.h **** 
  91:BSP/BSP.h/FusionMath.h **** /**
  92:BSP/BSP.h/FusionMath.h ****  * @brief Identity quaternion.
  93:BSP/BSP.h/FusionMath.h ****  */
  94:BSP/BSP.h/FusionMath.h **** #define FUSION_IDENTITY_QUATERNION ((FusionQuaternion){ .array = {1.0f, 0.0f, 0.0f, 0.0f} })
  95:BSP/BSP.h/FusionMath.h **** 
  96:BSP/BSP.h/FusionMath.h **** /**
  97:BSP/BSP.h/FusionMath.h ****  * @brief Identity matrix.
  98:BSP/BSP.h/FusionMath.h ****  */
  99:BSP/BSP.h/FusionMath.h **** #define FUSION_IDENTITY_MATRIX ((FusionMatrix){ .array = {{1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {
 100:BSP/BSP.h/FusionMath.h **** 
 101:BSP/BSP.h/FusionMath.h **** /**
 102:BSP/BSP.h/FusionMath.h ****  * @brief Euler angles of zero.
 103:BSP/BSP.h/FusionMath.h ****  */
 104:BSP/BSP.h/FusionMath.h **** #define FUSION_EULER_ZERO ((FusionEuler){ .array = {0.0f, 0.0f, 0.0f} })
 105:BSP/BSP.h/FusionMath.h **** 
 106:BSP/BSP.h/FusionMath.h **** /**
 107:BSP/BSP.h/FusionMath.h ****  * @brief Pi. May not be defined in math.h.
 108:BSP/BSP.h/FusionMath.h ****  */
 109:BSP/BSP.h/FusionMath.h **** #ifndef M_PI
 110:BSP/BSP.h/FusionMath.h **** #define M_PI (3.14159265358979323846)
 111:BSP/BSP.h/FusionMath.h **** #endif
 112:BSP/BSP.h/FusionMath.h **** 
 113:BSP/BSP.h/FusionMath.h **** /**
 114:BSP/BSP.h/FusionMath.h ****  * @brief Include this definition or add as a preprocessor definition to use
 115:BSP/BSP.h/FusionMath.h ****  * normal square root operations.
 116:BSP/BSP.h/FusionMath.h ****  */
 117:BSP/BSP.h/FusionMath.h **** //#define FUSION_USE_NORMAL_SQRT
 118:BSP/BSP.h/FusionMath.h **** 
 119:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
 120:BSP/BSP.h/FusionMath.h **** // Inline functions - Degrees and radians conversion
 121:BSP/BSP.h/FusionMath.h **** 
 122:BSP/BSP.h/FusionMath.h **** /**
 123:BSP/BSP.h/FusionMath.h ****  * @brief Converts degrees to radians.
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 6


 124:BSP/BSP.h/FusionMath.h ****  * @param degrees Degrees.
 125:BSP/BSP.h/FusionMath.h ****  * @return Radians.
 126:BSP/BSP.h/FusionMath.h ****  */
 127:BSP/BSP.h/FusionMath.h **** static inline float FusionDegreesToRadians(const float degrees) {
 128:BSP/BSP.h/FusionMath.h ****     return degrees * ((float) M_PI / 180.0f);
 129:BSP/BSP.h/FusionMath.h **** }
 130:BSP/BSP.h/FusionMath.h **** 
 131:BSP/BSP.h/FusionMath.h **** /**
 132:BSP/BSP.h/FusionMath.h ****  * @brief Converts radians to degrees.
 133:BSP/BSP.h/FusionMath.h ****  * @param radians Radians.
 134:BSP/BSP.h/FusionMath.h ****  * @return Degrees.
 135:BSP/BSP.h/FusionMath.h ****  */
 136:BSP/BSP.h/FusionMath.h **** static inline float FusionRadiansToDegrees(const float radians) {
 137:BSP/BSP.h/FusionMath.h ****     return radians * (180.0f / (float) M_PI);
 138:BSP/BSP.h/FusionMath.h **** }
 139:BSP/BSP.h/FusionMath.h **** 
 140:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
 141:BSP/BSP.h/FusionMath.h **** // Inline functions - Arc sine
 142:BSP/BSP.h/FusionMath.h **** 
 143:BSP/BSP.h/FusionMath.h **** /**
 144:BSP/BSP.h/FusionMath.h ****  * @brief Returns the arc sine of the value.
 145:BSP/BSP.h/FusionMath.h ****  * @param value Value.
 146:BSP/BSP.h/FusionMath.h ****  * @return Arc sine of the value.
 147:BSP/BSP.h/FusionMath.h ****  */
 148:BSP/BSP.h/FusionMath.h **** static inline float FusionAsin(const float value) {
 149:BSP/BSP.h/FusionMath.h ****     if (value <= -1.0f) {
 150:BSP/BSP.h/FusionMath.h ****         return (float) M_PI / -2.0f;
 151:BSP/BSP.h/FusionMath.h ****     }
 152:BSP/BSP.h/FusionMath.h ****     if (value >= 1.0f) {
 153:BSP/BSP.h/FusionMath.h ****         return (float) M_PI / 2.0f;
 154:BSP/BSP.h/FusionMath.h ****     }
 155:BSP/BSP.h/FusionMath.h ****     return asinf(value);
 156:BSP/BSP.h/FusionMath.h **** }
 157:BSP/BSP.h/FusionMath.h **** 
 158:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
 159:BSP/BSP.h/FusionMath.h **** // Inline functions - Fast inverse square root
 160:BSP/BSP.h/FusionMath.h **** 
 161:BSP/BSP.h/FusionMath.h **** #ifndef FUSION_USE_NORMAL_SQRT
 162:BSP/BSP.h/FusionMath.h **** 
 163:BSP/BSP.h/FusionMath.h **** /**
 164:BSP/BSP.h/FusionMath.h ****  * @brief Calculates the reciprocal of the square root.
 165:BSP/BSP.h/FusionMath.h ****  * See https://pizer.wordpress.com/2008/10/12/fast-inverse-square-root/
 166:BSP/BSP.h/FusionMath.h ****  * @param x Operand.
 167:BSP/BSP.h/FusionMath.h ****  * @return Reciprocal of the square root of x.
 168:BSP/BSP.h/FusionMath.h ****  */
 169:BSP/BSP.h/FusionMath.h **** static inline float FusionFastInverseSqrt(const float x) {
 170:BSP/BSP.h/FusionMath.h **** 
 171:BSP/BSP.h/FusionMath.h ****     typedef union {
 172:BSP/BSP.h/FusionMath.h ****         float f;
 173:BSP/BSP.h/FusionMath.h ****         int32_t i;
 174:BSP/BSP.h/FusionMath.h ****     } Union32;
 175:BSP/BSP.h/FusionMath.h **** 
 176:BSP/BSP.h/FusionMath.h ****     Union32 union32 = {.f = x};
 177:BSP/BSP.h/FusionMath.h ****     union32.i = 0x5F1F1412 - (union32.i >> 1);
 178:BSP/BSP.h/FusionMath.h ****     return union32.f * (1.69000231f - 0.714158168f * x * union32.f * union32.f);
 179:BSP/BSP.h/FusionMath.h **** }
 180:BSP/BSP.h/FusionMath.h **** 
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 7


 181:BSP/BSP.h/FusionMath.h **** #endif
 182:BSP/BSP.h/FusionMath.h **** 
 183:BSP/BSP.h/FusionMath.h **** //------------------------------------------------------------------------------
 184:BSP/BSP.h/FusionMath.h **** // Inline functions - Vector operations
 185:BSP/BSP.h/FusionMath.h **** 
 186:BSP/BSP.h/FusionMath.h **** /**
 187:BSP/BSP.h/FusionMath.h ****  * @brief Returns true if the vector is zero.
 188:BSP/BSP.h/FusionMath.h ****  * @param vector Vector.
 189:BSP/BSP.h/FusionMath.h ****  * @return True if the vector is zero.
 190:BSP/BSP.h/FusionMath.h ****  */
 191:BSP/BSP.h/FusionMath.h **** static inline bool FusionVectorIsZero(const FusionVector vector) {
 192:BSP/BSP.h/FusionMath.h ****     return (vector.axis.x == 0.0f) && (vector.axis.y == 0.0f) && (vector.axis.z == 0.0f);
 193:BSP/BSP.h/FusionMath.h **** }
 194:BSP/BSP.h/FusionMath.h **** 
 195:BSP/BSP.h/FusionMath.h **** /**
 196:BSP/BSP.h/FusionMath.h ****  * @brief Returns the sum of two vectors.
 197:BSP/BSP.h/FusionMath.h ****  * @param vectorA Vector A.
 198:BSP/BSP.h/FusionMath.h ****  * @param vectorB Vector B.
 199:BSP/BSP.h/FusionMath.h ****  * @return Sum of two vectors.
 200:BSP/BSP.h/FusionMath.h ****  */
 201:BSP/BSP.h/FusionMath.h **** static inline FusionVector FusionVectorAdd(const FusionVector vectorA, const FusionVector vectorB) 
 202:BSP/BSP.h/FusionMath.h ****     FusionVector result;
 203:BSP/BSP.h/FusionMath.h ****     result.axis.x = vectorA.axis.x + vectorB.axis.x;
 204:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y + vectorB.axis.y;
 205:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z + vectorB.axis.z;
 206:BSP/BSP.h/FusionMath.h ****     return result;
 207:BSP/BSP.h/FusionMath.h **** }
 208:BSP/BSP.h/FusionMath.h **** 
 209:BSP/BSP.h/FusionMath.h **** /**
 210:BSP/BSP.h/FusionMath.h ****  * @brief Returns vector B subtracted from vector A.
 211:BSP/BSP.h/FusionMath.h ****  * @param vectorA Vector A.
 212:BSP/BSP.h/FusionMath.h ****  * @param vectorB Vector B.
 213:BSP/BSP.h/FusionMath.h ****  * @return Vector B subtracted from vector A.
 214:BSP/BSP.h/FusionMath.h ****  */
 215:BSP/BSP.h/FusionMath.h **** static inline FusionVector FusionVectorSubtract(const FusionVector vectorA, const FusionVector vect
 109              		.loc 2 215 28 is_stmt 1 view .LVU18
 110              	.LBB9:
 216:BSP/BSP.h/FusionMath.h ****     FusionVector result;
 111              		.loc 2 216 5 view .LVU19
 217:BSP/BSP.h/FusionMath.h ****     result.axis.x = vectorA.axis.x - vectorB.axis.x;
 112              		.loc 2 217 5 view .LVU20
 113              		.loc 2 217 50 is_stmt 0 view .LVU21
 114 0020 DDED087A 		vldr.32	s15, [sp, #32]
 115              		.loc 2 217 36 view .LVU22
 116 0024 30EE670A 		vsub.f32	s0, s0, s15
 117              		.loc 2 217 19 view .LVU23
 118 0028 8DED0B0A 		vstr.32	s0, [sp, #44]
 218:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y - vectorB.axis.y;
 119              		.loc 2 218 5 is_stmt 1 view .LVU24
 120              		.loc 2 218 50 is_stmt 0 view .LVU25
 121 002c DDED097A 		vldr.32	s15, [sp, #36]
 122              		.loc 2 218 36 view .LVU26
 123 0030 70EEE70A 		vsub.f32	s1, s1, s15
 124              		.loc 2 218 19 view .LVU27
 125 0034 CDED0C0A 		vstr.32	s1, [sp, #48]
 219:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z - vectorB.axis.z;
 126              		.loc 2 219 5 is_stmt 1 view .LVU28
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 8


 127              		.loc 2 219 50 is_stmt 0 view .LVU29
 128 0038 DDED0A7A 		vldr.32	s15, [sp, #40]
 129              		.loc 2 219 36 view .LVU30
 130 003c 31EE671A 		vsub.f32	s2, s2, s15
 131              		.loc 2 219 19 view .LVU31
 132 0040 8DED0D1A 		vstr.32	s2, [sp, #52]
 220:BSP/BSP.h/FusionMath.h ****     return result;
 133              		.loc 2 220 5 is_stmt 1 view .LVU32
 134              		.loc 2 220 12 is_stmt 0 view .LVU33
 135 0044 0DF1500C 		add	ip, sp, #80
 136 0048 0BAA     		add	r2, sp, #44
 137 004a 07CA     		ldm	r2, {r0, r1, r2}
 138 004c 8CE80700 		stm	ip, {r0, r1, r2}
 139 0050 0DF1140E 		add	lr, sp, #20
 140 0054 8EE80700 		stm	lr, {r0, r1, r2}
 141              	.LBE9:
 142              	.LBE8:
  58:BSP/BSP.c/FusionOffset.c **** 
  59:BSP/BSP.c/FusionOffset.c ****     // Reset timer if gyroscope not stationary
  60:BSP/BSP.c/FusionOffset.c ****     if ((fabs(gyroscope.axis.x) > THRESHOLD) || (fabs(gyroscope.axis.y) > THRESHOLD) || (fabs(gyros
 143              		.loc 1 60 5 is_stmt 1 view .LVU34
 144              		.loc 1 60 10 is_stmt 0 view .LVU35
 145 0058 B0EEC07A 		vabs.f32	s14, s0
 146              		.loc 1 60 8 view .LVU36
 147 005c F0EE087A 		vmov.f32	s15, #3.0e+0
 148 0060 B4EEE77A 		vcmpe.f32	s14, s15
 149 0064 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 150 0068 58DC     		bgt	.L5
 151              		.loc 1 60 50 discriminator 1 view .LVU37
 152 006a F0EEE07A 		vabs.f32	s15, s1
 153              		.loc 1 60 46 discriminator 1 view .LVU38
 154 006e B0EE087A 		vmov.f32	s14, #3.0e+0
 155 0072 F4EEC77A 		vcmpe.f32	s15, s14
 156 0076 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 157 007a 4FDC     		bgt	.L5
 158              		.loc 1 60 90 discriminator 2 view .LVU39
 159 007c F0EEC17A 		vabs.f32	s15, s2
 160              		.loc 1 60 86 discriminator 2 view .LVU40
 161 0080 F4EEC77A 		vcmpe.f32	s15, s14
 162 0084 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 163 0088 48DC     		bgt	.L5
  61:BSP/BSP.c/FusionOffset.c ****         offset->timer = 0;
  62:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
  63:BSP/BSP.c/FusionOffset.c ****     }
  64:BSP/BSP.c/FusionOffset.c **** 
  65:BSP/BSP.c/FusionOffset.c ****     // Increment timer while gyroscope stationary
  66:BSP/BSP.c/FusionOffset.c ****     if (offset->timer < offset->timeout) {
 164              		.loc 1 66 5 is_stmt 1 view .LVU41
 165              		.loc 1 66 15 is_stmt 0 view .LVU42
 166 008a 9A68     		ldr	r2, [r3, #8]
 167              		.loc 1 66 31 view .LVU43
 168 008c 5968     		ldr	r1, [r3, #4]
 169              		.loc 1 66 8 view .LVU44
 170 008e 8A42     		cmp	r2, r1
 171 0090 53D3     		bcc	.L12
  67:BSP/BSP.c/FusionOffset.c ****         offset->timer++;
  68:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 9


  69:BSP/BSP.c/FusionOffset.c ****     }
  70:BSP/BSP.c/FusionOffset.c **** 
  71:BSP/BSP.c/FusionOffset.c ****     // Adjust offset if timer has elapsed
  72:BSP/BSP.c/FusionOffset.c ****     offset->gyroscopeOffset = FusionVectorAdd(offset->gyroscopeOffset, FusionVectorMultiplyScalar(g
 172              		.loc 1 72 5 is_stmt 1 view .LVU45
 173              		.loc 1 72 31 is_stmt 0 view .LVU46
 174 0092 1A46     		mov	r2, r3
 175 0094 0C33     		adds	r3, r3, #12
 176              	.LVL4:
 177              		.loc 1 72 31 view .LVU47
 178 0096 D2ED007A 		vldr.32	s15, [r2]
 179              	.LVL5:
 180              	.LBB10:
 181              	.LBI10:
 221:BSP/BSP.h/FusionMath.h **** }
 222:BSP/BSP.h/FusionMath.h **** 
 223:BSP/BSP.h/FusionMath.h **** /**
 224:BSP/BSP.h/FusionMath.h ****  * @brief Returns the sum of the elements.
 225:BSP/BSP.h/FusionMath.h ****  * @param vector Vector.
 226:BSP/BSP.h/FusionMath.h ****  * @return Sum of the elements.
 227:BSP/BSP.h/FusionMath.h ****  */
 228:BSP/BSP.h/FusionMath.h **** static inline float FusionVectorSum(const FusionVector vector) {
 229:BSP/BSP.h/FusionMath.h ****     return vector.axis.x + vector.axis.y + vector.axis.z;
 230:BSP/BSP.h/FusionMath.h **** }
 231:BSP/BSP.h/FusionMath.h **** 
 232:BSP/BSP.h/FusionMath.h **** /**
 233:BSP/BSP.h/FusionMath.h ****  * @brief Returns the multiplication of a vector by a scalar.
 234:BSP/BSP.h/FusionMath.h ****  * @param vector Vector.
 235:BSP/BSP.h/FusionMath.h ****  * @param scalar Scalar.
 236:BSP/BSP.h/FusionMath.h ****  * @return Multiplication of a vector by a scalar.
 237:BSP/BSP.h/FusionMath.h ****  */
 238:BSP/BSP.h/FusionMath.h **** static inline FusionVector FusionVectorMultiplyScalar(const FusionVector vector, const float scalar
 182              		.loc 2 238 28 is_stmt 1 view .LVU48
 183              	.LBB11:
 239:BSP/BSP.h/FusionMath.h ****     FusionVector result;
 184              		.loc 2 239 5 view .LVU49
 240:BSP/BSP.h/FusionMath.h ****     result.axis.x = vector.axis.x * scalar;
 185              		.loc 2 240 5 view .LVU50
 186              		.loc 2 240 35 is_stmt 0 view .LVU51
 187 009a 27EE800A 		vmul.f32	s0, s15, s0
 188              		.loc 2 240 19 view .LVU52
 189 009e 8DED0B0A 		vstr.32	s0, [sp, #44]
 241:BSP/BSP.h/FusionMath.h ****     result.axis.y = vector.axis.y * scalar;
 190              		.loc 2 241 5 is_stmt 1 view .LVU53
 191              		.loc 2 241 35 is_stmt 0 view .LVU54
 192 00a2 67EEA00A 		vmul.f32	s1, s15, s1
 193              		.loc 2 241 19 view .LVU55
 194 00a6 CDED0C0A 		vstr.32	s1, [sp, #48]
 242:BSP/BSP.h/FusionMath.h ****     result.axis.z = vector.axis.z * scalar;
 195              		.loc 2 242 5 is_stmt 1 view .LVU56
 196              		.loc 2 242 35 is_stmt 0 view .LVU57
 197 00aa 67EE817A 		vmul.f32	s15, s15, s2
 198              	.LVL6:
 199              		.loc 2 242 19 view .LVU58
 200 00ae CDED0D7A 		vstr.32	s15, [sp, #52]
 243:BSP/BSP.h/FusionMath.h ****     return result;
 201              		.loc 2 243 5 is_stmt 1 view .LVU59
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 10


 202              		.loc 2 243 12 is_stmt 0 view .LVU60
 203 00b2 0DF1740E 		add	lr, sp, #116
 204 00b6 0DF12C0C 		add	ip, sp, #44
 205 00ba 9CE80700 		ldm	ip, {r0, r1, r2}
 206              	.LVL7:
 207              		.loc 2 243 12 view .LVU61
 208 00be 8EE80700 		stm	lr, {r0, r1, r2}
 209 00c2 11AC     		add	r4, sp, #68
 210 00c4 84E80700 		stm	r4, {r0, r1, r2}
 211              	.LVL8:
 212              		.loc 2 243 12 view .LVU62
 213 00c8 0DF1200E 		add	lr, sp, #32
 214 00cc 93E80700 		ldm	r3, {r0, r1, r2}
 215 00d0 8EE80700 		stm	lr, {r0, r1, r2}
 216              	.LBE11:
 217              	.LBE10:
 218              	.LBB12:
 219              	.LBI12:
 201:BSP/BSP.h/FusionMath.h ****     FusionVector result;
 220              		.loc 2 201 28 is_stmt 1 view .LVU63
 221              	.LBB13:
 202:BSP/BSP.h/FusionMath.h ****     result.axis.x = vectorA.axis.x + vectorB.axis.x;
 222              		.loc 2 202 5 view .LVU64
 203:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y + vectorB.axis.y;
 223              		.loc 2 203 5 view .LVU65
 203:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y + vectorB.axis.y;
 224              		.loc 2 203 33 is_stmt 0 view .LVU66
 225 00d4 9DED087A 		vldr.32	s14, [sp, #32]
 203:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y + vectorB.axis.y;
 226              		.loc 2 203 36 view .LVU67
 227 00d8 37EE007A 		vadd.f32	s14, s14, s0
 203:BSP/BSP.h/FusionMath.h ****     result.axis.y = vectorA.axis.y + vectorB.axis.y;
 228              		.loc 2 203 19 view .LVU68
 229 00dc 8DED0B7A 		vstr.32	s14, [sp, #44]
 204:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z + vectorB.axis.z;
 230              		.loc 2 204 5 is_stmt 1 view .LVU69
 204:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z + vectorB.axis.z;
 231              		.loc 2 204 33 is_stmt 0 view .LVU70
 232 00e0 9DED097A 		vldr.32	s14, [sp, #36]
 204:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z + vectorB.axis.z;
 233              		.loc 2 204 36 view .LVU71
 234 00e4 37EE207A 		vadd.f32	s14, s14, s1
 204:BSP/BSP.h/FusionMath.h ****     result.axis.z = vectorA.axis.z + vectorB.axis.z;
 235              		.loc 2 204 19 view .LVU72
 236 00e8 8DED0C7A 		vstr.32	s14, [sp, #48]
 205:BSP/BSP.h/FusionMath.h ****     return result;
 237              		.loc 2 205 5 is_stmt 1 view .LVU73
 205:BSP/BSP.h/FusionMath.h ****     return result;
 238              		.loc 2 205 33 is_stmt 0 view .LVU74
 239 00ec 9DED0A7A 		vldr.32	s14, [sp, #40]
 205:BSP/BSP.h/FusionMath.h ****     return result;
 240              		.loc 2 205 36 view .LVU75
 241 00f0 77EE277A 		vadd.f32	s15, s14, s15
 205:BSP/BSP.h/FusionMath.h ****     return result;
 242              		.loc 2 205 19 view .LVU76
 243 00f4 CDED0D7A 		vstr.32	s15, [sp, #52]
 206:BSP/BSP.h/FusionMath.h **** }
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 11


 244              		.loc 2 206 5 is_stmt 1 view .LVU77
 206:BSP/BSP.h/FusionMath.h **** }
 245              		.loc 2 206 12 is_stmt 0 view .LVU78
 246 00f8 0DF1680E 		add	lr, sp, #104
 247 00fc 9CE80700 		ldm	ip, {r0, r1, r2}
 248 0100 8EE80700 		stm	lr, {r0, r1, r2}
 249 0104 0DF15C0C 		add	ip, sp, #92
 250 0108 8CE80700 		stm	ip, {r0, r1, r2}
 251              	.LBE13:
 252              	.LBE12:
 253              		.loc 1 72 31 view .LVU79
 254 010c 83E80700 		stm	r3, {r0, r1, r2}
  73:BSP/BSP.c/FusionOffset.c ****     return gyroscope;
 255              		.loc 1 73 5 is_stmt 1 view .LVU80
 256              		.loc 1 73 12 is_stmt 0 view .LVU81
 257 0110 0EAB     		add	r3, sp, #56
 258              	.LVL9:
 259              		.loc 1 73 12 view .LVU82
 260 0112 05AA     		add	r2, sp, #20
 261 0114 07CA     		ldm	r2, {r0, r1, r2}
 262 0116 83E80700 		stm	r3, {r0, r1, r2}
 263 011a 06E0     		b	.L8
 264              	.LVL10:
 265              	.L5:
  61:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
 266              		.loc 1 61 9 is_stmt 1 view .LVU83
  61:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
 267              		.loc 1 61 23 is_stmt 0 view .LVU84
 268 011c 0022     		movs	r2, #0
 269 011e 9A60     		str	r2, [r3, #8]
  62:BSP/BSP.c/FusionOffset.c ****     }
 270              		.loc 1 62 9 is_stmt 1 view .LVU85
  62:BSP/BSP.c/FusionOffset.c ****     }
 271              		.loc 1 62 16 is_stmt 0 view .LVU86
 272 0120 0EAB     		add	r3, sp, #56
 273              	.LVL11:
  62:BSP/BSP.c/FusionOffset.c ****     }
 274              		.loc 1 62 16 view .LVU87
 275 0122 05AA     		add	r2, sp, #20
 276 0124 07CA     		ldm	r2, {r0, r1, r2}
 277 0126 83E80700 		stm	r3, {r0, r1, r2}
 278              	.L8:
  74:BSP/BSP.c/FusionOffset.c **** }
 279              		.loc 1 74 1 view .LVU88
 280 012a 9DED0E0A 		vldr.32	s0, [sp, #56]
 281 012e DDED0F0A 		vldr.32	s1, [sp, #60]
 282 0132 9DED101A 		vldr.32	s2, [sp, #64]
 283 0136 20B0     		add	sp, sp, #128
 284              	.LCFI2:
 285              		.cfi_remember_state
 286              		.cfi_def_cfa_offset 8
 287              		@ sp needed
 288 0138 10BD     		pop	{r4, pc}
 289              	.LVL12:
 290              	.L12:
 291              	.LCFI3:
 292              		.cfi_restore_state
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 12


  67:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
 293              		.loc 1 67 9 is_stmt 1 view .LVU89
  67:BSP/BSP.c/FusionOffset.c ****         return gyroscope;
 294              		.loc 1 67 22 is_stmt 0 view .LVU90
 295 013a 0132     		adds	r2, r2, #1
 296 013c 9A60     		str	r2, [r3, #8]
  68:BSP/BSP.c/FusionOffset.c ****     }
 297              		.loc 1 68 9 is_stmt 1 view .LVU91
  68:BSP/BSP.c/FusionOffset.c ****     }
 298              		.loc 1 68 16 is_stmt 0 view .LVU92
 299 013e 0EAB     		add	r3, sp, #56
 300              	.LVL13:
  68:BSP/BSP.c/FusionOffset.c ****     }
 301              		.loc 1 68 16 view .LVU93
 302 0140 05AA     		add	r2, sp, #20
 303 0142 07CA     		ldm	r2, {r0, r1, r2}
 304 0144 83E80700 		stm	r3, {r0, r1, r2}
 305 0148 EFE7     		b	.L8
 306              		.cfi_endproc
 307              	.LFE22:
 309              		.text
 310              	.Letext0:
 311              		.file 3 "BSP/BSP.h/FusionOffset.h"
ARM GAS  C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s 			page 13


DEFINED SYMBOLS
                            *ABS*:00000000 FusionOffset.c
C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s:21     .text.FusionOffsetInitialise:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s:27     .text.FusionOffsetInitialise:00000000 FusionOffsetInitialise
C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s:68     .text.FusionOffsetInitialise:00000030 $d
C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s:73     .text.FusionOffsetUpdate:00000000 $t
C:\Users\purdu\AppData\Local\Temp\ccU9kAlm.s:79     .text.FusionOffsetUpdate:00000000 FusionOffsetUpdate

NO UNDEFINED SYMBOLS
